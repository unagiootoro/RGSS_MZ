RGSS_MODE = :client
RGSS_ENABLE_MARSHAL = false
GRAPHICS_FILE_LIST = ["Graphics/Tilesets/007-Swamp01.png",
 "Graphics/Tilesets/009-CastleTown01.png",
 "Graphics/Tilesets/029-Church02.png",
 "Graphics/Tilesets/006-Desert01.png",
 "Graphics/Tilesets/046-Cave04.png",
 "Graphics/Tilesets/040-Tower02.png",
 "Graphics/Tilesets/028-Church01.png",
 "Graphics/Tilesets/023-FarmVillage01.png",
 "Graphics/Tilesets/013-PostTown01.png",
 "Graphics/Tilesets/032-Heaven01.png",
 "Graphics/Tilesets/050-DarkSpace01.png",
 "Graphics/Tilesets/003-Forest01.png",
 "Graphics/Tilesets/030-Ship01.png",
 "Graphics/Tilesets/001-Grassland01.png",
 "Graphics/Tilesets/035-Ruins01.png",
 "Graphics/Tilesets/043-Cave01.png",
 "Graphics/Tilesets/021-SnowTown01.png",
 "Graphics/Tilesets/034-Bridge01.png",
 "Graphics/Tilesets/020-DesertTown02.png",
 "Graphics/Tilesets/016-ForestTown02.png",
 "Graphics/Tilesets/038-Fort02.png",
 "Graphics/Tilesets/047-Mine01.png",
 "Graphics/Tilesets/015-ForestTown01.png",
 "Graphics/Tilesets/024-FarmVillage02.png",
 "Graphics/Tilesets/019-DesertTown01.png",
 "Graphics/Tilesets/048-Sewer01.png",
 "Graphics/Tilesets/025-Castle01.png",
 "Graphics/Tilesets/027-Castle03.png",
 "Graphics/Tilesets/002-Woods01.png",
 "Graphics/Tilesets/041-EvilCastle01.png",
 "Graphics/Tilesets/014-PostTown02.png",
 "Graphics/Tilesets/008-Snowfield01.png",
 "Graphics/Tilesets/033-Heaven02.png",
 "Graphics/Tilesets/026-Castle02.png",
 "Graphics/Tilesets/004-Mountain01.png",
 "Graphics/Tilesets/017-MineTown01.png",
 "Graphics/Tilesets/005-Beach01.png",
 "Graphics/Tilesets/042-EvilCastle02.png",
 "Graphics/Tilesets/037-Fort01.png",
 "Graphics/Tilesets/011-PortTown01.png",
 "Graphics/Tilesets/036-Shop01.png",
 "Graphics/Tilesets/018-MineTown02.png",
 "Graphics/Tilesets/022-SnowTown02.png",
 "Graphics/Tilesets/049-InnerBody01.png",
 "Graphics/Tilesets/045-Cave03.png",
 "Graphics/Tilesets/039-Tower01.png",
 "Graphics/Tilesets/010-CastleTown02.png",
 "Graphics/Tilesets/012-PortTown02.png",
 "Graphics/Tilesets/031-Ship02.png",
 "Graphics/Tilesets/044-Cave02.png",
 "Graphics/Windowskins/001-Blue01.png",
 "Graphics/Transitions/006-Stripe02.png",
 "Graphics/Transitions/016-Diamond02.png",
 "Graphics/Transitions/011-Random03.png",
 "Graphics/Transitions/002-Blind02.png",
 "Graphics/Transitions/001-Blind01.png",
 "Graphics/Transitions/010-Random02.png",
 "Graphics/Transitions/005-Stripe01.png",
 "Graphics/Transitions/008-Line02.png",
 "Graphics/Transitions/007-Line01.png",
 "Graphics/Transitions/009-Random01.png",
 "Graphics/Transitions/004-Blind04.png",
 "Graphics/Transitions/017-Brick01.png",
 "Graphics/Transitions/003-Blind03.png",
 "Graphics/Transitions/018-Brick02.png",
 "Graphics/Transitions/015-Diamond01.png",
 "Graphics/Transitions/020-Flat01.png",
 "Graphics/Transitions/013-Square01.png",
 "Graphics/Transitions/019-Whorl01.png",
 "Graphics/Transitions/014-Square02.png",
 "Graphics/Transitions/012-Random04.png",
 "Graphics/Icons/008-Weapon08.png",
 "Graphics/Icons/016-Accessory01.png",
 "Graphics/Icons/002-Weapon02.png",
 "Graphics/Icons/026-Herb02.png",
 "Graphics/Icons/007-Weapon07.png",
 "Graphics/Icons/018-Accessory03.png",
 "Graphics/Icons/041-Item10.png",
 "Graphics/Icons/035-Item04.png",
 "Graphics/Icons/029-Key01.png",
 "Graphics/Icons/005-Weapon05.png",
 "Graphics/Icons/049-Skill06.png",
 "Graphics/Icons/006-Weapon06.png",
 "Graphics/Icons/020-Accessory05.png",
 "Graphics/Icons/039-Item08.png",
 "Graphics/Icons/017-Accessory02.png",
 "Graphics/Icons/047-Skill04.png",
 "Graphics/Icons/034-Item03.png",
 "Graphics/Icons/010-Head01.png",
 "Graphics/Icons/048-Skill05.png",
 "Graphics/Icons/011-Head02.png",
 "Graphics/Icons/040-Item09.png",
 "Graphics/Icons/045-Skill02.png",
 "Graphics/Icons/012-Head03.png",
 "Graphics/Icons/009-Shield01.png",
 "Graphics/Icons/036-Item05.png",
 "Graphics/Icons/013-Body01.png",
 "Graphics/Icons/031-Key03.png",
 "Graphics/Icons/044-Skill01.png",
 "Graphics/Icons/038-Item07.png",
 "Graphics/Icons/014-Body02.png",
 "Graphics/Icons/033-Item02.png",
 "Graphics/Icons/050-Skill07.png",
 "Graphics/Icons/001-Weapon01.png",
 "Graphics/Icons/046-Skill03.png",
 "Graphics/Icons/021-Potion01.png",
 "Graphics/Icons/043-Item12.png",
 "Graphics/Icons/019-Accessory04.png",
 "Graphics/Icons/022-Potion02.png",
 "Graphics/Icons/042-Item11.png",
 "Graphics/Icons/027-Herb03.png",
 "Graphics/Icons/025-Herb01.png",
 "Graphics/Icons/037-Item06.png",
 "Graphics/Icons/032-Item01.png",
 "Graphics/Icons/003-Weapon03.png",
 "Graphics/Icons/023-Potion03.png",
 "Graphics/Icons/015-Body03.png",
 "Graphics/Icons/004-Weapon04.png",
 "Graphics/Icons/028-Herb04.png",
 "Graphics/Icons/030-Key02.png",
 "Graphics/Icons/024-Potion04.png",
 "Graphics/Titles/001-Title01.jpg",
 "Graphics/Autotiles/030-Sn_Ground01.png",
 "Graphics/Autotiles/062-CF_Lava01.png",
 "Graphics/Autotiles/041-Grass01.png",
 "Graphics/Autotiles/076-CW_Grass01.png",
 "Graphics/Autotiles/053-Wall01.png",
 "Graphics/Autotiles/002-G_Shadow01.png",
 "Graphics/Autotiles/025-Ocean02.png",
 "Graphics/Autotiles/061-CE_Road01.png",
 "Graphics/Autotiles/023-Sa_Undulation01.png",
 "Graphics/Autotiles/019-Sa_Grass02.png",
 "Graphics/Autotiles/078-CW_Ground01.png",
 "Graphics/Autotiles/024-Ocean01.png",
 "Graphics/Autotiles/001-G_Water01.png",
 "Graphics/Autotiles/064-CF_Ground01.png",
 "Graphics/Autotiles/068-CI_Water01.png",
 "Graphics/Autotiles/043-Grass02.png",
 "Graphics/Autotiles/015-Sa_Water01.png",
 "Graphics/Autotiles/026-Ocean03.png",
 "Graphics/Autotiles/065-CF_Ground02.png",
 "Graphics/Autotiles/080-B_Ground01.png",
 "Graphics/Autotiles/067-CF_Ground04.png",
 "Graphics/Autotiles/066-CF_Ground03.png",
 "Graphics/Autotiles/008-G_Undulation02.png",
 "Graphics/Autotiles/033-Waterfall01.png",
 "Graphics/Autotiles/077-CW_Grass02.png",
 "Graphics/Autotiles/004-G_Ground02.png",
 "Graphics/Autotiles/070-CI_Snow01.png",
 "Graphics/Autotiles/037-Tree02.png",
 "Graphics/Autotiles/028-Sn_Water01.png",
 "Graphics/Autotiles/003-G_Ground01.png",
 "Graphics/Autotiles/058-CE_Ground01.png",
 "Graphics/Autotiles/055-Wall03.png",
 "Graphics/Autotiles/006-G_Road02.png",
 "Graphics/Autotiles/069-CI_Shadow01.png",
 "Graphics/Autotiles/081-B_Ground02.png",
 "Graphics/Autotiles/011-G2_Ground02.png",
 "Graphics/Autotiles/057-CE_Shadow01.png",
 "Graphics/Autotiles/042-Ground02.png",
 "Graphics/Autotiles/009-G2_Water01.png",
 "Graphics/Autotiles/047-Flower01.png",
 "Graphics/Autotiles/035-Waterfall03.png",
 "Graphics/Autotiles/074-CW_Water01.png",
 "Graphics/Autotiles/022-Roof01.png",
 "Graphics/Autotiles/075-CW_Shadow01.png",
 "Graphics/Autotiles/049-St_Shadow01.png",
 "Graphics/Autotiles/039-Tree04.png",
 "Graphics/Autotiles/038-Tree03.png",
 "Graphics/Autotiles/005-G_Road01.png",
 "Graphics/Autotiles/063-CF_Shadow01.png",
 "Graphics/Autotiles/018-Sa_Ground01.png",
 "Graphics/Autotiles/014-G2_Swamp03.png",
 "Graphics/Autotiles/021-Sa_Road01.png",
 "Graphics/Autotiles/017-Sa_Grass01.png",
 "Graphics/Autotiles/007-G_Undulation01.png",
 "Graphics/Autotiles/016-Sa_Shadow01.png",
 "Graphics/Autotiles/031-Sn_Undulation01.png",
 "Graphics/Autotiles/051-Carpet01.png",
 "Graphics/Autotiles/071-CI_Ground01.png",
 "Graphics/Autotiles/054-Wall02.png",
 "Graphics/Autotiles/027-Ocean04.png",
 "Graphics/Autotiles/050-Roof02.png",
 "Graphics/Autotiles/044-Road01.png",
 "Graphics/Autotiles/052-Carpet02.png",
 "Graphics/Autotiles/012-G2_Swamp01.png",
 "Graphics/Autotiles/036-Tree01.png",
 "Graphics/Autotiles/079-CW_Grass03.png",
 "Graphics/Autotiles/046-Road03.png",
 "Graphics/Autotiles/060-CE_Grass01.png",
 "Graphics/Autotiles/010-G2_Ground01.png",
 "Graphics/Autotiles/048-Water01.png",
 "Graphics/Autotiles/059-CE_Ground02.png",
 "Graphics/Autotiles/032-T_Ocean01.png",
 "Graphics/Autotiles/013-G2_Swamp02.png",
 "Graphics/Autotiles/034-Waterfall02.png",
 "Graphics/Autotiles/040-Ground01.png",
 "Graphics/Autotiles/020-Sa_Grass03.png",
 "Graphics/Autotiles/056-CE_Water01.png",
 "Graphics/Autotiles/072-CI_Ice01.png",
 "Graphics/Autotiles/045-Road02.png",
 "Graphics/Autotiles/073-CI_Ground02.png",
 "Graphics/Autotiles/029-Sn_Shadow01.png",
 "Graphics/Characters/143-Farmer01.png",
 "Graphics/Characters/182-Rock01.png",
 "Graphics/Characters/195-Support03.png",
 "Graphics/Characters/179-Switch02.png",
 "Graphics/Characters/188-Wagon01.png",
 "Graphics/Characters/021-Hunter02.png",
 "Graphics/Characters/093-Monster07.png",
 "Graphics/Characters/172-Door03.png",
 "Graphics/Characters/023-Gunner01.png",
 "Graphics/Characters/082-Angel04.png",
 "Graphics/Characters/030-Cleric06.png",
 "Graphics/Characters/107-Civilian07.png",
 "Graphics/Characters/118-Civilian18.png",
 "Graphics/Characters/142-Scholar01.png",
 "Graphics/Characters/080-Angel02.png",
 "Graphics/Characters/022-Hunter03.png",
 "Graphics/Characters/180-Switch03.png",
 "Graphics/Characters/186-Bulletin01.png",
 "Graphics/Characters/006-Fighter06.png",
 "Graphics/Characters/164-Small06.png",
 "Graphics/Characters/088-Monster02.png",
 "Graphics/Characters/167-Small09.png",
 "Graphics/Characters/019-Thief04.png",
 "Graphics/Characters/007-Fighter07.png",
 "Graphics/Characters/136-Bartender01.png",
 "Graphics/Characters/132-Noble07.png",
 "Graphics/Characters/041-Mage09.png",
 "Graphics/Characters/085-Elemental03.png",
 "Graphics/Characters/109-Civilian09.png",
 "Graphics/Characters/128-Noble03.png",
 "Graphics/Characters/035-Mage03.png",
 "Graphics/Characters/174-Chest01.png",
 "Graphics/Characters/189-Down01.png",
 "Graphics/Characters/131-Noble06.png",
 "Graphics/Characters/185-Light02.png",
 "Graphics/Characters/121-Civilian21.png",
 "Graphics/Characters/045-Fortuneteller01.png",
 "Graphics/Characters/114-Civilian14.png",
 "Graphics/Characters/039-Mage07.png",
 "Graphics/Characters/076-Devil02.png",
 "Graphics/Characters/200-Support08.png",
 "Graphics/Characters/064-Beast02.png",
 "Graphics/Characters/115-Civilian15.png",
 "Graphics/Characters/116-Civilian16.png",
 "Graphics/Characters/029-Cleric05.png",
 "Graphics/Characters/014-Warrior02.png",
 "Graphics/Characters/183-Rock02.png",
 "Graphics/Characters/184-Light01.png",
 "Graphics/Characters/157-Animal07.png",
 "Graphics/Characters/048-Fairy01.png",
 "Graphics/Characters/144-Farmer02.png",
 "Graphics/Characters/065-Beast03.PNG",
 "Graphics/Characters/054-Undead04.png",
 "Graphics/Characters/154-Animal04.png",
 "Graphics/Characters/198-Support06.png",
 "Graphics/Characters/003-Fighter03.png",
 "Graphics/Characters/178-Switch01.png",
 "Graphics/Characters/177-Chest04.png",
 "Graphics/Characters/175-Chest02.png",
 "Graphics/Characters/197-Support05.png",
 "Graphics/Characters/081-Angel03.png",
 "Graphics/Characters/110-Civilian10.png",
 "Graphics/Characters/083-Elemental01.png",
 "Graphics/Characters/148-Storekeeper02.png",
 "Graphics/Characters/025-Cleric01.png",
 "Graphics/Characters/134-Butler01.png",
 "Graphics/Characters/077-Devil03.png",
 "Graphics/Characters/059-Aquatic01.png",
 "Graphics/Characters/026-Cleric02.png",
 "Graphics/Characters/002-Fighter02.png",
 "Graphics/Characters/078-Devil04.png",
 "Graphics/Characters/173-Door04.png",
 "Graphics/Characters/190-Down02.png",
 "Graphics/Characters/149-Captain01.png",
 "Graphics/Characters/067-Goblin01.png",
 "Graphics/Characters/171-Door02.png",
 "Graphics/Characters/135-Maid01.png",
 "Graphics/Characters/060-Aquatic02.png",
 "Graphics/Characters/024-Gunner02.png",
 "Graphics/Characters/162-Small04.png",
 "Graphics/Characters/009-Lancer01.png",
 "Graphics/Characters/012-Lancer04.png",
 "Graphics/Characters/108-Civilian08.png",
 "Graphics/Characters/016-Thief01.png",
 "Graphics/Characters/166-Small08.png",
 "Graphics/Characters/101-Civilian01.png",
 "Graphics/Characters/033-Mage01.png",
 "Graphics/Characters/126-Noble01.png",
 "Graphics/Characters/156-Animal06.png",
 "Graphics/Characters/100-Monster14.png",
 "Graphics/Characters/066-Beast04.png",
 "Graphics/Characters/084-Elemental02.png",
 "Graphics/Characters/130-Noble05.png",
 "Graphics/Characters/008-Fighter08.png",
 "Graphics/Characters/050-Soldier02.png",
 "Graphics/Characters/137-BunnyGirl01.png",
 "Graphics/Characters/001-Fighter01.png",
 "Graphics/Characters/159-Small01.png",
 "Graphics/Characters/163-Small05.png",
 "Graphics/Characters/091-Monster05.png",
 "Graphics/Characters/196-Support04.png",
 "Graphics/Characters/049-Soldier01.png",
 "Graphics/Characters/062-Aquatic04.png",
 "Graphics/Characters/141-Bard01.png",
 "Graphics/Characters/098-Monster12.png",
 "Graphics/Characters/168-Small10.png",
 "Graphics/Characters/042-King01.png",
 "Graphics/Characters/090-Monster04.png",
 "Graphics/Characters/155-Animal05.png",
 "Graphics/Characters/011-Lancer03.png",
 "Graphics/Characters/158-Animal08.png",
 "Graphics/Characters/047-Grappler02.png",
 "Graphics/Characters/176-Chest03.png",
 "Graphics/Characters/089-Monster03.png",
 "Graphics/Characters/129-Noble04.png",
 "Graphics/Characters/063-Beast01.png",
 "Graphics/Characters/051-Undead01.png",
 "Graphics/Characters/069-Goblin03.png",
 "Graphics/Characters/187-Lorry01.png",
 "Graphics/Characters/119-Civilian19.png",
 "Graphics/Characters/013-Warrior01.png",
 "Graphics/Characters/122-Civilian22.png",
 "Graphics/Characters/146-Prisoner02.png",
 "Graphics/Characters/120-Civilian20.png",
 "Graphics/Characters/073-Bird03.png",
 "Graphics/Characters/160-Small02.png",
 "Graphics/Characters/044-Trader01.png",
 "Graphics/Characters/140-Dancer01.png",
 "Graphics/Characters/034-Mage02.png",
 "Graphics/Characters/150-Sailor01.png",
 "Graphics/Characters/124-Civilian24.png",
 "Graphics/Characters/056-Snake02.png",
 "Graphics/Characters/191-Down03.png",
 "Graphics/Characters/017-Thief02.png",
 "Graphics/Characters/055-Snake01.png",
 "Graphics/Characters/032-Cleric08.png",
 "Graphics/Characters/125-Baby01.png",
 "Graphics/Characters/079-Angel01.png",
 "Graphics/Characters/075-Devil01.png",
 "Graphics/Characters/092-Monster06.png",
 "Graphics/Characters/027-Cleric03.png",
 "Graphics/Characters/015-Warrior03.png",
 "Graphics/Characters/071-Bird01.png",
 "Graphics/Characters/074-Bird04.png",
 "Graphics/Characters/112-Civilian12.png",
 "Graphics/Characters/037-Mage05.png",
 "Graphics/Characters/111-Civilian11.png",
 "Graphics/Characters/028-Cleric04.png",
 "Graphics/Characters/096-Monster10.png",
 "Graphics/Characters/087-Monster01.png",
 "Graphics/Characters/070-Goblin04.png",
 "Graphics/Characters/147-Storekeeper01.png",
 "Graphics/Characters/192-Down04.png",
 "Graphics/Characters/161-Small03.png",
 "Graphics/Characters/004-Fighter04.png",
 "Graphics/Characters/010-Lancer02.png",
 "Graphics/Characters/139-Clown01.png",
 "Graphics/Characters/072-Bird02.png",
 "Graphics/Characters/193-Support01.png",
 "Graphics/Characters/086-Elemental04.png",
 "Graphics/Characters/152-Animal02.png",
 "Graphics/Characters/046-Grappler01.png",
 "Graphics/Characters/165-Small07.png",
 "Graphics/Characters/005-Fighter05.png",
 "Graphics/Characters/113-Civilian13.png",
 "Graphics/Characters/099-Monster13.png",
 "Graphics/Characters/104-Civilian04.png",
 "Graphics/Characters/036-Mage04.png",
 "Graphics/Characters/031-Cleric07.png",
 "Graphics/Characters/018-Thief03.png",
 "Graphics/Characters/138-Cook01.png",
 "Graphics/Characters/058-Snake04.png",
 "Graphics/Characters/020-Hunter01.png",
 "Graphics/Characters/133-Noble08.png",
 "Graphics/Characters/123-Civilian23.png",
 "Graphics/Characters/106-Civilian06.png",
 "Graphics/Characters/153-Animal03.png",
 "Graphics/Characters/199-Support07.png",
 "Graphics/Characters/105-Civilian05.png",
 "Graphics/Characters/097-Monster11.png",
 "Graphics/Characters/052-Undead02.png",
 "Graphics/Characters/094-Monster08.png",
 "Graphics/Characters/068-Goblin02.png",
 "Graphics/Characters/127-Noble02.png",
 "Graphics/Characters/043-Queen01.png",
 "Graphics/Characters/053-Undead03.png",
 "Graphics/Characters/038-Mage06.png",
 "Graphics/Characters/095-Monster09.png",
 "Graphics/Characters/170-Door01.png",
 "Graphics/Characters/117-Civilian17.png",
 "Graphics/Characters/102-Civilian02.png",
 "Graphics/Characters/057-Snake03.png",
 "Graphics/Characters/169-Small11.png",
 "Graphics/Characters/181-Switch04.png",
 "Graphics/Characters/061-Aquatic03.png",
 "Graphics/Characters/151-Animal01.png",
 "Graphics/Characters/040-Mage08.png",
 "Graphics/Characters/145-Prisoner01.png",
 "Graphics/Characters/194-Support02.png",
 "Graphics/Characters/103-Civilian03.png",
 "Graphics/Battlers/021-Hunter02.png",
 "Graphics/Battlers/093-Monster07.png",
 "Graphics/Battlers/023-Gunner01.png",
 "Graphics/Battlers/082-Angel04.png",
 "Graphics/Battlers/030-Cleric06.png",
 "Graphics/Battlers/080-Angel02.png",
 "Graphics/Battlers/022-Hunter03.png",
 "Graphics/Battlers/006-Fighter06.png",
 "Graphics/Battlers/065-Beast03.png",
 "Graphics/Battlers/088-Monster02.png",
 "Graphics/Battlers/019-Thief04.png",
 "Graphics/Battlers/007-Fighter07.png",
 "Graphics/Battlers/041-Mage09.png",
 "Graphics/Battlers/085-Elemental03.png",
 "Graphics/Battlers/035-Mage03.png",
 "Graphics/Battlers/045-Fortuneteller01.png",
 "Graphics/Battlers/039-Mage07.png",
 "Graphics/Battlers/076-Devil02.png",
 "Graphics/Battlers/064-Beast02.png",
 "Graphics/Battlers/029-Cleric05.png",
 "Graphics/Battlers/014-Warrior02.png",
 "Graphics/Battlers/048-Fairy01.png",
 "Graphics/Battlers/054-Undead04.png",
 "Graphics/Battlers/003-Fighter03.png",
 "Graphics/Battlers/081-Angel03.png",
 "Graphics/Battlers/083-Elemental01.png",
 "Graphics/Battlers/025-Cleric01.png",
 "Graphics/Battlers/077-Devil03.png",
 "Graphics/Battlers/059-Aquatic01.png",
 "Graphics/Battlers/026-Cleric02.png",
 "Graphics/Battlers/002-Fighter02.png",
 "Graphics/Battlers/078-Devil04.png",
 "Graphics/Battlers/067-Goblin01.png",
 "Graphics/Battlers/060-Aquatic02.png",
 "Graphics/Battlers/024-Gunner02.png",
 "Graphics/Battlers/009-Lancer01.png",
 "Graphics/Battlers/012-Lancer04.png",
 "Graphics/Battlers/016-Thief01.png",
 "Graphics/Battlers/033-Mage01.png",
 "Graphics/Battlers/100-Monster14.png",
 "Graphics/Battlers/066-Beast04.png",
 "Graphics/Battlers/084-Elemental02.png",
 "Graphics/Battlers/008-Fighter08.png",
 "Graphics/Battlers/050-Soldier02.png",
 "Graphics/Battlers/001-Fighter01.png",
 "Graphics/Battlers/091-Monster05.png",
 "Graphics/Battlers/049-Soldier01.png",
 "Graphics/Battlers/062-Aquatic04.png",
 "Graphics/Battlers/098-Monster12.png",
 "Graphics/Battlers/042-King01.png",
 "Graphics/Battlers/090-Monster04.png",
 "Graphics/Battlers/011-Lancer03.png",
 "Graphics/Battlers/047-Grappler02.png",
 "Graphics/Battlers/089-Monster03.png",
 "Graphics/Battlers/063-Beast01.png",
 "Graphics/Battlers/051-Undead01.png",
 "Graphics/Battlers/069-Goblin03.png",
 "Graphics/Battlers/013-Warrior01.png",
 "Graphics/Battlers/073-Bird03.png",
 "Graphics/Battlers/044-Trader01.png",
 "Graphics/Battlers/034-Mage02.png",
 "Graphics/Battlers/056-Snake02.png",
 "Graphics/Battlers/017-Thief02.png",
 "Graphics/Battlers/055-Snake01.png",
 "Graphics/Battlers/032-Cleric08.png",
 "Graphics/Battlers/079-Angel01.png",
 "Graphics/Battlers/075-Devil01.png",
 "Graphics/Battlers/092-Monster06.png",
 "Graphics/Battlers/027-Cleric03.png",
 "Graphics/Battlers/015-Warrior03.png",
 "Graphics/Battlers/071-Bird01.png",
 "Graphics/Battlers/074-Bird04.png",
 "Graphics/Battlers/037-Mage05.png",
 "Graphics/Battlers/028-Cleric04.png",
 "Graphics/Battlers/096-Monster10.png",
 "Graphics/Battlers/087-Monster01.png",
 "Graphics/Battlers/070-Goblin04.png",
 "Graphics/Battlers/004-Fighter04.png",
 "Graphics/Battlers/010-Lancer02.png",
 "Graphics/Battlers/072-Bird02.png",
 "Graphics/Battlers/086-Elemental04.png",
 "Graphics/Battlers/046-Grappler01.png",
 "Graphics/Battlers/005-Fighter05.png",
 "Graphics/Battlers/099-Monster13.png",
 "Graphics/Battlers/036-Mage04.png",
 "Graphics/Battlers/031-Cleric07.png",
 "Graphics/Battlers/018-Thief03.png",
 "Graphics/Battlers/058-Snake04.png",
 "Graphics/Battlers/020-Hunter01.png",
 "Graphics/Battlers/097-Monster11.png",
 "Graphics/Battlers/052-Undead02.png",
 "Graphics/Battlers/094-Monster08.png",
 "Graphics/Battlers/068-Goblin02.png",
 "Graphics/Battlers/043-Queen01.png",
 "Graphics/Battlers/053-Undead03.png",
 "Graphics/Battlers/038-Mage06.png",
 "Graphics/Battlers/095-Monster09.png",
 "Graphics/Battlers/057-Snake03.png",
 "Graphics/Battlers/061-Aquatic03.png",
 "Graphics/Battlers/040-Mage08.png",
 "Graphics/Panoramas/006-Mountains01.jpg",
 "Graphics/Panoramas/001-Sky01.jpg",
 "Graphics/Panoramas/007-Ocean01.jpg",
 "Graphics/Panoramas/003-StarlitSky01.jpg",
 "Graphics/Panoramas/002-Sky02.jpg",
 "Graphics/Panoramas/005-Sunset01.jpg",
 "Graphics/Panoramas/004-CloudySky01.jpg",
 "Graphics/Animations/024-Support01.png",
 "Graphics/Animations/005-Attack03.png",
 "Graphics/Animations/028-State01.png",
 "Graphics/Animations/001-Action01.png",
 "Graphics/Animations/010-Weapon05.png",
 "Graphics/Animations/011-Weapon06.png",
 "Graphics/Animations/026-Support03.png",
 "Graphics/Animations/030-Explosion01.png",
 "Graphics/Animations/017-Thunder01.png",
 "Graphics/Animations/025-Support02.png",
 "Graphics/Animations/029-Emotion01.png",
 "Graphics/Animations/013-Heal02.png",
 "Graphics/Animations/023-Burst01.png",
 "Graphics/Animations/008-Weapon03.png",
 "Graphics/Animations/002-Action02.png",
 "Graphics/Animations/020-Wind01.png",
 "Graphics/Animations/022-Darkness01.png",
 "Graphics/Animations/004-Attack02.png",
 "Graphics/Animations/021-Light01.png",
 "Graphics/Animations/027-Support04.png",
 "Graphics/Animations/009-Weapon04.png",
 "Graphics/Animations/006-Weapon01.png",
 "Graphics/Animations/015-Fire01.png",
 "Graphics/Animations/016-Ice01.png",
 "Graphics/Animations/014-Heal03.png",
 "Graphics/Animations/018-Water01.png",
 "Graphics/Animations/012-Heal01.png",
 "Graphics/Animations/003-Attack01.png",
 "Graphics/Animations/019-Earth01.png",
 "Graphics/Animations/007-Weapon02.png",
 "Graphics/Battlebacks/030-Ship01.jpg",
 "Graphics/Battlebacks/018-MineTown02.jpg",
 "Graphics/Battlebacks/011-PortTown01.jpg",
 "Graphics/Battlebacks/050-DarkSpace01.jpg",
 "Graphics/Battlebacks/019-DesertTown01.jpg",
 "Graphics/Battlebacks/033-Heaven02.jpg",
 "Graphics/Battlebacks/046-Cave04.jpg",
 "Graphics/Battlebacks/022-SnowTown02.jpg",
 "Graphics/Battlebacks/004-Mountain01.jpg",
 "Graphics/Battlebacks/034-Bridge01.jpg",
 "Graphics/Battlebacks/008-Snowfield01.jpg",
 "Graphics/Battlebacks/041-EvilCastle01.jpg",
 "Graphics/Battlebacks/001-Grassland01.jpg",
 "Graphics/Battlebacks/035-Ruins01.jpg",
 "Graphics/Battlebacks/006-Desert01.jpg",
 "Graphics/Battlebacks/025-Castle01.jpg",
 "Graphics/Battlebacks/031-Ship02.jpg",
 "Graphics/Battlebacks/040-Tower02.jpg",
 "Graphics/Battlebacks/020-DesertTown02.jpg",
 "Graphics/Battlebacks/021-SnowTown01.jpg",
 "Graphics/Battlebacks/048-Sewer01.jpg",
 "Graphics/Battlebacks/039-Tower01.jpg",
 "Graphics/Battlebacks/028-Church01.jpg",
 "Graphics/Battlebacks/010-CastleTown02.jpg",
 "Graphics/Battlebacks/003-Forest01.jpg",
 "Graphics/Battlebacks/023-FarmVillage01.jpg",
 "Graphics/Battlebacks/043-Cave01.jpg",
 "Graphics/Battlebacks/012-PortTown02.jpg",
 "Graphics/Battlebacks/013-PostTown01.jpg",
 "Graphics/Battlebacks/016-ForestTown02.jpg",
 "Graphics/Battlebacks/009-CastleTown01.jpg",
 "Graphics/Battlebacks/037-Fort01.jpg",
 "Graphics/Battlebacks/002-Woods01.jpg",
 "Graphics/Battlebacks/032-Heaven01.jpg",
 "Graphics/Battlebacks/024-FarmVillage02.jpg",
 "Graphics/Battlebacks/042-EvilCastle02.jpg",
 "Graphics/Battlebacks/015-ForestTown01.jpg",
 "Graphics/Battlebacks/044-Cave02.jpg",
 "Graphics/Battlebacks/047-Mine01.jpg",
 "Graphics/Battlebacks/045-Cave03.jpg",
 "Graphics/Battlebacks/038-Fort02.jpg",
 "Graphics/Battlebacks/014-PostTown02.jpg",
 "Graphics/Battlebacks/007-Swamp01.jpg",
 "Graphics/Battlebacks/049-InnerBody01.jpg",
 "Graphics/Battlebacks/036-Shop01.jpg",
 "Graphics/Battlebacks/017-MineTown01.jpg",
 "Graphics/Battlebacks/026-Castle02.jpg",
 "Graphics/Battlebacks/029-Church02.jpg",
 "Graphics/Battlebacks/005-Beach01.jpg",
 "Graphics/Battlebacks/027-Castle03.jpg",
 "Graphics/Fogs/003-Shade01.png",
 "Graphics/Fogs/006-Sandstorm02.png",
 "Graphics/Fogs/005-Sandstorm01.png",
 "Graphics/Fogs/001-Fog01.png",
 "Graphics/Fogs/004-Shade02.png",
 "Graphics/Fogs/008-Water02.png",
 "Graphics/Fogs/007-Water01.png",
 "Graphics/Fogs/009-Water03.png",
 "Graphics/Fogs/002-Clouds01.png",
 "Graphics/Fogs/010-Water04.png",
 "Graphics/Gameovers/001-Gameover01.jpg",
 "Audio/BGM/046-Positive04.mid",
 "Audio/BGM/014-Theme03.mid",
 "Audio/BGM/041-Dungeon07.mid",
 "Audio/BGM/009-LastBoss01.mid",
 "Audio/BGM/062-Slow05.mid",
 "Audio/BGM/045-Positive03.mid",
 "Audio/BGM/013-Theme02.mid",
 "Audio/BGM/043-Positive01.mid",
 "Audio/BGM/015-Theme04.mid",
 "Audio/BGM/044-Positive02.mid",
 "Audio/BGM/022-Field05.mid",
 "Audio/BGM/019-Field02.mid",
 "Audio/BGM/027-Town05.mid",
 "Audio/BGM/017-Theme06.mid",
 "Audio/BGM/006-Boss02.mid",
 "Audio/BGM/016-Theme05.mid",
 "Audio/BGM/028-Town06.mid",
 "Audio/BGM/058-Slow01.mid",
 "Audio/BGM/034-Heaven01.mid",
 "Audio/BGM/021-Field04.mid",
 "Audio/BGM/054-Negative03.mid",
 "Audio/BGM/029-Town07.mid",
 "Audio/BGM/035-Dungeon01.mid",
 "Audio/BGM/003-Battle03.mid",
 "Audio/BGM/049-Positive07.mid",
 "Audio/BGM/001-Battle01.mid",
 "Audio/BGM/063-Slow06.mid",
 "Audio/BGM/010-LastBoss02.mid",
 "Audio/BGM/008-Boss04.mid",
 "Audio/BGM/039-Dungeon05.mid",
 "Audio/BGM/037-Dungeon03.mid",
 "Audio/BGM/059-Slow02.mid",
 "Audio/BGM/055-Negative04.mid",
 "Audio/BGM/032-Church01.mid",
 "Audio/BGM/061-Slow04.mid",
 "Audio/BGM/040-Dungeon06.mid",
 "Audio/BGM/060-Slow03.mid",
 "Audio/BGM/036-Dungeon02.mid",
 "Audio/BGM/057-Negative06.mid",
 "Audio/BGM/051-Positive09.mid",
 "Audio/BGM/042-Dungeon08.mid",
 "Audio/BGM/031-Castle01.mid",
 "Audio/BGM/026-Town04.mid",
 "Audio/BGM/020-Field03.mid",
 "Audio/BGM/048-Positive06.mid",
 "Audio/BGM/064-Slow07.mid",
 "Audio/BGM/047-Positive05.mid",
 "Audio/BGM/050-Positive08.mid",
 "Audio/BGM/005-Boss01.mid",
 "Audio/BGM/018-Field01.mid",
 "Audio/BGM/038-Dungeon04.mid",
 "Audio/BGM/002-Battle02.mid",
 "Audio/BGM/004-Battle04.mid",
 "Audio/BGM/053-Negative02.mid",
 "Audio/BGM/012-Theme01.mid",
 "Audio/BGM/024-Town02.mid",
 "Audio/BGM/052-Negative01.mid",
 "Audio/BGM/033-Ship01.mid",
 "Audio/BGM/025-Town03.mid",
 "Audio/BGM/023-Town01.mid",
 "Audio/BGM/056-Negative05.mid",
 "Audio/BGM/007-Boss03.mid",
 "Audio/BGM/011-LastBoss03.mid",
 "Audio/BGM/030-Town08.mid",
 "Audio/SE/117-Fire01.ogg",
 "Audio/SE/118-Fire02.ogg",
 "Audio/SE/092-Attack04.ogg",
 "Audio/SE/167-Skill11.ogg",
 "Audio/SE/165-Skill09.ogg",
 "Audio/SE/097-Attack09.ogg",
 "Audio/SE/175-Skill19.ogg",
 "Audio/SE/023-Dive03.ogg",
 "Audio/SE/069-Animal04.ogg",
 "Audio/SE/031-Door08.ogg",
 "Audio/SE/008-System08.ogg",
 "Audio/SE/047-Book02.ogg",
 "Audio/SE/108-Heal04.ogg",
 "Audio/SE/144-Support02.ogg",
 "Audio/SE/133-Wind02.ogg",
 "Audio/SE/066-Animal01.ogg",
 "Audio/SE/034-Switch03.ogg",
 "Audio/SE/116-Raise02.ogg",
 "Audio/SE/076-Small03.ogg",
 "Audio/SE/018-Teleport01.ogg",
 "Audio/SE/029-Door06.ogg",
 "Audio/SE/150-Support08.ogg",
 "Audio/SE/119-Fire03.ogg",
 "Audio/SE/146-Support04.ogg",
 "Audio/SE/141-Burst01.ogg",
 "Audio/SE/019-Teleport02.ogg",
 "Audio/SE/089-Attack01.ogg",
 "Audio/SE/157-Skill01.ogg",
 "Audio/SE/140-Darkness03.ogg",
 "Audio/SE/128-Water03.ogg",
 "Audio/SE/009-System09.ogg",
 "Audio/SE/174-Skill18.ogg",
 "Audio/SE/078-Small05.ogg",
 "Audio/SE/176-Skill20.ogg",
 "Audio/SE/004-System04.ogg",
 "Audio/SE/147-Support05.ogg",
 "Audio/SE/123-Thunder01.ogg",
 "Audio/SE/050-Explosion03.ogg",
 "Audio/SE/164-Skill08.ogg",
 "Audio/SE/043-Knock04.ogg",
 "Audio/SE/060-Cheer01.ogg",
 "Audio/SE/163-Skill07.ogg",
 "Audio/SE/052-Cannon01.ogg",
 "Audio/SE/033-Switch02.ogg",
 "Audio/SE/048-Explosion01.ogg",
 "Audio/SE/153-Support11.ogg",
 "Audio/SE/152-Support10.ogg",
 "Audio/SE/056-Right02.ogg",
 "Audio/SE/039-Switch08.ogg",
 "Audio/SE/013-Move01.ogg",
 "Audio/SE/025-Door02.ogg",
 "Audio/SE/083-Monster05.ogg",
 "Audio/SE/073-Animal08.ogg",
 "Audio/SE/169-Skill13.ogg",
 "Audio/SE/085-Monster07.ogg",
 "Audio/SE/001-System01.ogg",
 "Audio/SE/041-Knock02.ogg",
 "Audio/SE/055-Right01.ogg",
 "Audio/SE/110-Heal06.ogg",
 "Audio/SE/062-Swing01.ogg",
 "Audio/SE/049-Explosion02.ogg",
 "Audio/SE/077-Small04.ogg",
 "Audio/SE/044-Chest01.ogg",
 "Audio/SE/148-Support06.ogg",
 "Audio/SE/084-Monster06.ogg",
 "Audio/SE/096-Attack08.ogg",
 "Audio/SE/125-Thunder03.ogg",
 "Audio/SE/177-Skill21.ogg",
 "Audio/SE/143-Support01.ogg",
 "Audio/SE/012-System12.ogg",
 "Audio/SE/036-Switch05.ogg",
 "Audio/SE/155-Support13.ogg",
 "Audio/SE/173-Skill17.ogg",
 "Audio/SE/142-Burst02.ogg",
 "Audio/SE/100-Attack12.ogg",
 "Audio/SE/087-Action02.ogg",
 "Audio/SE/145-Support03.ogg",
 "Audio/SE/002-System02.ogg",
 "Audio/SE/015-Jump01.ogg",
 "Audio/SE/046-Book01.ogg",
 "Audio/SE/109-Heal05.ogg",
 "Audio/SE/124-Thunder02.ogg",
 "Audio/SE/093-Attack05.ogg",
 "Audio/SE/129-Earth01.ogg",
 "Audio/SE/032-Switch01.ogg",
 "Audio/SE/040-Knock01.ogg",
 "Audio/SE/159-Skill03.ogg",
 "Audio/SE/156-Support14.ogg",
 "Audio/SE/021-Dive01.ogg",
 "Audio/SE/107-Heal03.ogg",
 "Audio/SE/005-System05.ogg",
 "Audio/SE/014-Move02.ogg",
 "Audio/SE/037-Switch06.ogg",
 "Audio/SE/127-Water02.ogg",
 "Audio/SE/075-Small02.ogg",
 "Audio/SE/114-Remedy02.ogg",
 "Audio/SE/098-Attack10.ogg",
 "Audio/SE/094-Attack06.ogg",
 "Audio/SE/101-Attack13.ogg",
 "Audio/SE/011-System11.ogg",
 "Audio/SE/045-Push01.ogg",
 "Audio/SE/028-Door05.ogg",
 "Audio/SE/105-Heal01.ogg",
 "Audio/SE/017-Jump03.ogg",
 "Audio/SE/106-Heal02.ogg",
 "Audio/SE/104-Attack16.ogg",
 "Audio/SE/071-Animal06.ogg",
 "Audio/SE/080-Monster02.ogg",
 "Audio/SE/091-Attack03.ogg",
 "Audio/SE/079-Monster01.ogg",
 "Audio/SE/007-System07.ogg",
 "Audio/SE/160-Skill04.ogg",
 "Audio/SE/113-Remedy01.ogg",
 "Audio/SE/126-Water01.ogg",
 "Audio/SE/042-Knock03.ogg",
 "Audio/SE/178-Skill22.ogg",
 "Audio/SE/030-Door07.ogg",
 "Audio/SE/088-Action03.ogg",
 "Audio/SE/059-Applause01.ogg",
 "Audio/SE/020-Teleport03.ogg",
 "Audio/SE/010-System10.ogg",
 "Audio/SE/038-Switch07.ogg",
 "Audio/SE/139-Darkness02.ogg",
 "Audio/SE/154-Support12.ogg",
 "Audio/SE/070-Animal05.ogg",
 "Audio/SE/065-Swing04.ogg",
 "Audio/SE/158-Skill02.ogg",
 "Audio/SE/122-Ice03.ogg",
 "Audio/SE/166-Skill10.ogg",
 "Audio/SE/131-Earth03.ogg",
 "Audio/SE/082-Monster04.ogg",
 "Audio/SE/171-Skill15.ogg",
 "Audio/SE/064-Swing03.ogg",
 "Audio/SE/151-Support09.ogg",
 "Audio/SE/137-Light03.ogg",
 "Audio/SE/121-Ice02.ogg",
 "Audio/SE/161-Skill05.ogg",
 "Audio/SE/068-Animal03.ogg",
 "Audio/SE/111-Heal07.ogg",
 "Audio/SE/135-Light01.ogg",
 "Audio/SE/132-Wind01.ogg",
 "Audio/SE/058-Wrong02.ogg",
 "Audio/SE/074-Small01.ogg",
 "Audio/SE/099-Attack11.ogg",
 "Audio/SE/022-Dive02.ogg",
 "Audio/SE/134-Wind03.ogg",
 "Audio/SE/067-Animal02.ogg",
 "Audio/SE/054-Cannon03.ogg",
 "Audio/SE/115-Raise01.ogg",
 "Audio/SE/072-Animal07.ogg",
 "Audio/SE/130-Earth02.ogg",
 "Audio/SE/016-Jump02.ogg",
 "Audio/SE/063-Swing02.ogg",
 "Audio/SE/179-Skill23.ogg",
 "Audio/SE/120-Ice01.ogg",
 "Audio/SE/090-Attack02.ogg",
 "Audio/SE/057-Wrong01.ogg",
 "Audio/SE/053-Cannon02.ogg",
 "Audio/SE/051-Explosion04.ogg",
 "Audio/SE/138-Darkness01.ogg",
 "Audio/SE/103-Attack15.ogg",
 "Audio/SE/102-Attack14.ogg",
 "Audio/SE/006-System06.ogg",
 "Audio/SE/170-Skill14.ogg",
 "Audio/SE/112-Heal08.ogg",
 "Audio/SE/086-Action01.ogg",
 "Audio/SE/168-Skill12.ogg",
 "Audio/SE/149-Support07.ogg",
 "Audio/SE/061-Thunderclap01.ogg",
 "Audio/SE/172-Skill16.ogg",
 "Audio/SE/027-Door04.ogg",
 "Audio/SE/162-Skill06.ogg",
 "Audio/SE/095-Attack07.ogg",
 "Audio/SE/180-Skill24.ogg",
 "Audio/SE/003-System03.ogg",
 "Audio/SE/136-Light02.ogg",
 "Audio/SE/026-Door03.ogg",
 "Audio/SE/024-Door01.ogg",
 "Audio/SE/081-Monster03.ogg",
 "Audio/SE/035-Switch04.ogg",
 "Audio/BGS/019-People01.ogg",
 "Audio/BGS/009-Wave02.ogg",
 "Audio/BGS/002-Wind02.ogg",
 "Audio/BGS/004-Wind04.ogg",
 "Audio/BGS/014-Fire02.ogg",
 "Audio/BGS/005-Rain01.ogg",
 "Audio/BGS/016-Drips01.ogg",
 "Audio/BGS/006-Rain02.ogg",
 "Audio/BGS/017-Creature01.ogg",
 "Audio/BGS/012-Waterfall02.ogg",
 "Audio/BGS/011-Waterfall01.ogg",
 "Audio/BGS/013-Fire01.ogg",
 "Audio/BGS/010-River01.ogg",
 "Audio/BGS/020-People02.ogg",
 "Audio/BGS/015-Quake01.ogg",
 "Audio/BGS/001-Wind01.ogg",
 "Audio/BGS/007-Rain03.ogg",
 "Audio/BGS/003-Wind03.ogg",
 "Audio/BGS/018-Darkness01.ogg",
 "Audio/BGS/008-Wave01.ogg",
 "Audio/ME/010-Item01.mid",
 "Audio/ME/007-Fanfare01.mid",
 "Audio/ME/001-Victory01.mid",
 "Audio/ME/004-Victory04.mid",
 "Audio/ME/016-Shock01.mid",
 "Audio/ME/008-Fanfare02.mid",
 "Audio/ME/014-Inn01.mid",
 "Audio/ME/015-Mystery01.mid",
 "Audio/ME/011-Item02.mid",
 "Audio/ME/002-Victory02.mid",
 "Audio/ME/013-Gag02.mid",
 "Audio/ME/012-Gag01.mid",
 "Audio/ME/003-Victory03.mid",
 "Audio/ME/009-Fanfare03.mid",
 "Audio/ME/006-Defeat02.mid",
 "Audio/ME/005-Defeat01.mid"]

if RUBY_ENGINE == "opal"
  module RGSSEnv_Message
    def send_message(type, hash)
      if hash
        obj = `{}`
        hash.each do |key, val|
          if val
            `obj[key] = val`
          else
            `obj[key] = null`
          end
        end
      else
        obj = `null`
      end
      result = nil
      %x{
        const sharedBuffer = new SharedArrayBuffer(8);
        const bufferView = new Int32Array(sharedBuffer);
        global.postMessage([#{type}, sharedBuffer, #{obj}]);
        let loopCount = 0;
        while (true) {
          loopCount++;
          if (loopCount > 100000000) {
            global.postMessage(["debug_log", null, #{type} + " is no responced."]);
            while (true) {}
          }
          if (bufferView[0] === 1) {
            break;
          }
        }
        result = bufferView[1];
      }
      result
    end

    def debug_log(log)
      %x{
        global.postMessage(["debug_log", null, #{log}]);
      }
    end

    def file_read(file_path)
      file_data_array = nil
      %x{
        const sharedBuffer = new SharedArrayBuffer(8);
        const bufferView = new Int32Array(sharedBuffer);
        global.postMessage(["file_read_start", sharedBuffer, file_path]);
        while (true) {
          if (bufferView[0] === 1) {
            break;
          }
        }
        const dataSize = bufferView[1];
        const sharedBuffer2 = new SharedArrayBuffer(dataSize * 4);
        const bufferView2 = new Uint32Array(sharedBuffer2);
        bufferView[0] = 0;
        global.postMessage(["file_read", sharedBuffer, sharedBuffer2]);
        while (true) {
          if (bufferView[0] === 1) {
            break;
          }
        }
        #{
          file_data_array = Array.new(`dataSize`)
          `dataSize`.times do |i|
            file_data_array[i] = `String.fromCodePoint(bufferView2[i])`
          end
        }
      }
      file_data = file_data_array.join("")
      file_data
    end
  end
elsif RUBY_ENGINE == "mruby"
  module RGSSEnv_Message
    def send_message(type, hash)
      if RGSS_MODE == :client
        # send_data = JSON.stringify({ type: type, obj: hash })

        if hash
          base_array = []
          hash.each.with_index do |(key, val), i|
            if val.is_a?(String)
              strval = %`"#{val}"`
            elsif val == nil
              strval = "null"
            else
              strval = val.to_s
            end
            base_array << %`"#{key}": #{strval}`
          end
          obj_data = "{#{base_array.join(',')}}"
        else
          obj_data = "null"
        end
        send_data = %`{"type": "#{type}","obj": #{obj_data}}`

        res = rgss_send_message(send_data)
        res
      else
        uri = "http://localhost:7000/"
        http = HttpRequest.new
        hash = hash.to_h do |key, val|
          # rescue_flg = false
          # begin
          #   if val.is_a?(String)
          #     val = val.encode("UTF-8")
          #   end
          # rescue
          #   rescue_flg = true
          # end
  
          # if rescue_flg
          #   begin
          #     val.force_encoding("UTF-8")
          #     val = val.split("").join("")
          #   rescue
          #     val = ""
          #   end
          # end
  
          [key, val]
        end
  
        begin
          send_data = JSON.dump({ type: type, obj: hash })
        rescue
          hash = hash.to_h do |key, val|
            if val.is_a?(String)
              val = ""
            end
            [key, val]
          end
          send_data = JSON.dump({ type: type, obj: hash })
        end
  
        res = http.post(uri, send_data, { "Content-Type" => "application/json" })
        res.body.to_i
      end
    end

    def debug_log(log)
    end

    def file_read(file_path)
      if RGSS_MODE == :client
        buf = "\0" * 600000
        buf_len = rgss_file_read(file_path, buf)
        buf[0...buf_len]
      else
        res = File.read("../" + file_path)
        res
      end
    end
  end
else
  module RGSSEnv_Message
    def send_message(type, hash)
      uri = URI.parse("http://localhost:8000/")
      http = Net::HTTP.new(uri.host, uri.port)
      hash = hash.to_h do |key, val|
        rescue_flg = false
        begin
          if val.is_a?(String)
            val = val.encode("UTF-8")
          end
        rescue
          rescue_flg = true
        end

        if rescue_flg
          begin
            val.force_encoding("UTF-8")
            val = val.split("").join("")
          rescue
            val = ""
          end
        end

        [key, val]
      end

      begin
        send_data = JSON.dump({ type: type, obj: hash })
      rescue
        hash = hash.to_h do |key, val|
          if val.is_a?(String)
            val = ""
          end
          [key, val]
        end
        send_data = JSON.dump({ type: type, obj: hash })
      end

      res = http.post(uri.path, send_data, { "Content-Type" => "application/json" })
      res.body.to_i
    end

    def debug_log(log)
    end

    def file_read(file_path)
      res = File.read("../" + file_path)
      res
    end
  end
end

module RGSSEnv
  extend RGSSEnv_Message

  class << self

    def check_graphics_updated
      updated = send_message("Graphics_check_updated", nil)
      return true if updated == 1
      return false
    end

    # def input_is_pressed(keyname)
    #   hash = { keyname: keyname }
    #   res = send_message("Input_is_pressed", hash)
    #   return true if res == 1
    #   return false
    # end

    # def input_is_triggered(keyname)
    #   hash = { keyname: keyname }
    #   res = send_message("Input_is_triggered", hash)
    #   return true if res == 1
    #   return false
    # end

    # def input_is_repeated(keyname)
    #   hash = { keyname: keyname }
    #   res = send_message("Input_is_repeated", hash)
    #   return true if res == 1
    #   return false
    # end

    # def input_dir4
    #   send_message("Input_dir4", nil)
    # end

    # def input_dir8
    #   send_message("Input_dir8", nil)
    # end

  end
end

module MarshalConvertor; end

class Hash
  def to_h(&block)
    if block
      self.map(&block).to_h
    else
      self
    end
  end
end

module MarshalConvertor
  def rpg_hash_dump
    hash = {}
    hash["class_name"] = self.class.name
    instance_variables.each do |ivar|
      obj = instance_variable_get(ivar)
      if obj.respond_to?(:rpg_hash_dump)
        hash2 = obj.rpg_hash_dump
        hash[ivar] = hash2
      elsif obj.is_a?(String)
        hash[ivar] = str_encode(obj)
      elsif obj.is_a?(Array)
        hash[ivar] = obj.map do |val|
          if val.is_a?(String)
            val = str_encode(val)
          elsif val.respond_to?(:rpg_hash_dump)
            val.rpg_hash_dump
          else
            val
          end
        end
      elsif obj.is_a?(Hash)
        hash[ivar] = obj.to_h do |key, val|
          if val.is_a?(String)
            [key, str_encode(val)]
          elsif val.respond_to?(:rpg_hash_dump)
            [key, val.rpg_hash_dump]
          else
            [key, val]
          end
        end
      else
        hash[ivar] = obj
      end
    end
    hash
  end

  def rpg_hash_load(hash)
    hash.each do |ivar, obj|
      next unless ivar.to_s[0] == "@"
      if obj.is_a?(Hash) && obj["class_name"]
        cls = Kernel.const_get(obj["class_name"])
        obj2 = cls.allocate
        obj2.rpg_hash_load(obj)
        instance_variable_set(ivar, obj2)
      elsif obj.is_a?(Hash)
        hash2 = obj.to_h do |key, val|
          if key =~ /^\d+$/
            key = key.to_i
          end
          if val.is_a?(Hash) && val["class_name"]
            cls = Kernel.const_get(val["class_name"])
            obj2 = cls.allocate
            obj2.rpg_hash_load(val)
            [key, obj2]
          else
            [key, val]
          end
        end
        instance_variable_set(ivar, hash2)
      elsif obj.is_a?(Array)
        ary = obj.map do |val|
          if val.is_a?(Hash) && val["class_name"]
            cls = Kernel.const_get(val["class_name"])
            obj2 = cls.allocate
            obj2.rpg_hash_load(val)
            obj2
          else
            val
          end
        end
        instance_variable_set(ivar, ary)
      else
        instance_variable_set(ivar, obj)
      end
    end
  end

  def str_encode(str)
    begin
      str = str.encode("UTF-8")
    rescue
      str = str.force_encoding("UTF-8")
      str = str.gsub('\\', "")
      str = str.gsub('"', "")
    end
    str
  end
end

=begin
Audio
ミュージック、サウンドにかかわる処理を行うモジュール。

モジュールメソッドAudio.bgm_play(filename[, volume[, pitch]]) 
BGM の演奏を開始します。順にファイル名、ボリューム、ピッチを指定します。

RGSS-RTP に含まれるファイルも自動的に探します。拡張子は省略可能です。

Audio.bgm_stop 
BGM の演奏を停止します。

Audio.bgm_fade(time) 
BGM のフェードアウトを開始します。time は、フェードアウトにかける時間をミリ秒単位で指定します。

Audio.bgs_play(filename[, volume[, pitch]]) 
BGS の演奏を開始します。順にファイル名、ボリューム、ピッチを指定します。

RGSS-RTP に含まれるファイルも自動的に探します。拡張子は省略可能です。

Audio.bgs_stop 
BGS の演奏を停止します。

Audio.bgs_fade(time) 
BGS のフェードアウトを開始します。time は、フェードアウトにかける時間をミリ秒単位で指定します。

Audio.me_play(filename[, volume[, pitch]]) 
ME の演奏を開始します。順にファイル名、ボリューム、ピッチを指定します。

RGSS-RTP に含まれるファイルも自動的に探します。拡張子は省略可能です。

Audio.me_stop 
ME の演奏を停止します。

Audio.me_fade(time) 
ME のフェードアウトを開始します。time は、フェードアウトにかける時間をミリ秒単位で指定します。

Audio.se_play(filename[, volume[, pitch]]) 
SE の演奏を開始します。順にファイル名、ボリューム、ピッチを指定します。

RGSS-RTP に含まれるファイルも自動的に探します。拡張子は省略可能です。

きわめて短期間に同じ SE を演奏しようとした場合、音割れを防止するため、自動的に間引き処理を行います。

Audio.se_stop 
すべての SE の演奏を停止します。
=end

module Audio
  class << self
    def bgm_play(filename, volume = 90, pitch = 100)
      return if filename == @playing_filename
      @playing_filename = filename
      file_path = _find_full_filename(filename)
      RGSSEnv.audio_midi_bgm_play(file_path, volume, pitch)
    end

    def bgm_stop
      RGSSEnv.audio_midi_bgm_stop
    end
    
    def bgm_fade(time)
      RGSSEnv.audio_midi_bgm_fade_out(time)
    end

    def bgs_play(filename, volume = 90, pitch = 100)
      RGSSEnv.audio_ogg_bgs_play(filename, volume, pitch)
    end

    def bgs_stop
      RGSSEnv.audio_ogg_bgs_stop
    end

    def bgs_fade(time)
      RGSSEnv.audio_ogg_bgs_fade_out(time)
    end

    def me_play(filename, volume = 90, pitch = 100)
      return if filename == @playing_filename
      @playing_filename = filename
      file_path = _find_full_filename(filename)
      RGSSEnv.audio_midi_me_play(file_path, volume, pitch)
    end

    def me_stop
      RGSSEnv.audio_midi_me_stop
    end

    def me_fade(time)
      RGSSEnv.audio_midi_me_fade_out(time)
    end

    def se_play(filename, volume, pitch)
      RGSSEnv.audio_ogg_se_play(filename, volume, pitch)
    end

    def se_stop
      RGSSEnv.audio_ogg_se_stop
    end

    def _find_full_filename(filename)
      match_data = filename.match(/(.+)\/(.+)$/)
      target_dname = match_data[1]
      target_fname = match_data[2]
      file_path = GRAPHICS_FILE_LIST.find do |path|
        match_data = path.match(/(.+)\/(.+)\..+$/)
        dname = match_data[1]
        fname = match_data[2]
        fname_no_ext = fname.gsub(/\..+/, "")
        if match_data
          if fname_no_ext.upcase == target_fname.upcase && dname.upcase == target_dname.upcase
            next true
          end
        end
        false
      end
      raise "#{filename} is not found." unless file_path
      file_path
    end
  end
end

=begin
Bitmap
ビットマップのクラス。ビットマップは、いわゆる画像そのものを表わします。

画面にビットマップを表示するためにはスプライト (Sprite) などを使う必要があります。

スーパークラスObject 
クラスメソッドBitmap.new(filename) 
filename で指定した画像ファイルを読み込み、Bitmap オブジェクトを生成します。

RGSS-RTP、暗号化アーカイブに含まれるファイルも自動的に探します。拡張子は省略可能です。

Bitmap.new(width, height) 
指定したサイズの Bitmap オブジェクトを生成します。

メソッドdispose 
ビットマップを解放します。すでに解放されている場合は何も行いません。

disposed? 
ビットマップがすでに解放されている場合に真を返します。

width 
ビットマップの幅を取得します。

height 
ビットマップの高さを取得します。

rect 
ビットマップの矩形 (Rect) を取得します。

blt(x, y, src_bitmap, src_rect[, opacity]) 
src_bitmap の矩形 src_rect (Rect) から、このビットマップの座標 (x, y) にブロック転送を行います。

opacity には不透明度を 0 ～ 255 の範囲で指定できます。

stretch_blt(dest_rect, src_bitmap, src_rect[, opacity]) 
src_bitmap の矩形 src_rect (Rect) から、このビットマップの矩形 dest_rect (Rect) にブロック転送を行います。

opacity には不透明度を 0 ～ 255 の範囲で指定できます。

fill_rect(x, y, width, height, color) 
fill_rect(rect, color) 
このビットマップの矩形 (x, y, width, height) または rect (Rect) を color (Color) で塗り潰します。

clear 
ビットマップ全体をクリアします。

get_pixel(x, y) 
点 (x, y) の色 (Color) を取得します。

set_pixel(x, y, color) 
点 (x, y) の色を color (Color) に設定します。

hue_change(hue) 
色相を変換します。hue は色相 (360 度系) の変位を指定します。

この処理には時間がかかります。また、変換誤差のため、何度も変換を繰り返すと色が失われます。

draw_text(x, y, width, height, str[, align]) 
draw_text(rect, str[, align]) 
このビットマップの矩形 (x, y, width, height) または rect (Rect) に文字列 str を描画します。

テキストの長さが矩形の幅を超える場合は、幅を 60% まで自動的に縮小して描画します。

水平方向はデフォルトで左揃えですが、align に 1 を指定すると中央揃え、2 を指定すると右揃えになります。垂直方向は常に中央揃えです。

この処理には時間がかかるため、1 フレームごとに文字列を再描画するような使い方は推奨されません。

text_size(str) 
draw_text メソッドで文字列 str を描画したときの矩形 (Rect) を取得します。ただし、イタリックの場合の傾き分は含みません。

プロパティfont 
draw_text メソッドで文字列の描画に使用するフォント (Font) です。

=end

class Bitmap
  attr_reader :bitmap_id
  attr_reader :width
  attr_reader :height
  attr_reader :font

  def initialize(*args)
    if args.length == 1 && args[0].is_a?(Integer)
      initialize_1(*args)
    elsif args.length == 1 && args[0].is_a?(String)
      initialize_2(*args)
    elsif args.length == 2
      initialize_3(*args)
    else
      raise TypeError, "constructor is invalid."
    end
    loop_count = 0
    while true
      break if RGSSEnv.bitmap_check_created(@bitmap_id) == 1
      loop_count += 1
      raise "endless loop error." if loop_count > 1000
      Fiber.yield
    end
    @disposed = false
    @width = RGSSEnv.bitmap_get_width(@bitmap_id)
    @height = RGSSEnv.bitmap_get_height(@bitmap_id)
    self.font = Font.new
  end

  def initialize_1(bitmap_id)
    @bitmap_id = bitmap_id
  end

  def initialize_2(filename)
    file_path = _find_full_filename(filename)
    @bitmap_id = RGSSEnv.bitmap_new(file_path, 0, 0)
  end

  def initialize_3(width, height)
    @bitmap_id = RGSSEnv.bitmap_new(nil, width, height)
  end

  def _find_full_filename(filename)
    match_data = filename.match(/(.+)\/(.+)$/)
    target_dname = match_data[1]
    target_fname = match_data[2]
    file_path = GRAPHICS_FILE_LIST.find do |path|
      match_data = path.match(/(.+)\/(.+)\..+$/)
      dname = match_data[1]
      fname = match_data[2]
      fname_no_ext = fname.gsub(/\..+/, "")
      if match_data
        if fname_no_ext.upcase == target_fname.upcase && dname.upcase == target_dname.upcase
          next true
        end
      end
      false
    end
    raise "#{filename} is not found." unless file_path
    file_path
  end

  def dispose
    RGSSEnv.bitmap_delete(@bitmap_id)
    @disposed = true
  end

  def disposed?
    @disposed
  end

  def rect
    Rect.new(0, 0, @width, @height)
  end

  def blt(x, y, src_bitmap, src_rect, opacity = nil)
    sx = src_rect.x
    sy = src_rect.y
    sw = src_rect.width
    sh = src_rect.height
    dx = x
    dy = y
    dw = sw
    dh = sh
    RGSSEnv.bitmap_blt(@bitmap_id, src_bitmap.bitmap_id, sx, sy, sw, sh, x, y, sw, sh)
  end

  def stretch_blt(dest_rect, src_bitmap, src_rect, opacity = nil)
    sx = src_rect.x
    sy = src_rect.y
    sw = src_rect.width
    sh = src_rect.height
    dx = dest_rect.x
    dy = dest_rect.y
    dw = dest_rect.width
    dh = dest_rect.height
    RGSSEnv.bitmap_blt(@bitmap_id, src_bitmap.bitmap_id, sx, sy, sw, sh, dx, dy, dw, dh)
  end

  def fill_rect(*args)
    if args.length == 5
      fill_rect_1(*args)
    elsif args.length == 2
      fill_rect_2(*args)
    end
  end

  def fill_rect_1(x, y, width, height, color)
    RGSSEnv.bitmap_fill_rect(@bitmap_id, x, y, width, height, color.to_css_color)
  end

  def fill_rect_2(rect, color)
    fill_rect_1(rect.x, rect.y, rect.width, rect.height, color)
  end

  def clear
    RGSSEnv.bitmap_clear(@bitmap_id)
  end

  def get_pixel(x, y)

  end

  def set_pixel(x, y, color)

  end

  def hue_change(hue)

  end

  def draw_text(*args)
    if args.length == 5 || args.length == 6
      draw_text_1(*args)
    elsif args.length == 2 || args.length == 3
      draw_text_2(*args)
    else
      raise ArgumentError, "invalid args."
    end
  end

  def draw_text_1(x, y, width, height, str, align = 0)
    case align
    when 0
      str_align = "left"
    when 1
      str_align = "center"
    when 2
      str_align = "right"
    else
      raise TypeError, "align: #{align} is invalid."
    end
    RGSSEnv.bitmap_draw_text(@bitmap_id, str, x, y, width, height, str_align)
  end

  def draw_text_2(rect, str, align = 0)
    draw_text_1(rect.x, rect.y, rect.width, rect.height, str, align)
  end

  def text_size(str)
    width = RGSSEnv.bitmap_measure_text_width(@bitmap_id, str)
    Rect.new(0, 0, width, 32)
  end

  def font=(font)
    RGSSEnv.bitmap_set_font(@bitmap_id, font.name, font.size, font.bold, font.italic, font.color.to_css_color)
    @font = font
  end

  def _update_by_system
    if @font.need_update
      RGSSEnv.bitmap_set_font(@bitmap_id, @font.name, @font.size, @font.bold, @font.italic, @font.color.to_css_color)
    end
  end
end

=begin
Color
RGBA カラーのクラス。各要素は浮動小数点数 (Float) で管理されます。

スーパークラスObject 
クラスメソッドColor.new(red, green, blue[, alpha]) 
Color オブジェクトを生成します。 alpha を省略した場合は 255 になります。

メソッドset(red, green, blue[, alpha]) 
全要素をまとめて設定します。

プロパティred 
赤の値 (0 ～ 255) です。範囲外の値は自動で修正されます。

green 
緑の値 (0 ～ 255) です。範囲外の値は自動で修正されます。

blue 
青の値 (0 ～ 255) です。範囲外の値は自動で修正されます。

alpha 
アルファの値 (0 ～ 255) です。範囲外の値は自動で修正されます。
=end

class Color
  attr_accessor :red, :green, :blue, :alpha

  def initialize(red, green, blue, alpha = 255)
    set(red, green, blue, alpha)
  end

  def set(red, green, blue, alpha = 255)
    @red = red
    @green = green
    @blue = blue
    @alpha = alpha
  end

  def self._load(array)
    obj = self.allocate
    obj.marshal_load(array)
    obj
  end

  def to_css_color
    r = sprintf("%02x", @red)
    g = sprintf("%02x", @green)
    b = sprintf("%02x", @blue)
    "rgba(#{@red}, #{@green}, #{@blue}, #{@alpha / 255.0})"
  end

  def marshal_load(bin)
    double_ary = bin.unpack("d*")
    @red = double_ary[0]
    @green = double_ary[1]
    @blue = double_ary[2]
    @alpha = double_ary[3]
  end

  def rpg_hash_dump
    {
      "class_name" => "Color",
      "@red" => @red,
      "@green" => @green,
      "@blue" => @blue,
      "@alpha" => @alpha,
    }
  end

  def rpg_hash_load(hash)
    @red = hash["@red"]
    @green = hash["@green"]
    @blue = hash["@blue"]
    @alpha = hash["@alpha"]
  end
end

=begin
Font
フォントのクラス。フォントは Bitmap クラスのプロパティです。

スーパークラスObject 
クラスメソッドFont.new([name[, size]]) 
Font オブジェクトを生成します。

Font.exist?(name) 
指定された名前のフォントがシステムに存在するとき真を返します。

プロパティname 
フォント名です。初期値は "ＭＳ Ｐゴシック" です。

文字列の配列を設定すると、希望順に複数指定することができます。

font.name = ["HGP行書体", "ＭＳ Ｐゴシック"]

上の例の場合、第一希望の "HGP行書体" がシステムに存在しなければ、第二希望の "ＭＳ Ｐゴシック" が使用されることになります。

size 
フォントのサイズです。初期値は 22 です。

bold 
ボールドフラグです。初期値は false です。

italic 
イタリックフラグです。初期値は false です。

color 
フォントの色 (Color) です。アルファ値も有効です。初期値は (255,255,255,255) です。

クラスプロパティdefault_name 
default_size 
default_bold 
default_italic 
default_color 
Font オブジェクトが新しく作成されたときに各要素に設定されるデフォルト値を変更できます。

Font.default_name = "ＭＳ Ｐ明朝"
Font.default_bold = true

=end

class Font
  class << self
    attr_accessor :default_name , :default_size, :default_bold, :default_italic, :default_color
  end

  # @default_name = "mplus-1m-regular.woff"
  @default_name = "ＭＳ Ｐゴシック"
  @default_size = 32
  @default_bold = false
  @default_italic = false
  @default_color = Color.new(255, 255, 255, 255)

  attr_reader :name, :size, :bold, :italic, :color
  attr_reader :need_update

  def self.exist?(name)
    true
  end

  def initialize(name = Font.default_name, size = Font.default_size)
    @name = name
    @size = size
    @bold = Font.default_bold
    @italic = Font.default_italic
    @color = Font.default_color
    @need_update = false
  end

  def name=(name)
    @name = name
    @need_update = true
  end

  def size=(size)
    @size = size
    @need_update = true
  end

  def bold=(bold)
    @bold = bold
    @need_update = true
  end

  def italic=(italic)
    @italic = italic
    @need_update = true
  end

  def color=(color)
    @name = name
    @need_update = true
  end
end

=begin
Graphics
グラフィック全体にかかわる処理を行うモジュール。

モジュールメソッドGraphics.update 
ゲーム画面を更新し、時間を 1 フレーム進めます。このメソッドは必ず定期的に呼び出す必要があります。

loop do
  Graphics.update
  Input.update
  do_something
end

このメソッドが 10 秒以上に渡って実行されなかった場合、スクリプトが暴走したとみなして強制終了されます。

Graphics.freeze 
トランジションの準備として、現在の画面を固定します。

これ以後 transition メソッドを呼び出すまでは、一切の画面の書き換えが禁止されます。

Graphics.transition([duration[, filename[, vague]]]) 
freeze メソッドで固定した画面から現在の画面へのトランジションを行います。

duration はトランジションにかけるフレーム数です。省略時は 8 になります。

filename はトランジション グラフィックのファイル名を指定します (指定しない場合は通常のフェードになります) 。RGSS-RTP、暗号化アーカイブに含まれるファイルも自動的に探します。拡張子は省略可能です。

vague は転送元と転送先の境界のあいまいさで、値が大きいほどあいまいになります。省略時は 40 になります。

Graphics.frame_reset 
画面の更新タイミングをリセットします。時間のかかる処理の後にこのメソッドを呼ぶことで、極端なフレームスキップが発生しないようにすることができます。

モジュールプロパティGraphics.frame_rate 
[滑らかモード] のときに 1 秒間に画面を更新する回数です。値が大きいほど多くの CPU パワーが必要になります。通常は 40 です。[滑らかモード] でない場合、更新回数は半分になり、1 フレームごとにスキップして描画されます。

このプロパティを変更することは推奨されませんが、変更する場合は 10 ～ 120 の範囲で指定します。範囲外の値は自動で修正されます。

Graphics.frame_count 
画面の更新回数のカウントです。ゲーム開始時にこのプロパティを 0 に設定しておくと、frame_rate プロパティの値で割ることで、ゲームのプレイ時間 (秒数) が算出できます。

=end

module Graphics
  class << self
    attr_accessor :frame_rate
    attr_accessor :frame_count

    def _init
      @frame_rate = 60
      @frame_count = 0
      @sprites = []
    end

    def _add_sprite(sprite)
      @sprites.push(sprite)
    end

    def _remove_sprite(sprite)
      @sprites.delete(sprite)
    end

    def update
      @sprites.each do |sprite|
        sprite._update_by_system
      end
      loop_count = 0
      while true
        break if RGSSEnv.check_graphics_updated
        loop_count += 1
        raise "endless loop error." if loop_count > 1000
        Fiber.yield
      end
      @frame_count += 1
      Fiber.yield
    end

    def freeze

    end

    def transition(duration = nil, filename = nil, vague = nil)

    end

    def frame_reset

    end
  end
end

Graphics._init

=begin
Input
ゲームパッドやキーボードからの入力情報を扱うモジュール。

モジュールメソッドInput.update 
入力情報を更新します。原則として 1 フレームに 1 回呼び出します。

Input.press?(num) 
番号 num に対応するボタンが、現在押されているかどうかを判定します。

押されていれば true、押されていなければ false を返します。

if Input.press?(Input::C)
  do_something
end

Input.trigger?(num) 
番号 num に対応するボタンが、新たに押されたかどうかを判定します。

押されていない状態から押された状態に変わった瞬間のみ「新たに押された」とみなされます。

押されていれば true、押されていなければ false を返します。

Input.repeat?(num) 
番号 num に対応するボタンが、新たに押されたかどうかを判定します。

trigger? と異なり、ボタンを押し続けた場合のリピートを考慮します。

押されていれば true、押されていなければ false を返します。

Input.dir4 
方向ボタンの状態を判定し、4 方向入力に特化した形で、テンキーの数字に対応する整数 (2, 4, 6, 8) を返します。

方向ボタンが押されていない場合 (またはそれと同等とみなされる場合) は 0 を返します。

Input.dir8 
方向ボタンの状態を判定し、8 方向入力に特化した形で、テンキーの数字に対応する整数 (1, 2, 3, 4, 6, 7, 8, 9) を返します。

方向ボタンが押されていない場合 (またはそれと同等とみなされる場合) は 0 を返します。

定数DOWN LEFT RIGHT UP 
方向ボタンの下、左、右、上に対応する番号です。

A B C X Y Z L R 
各々のボタンに対応する番号です。

SHIFT CTRL ALT 
キーボードの SHIFT、CTRL、ALT キーに直接対応する番号です。

F5 F6 F7 F8 F9 
キーボードの各ファンクションキーに対応する番号です。これ以外のキーはシステムに予約されているため、取得することはできません。

=end

module Input
  @@key_table = {
    9 => "tab",
    13 => "ok",
    16 => "shift",
    17 => "control",
    18 => "control",
    27 => "escape",
    32 => "ok",
    33 => "pageup",
    34 => "pagedown",
    37 => "left",
    38 => "up",
    39 => "right",
    40 => "down",
    45 => "escape",
    81 => "pageup",
    87 => "pagedown",
    88 => "escape",
    90 => "ok",
    96 => "escape",
    98 => "down",
    100 => "left",
    102 => "right",
    104 => "up",
    120 => "debug"
  }

  class << self
    def _init
      @@key_state = {}
      @@key_table.each_key do |num|
        @@key_state[num] = 0
      end
    end

    def _get_keycode(target_keyname)
      @@key_table.each do |keycode, keyname|
        return keycode if keyname == target_keyname
      end
      raise "keycode not found: #{target_keyname}"
    end

    def update
      @@key_table.each_key do |num|
        if RGSSEnv.input_is_pressed(num) == 1
          if @@key_state[num] == 0
            @@key_state[num] = 1
          elsif @@key_state[num] == 1
            @@key_state[num] = 2
          end
        else
          @@key_state[num] = 0
        end
      end
    end

    def press?(num)
      # RGSSEnv.input_is_pressed(num) == 1
      @@key_state[num] >= 1
    end

    def trigger?(num)
      # RGSSEnv.input_is_triggered(num) == 1
      @@key_state[num] == 1
    end

    def repeat?(num)
      RGSSEnv.input_is_repeated(num) == 1
    end

    def dir4
      RGSSEnv.input_dir4
    end

    def dir8
      RGSSEnv.input_dir8
    end
  end
end

Input._init
Input::B = Input._get_keycode("escape")
Input::C = Input._get_keycode("ok")
Input::UP = Input._get_keycode("up")
Input::DOWN = Input._get_keycode("down")
Input::LEFT = Input._get_keycode("left")
Input::RIGHT = Input._get_keycode("right")
Input::L = Input._get_keycode("pageup")
Input::R = Input._get_keycode("pagedown")

=begin
Plane
プレーンのクラス。プレーンは、ビットマップのパターンを画面全体に並べて表示する特殊なスプライトで、パノラマやフォグを表示するために使います。

スーパークラスObject 
クラスメソッドPlane.new([viewport]) 
Plane オブジェクトを生成します。必要に応じてビューポート (Viewport) を指定します。

メソッドdispose 
プレーンを解放します。すでに解放されている場合は何も行いません。

disposed? 
プレーンがすでに解放されている場合に真を返します。

viewport 
生成時に指定されたビューポート (Viewport) を取得します。

プロパティbitmap 
プレーンとして使用するビットマップ (Bitmap) への参照です。

visible 
プレーンの可視状態です。真のとき可視になります。

z 
スプライトの Z 座標です。この値が大きいものほど手前に表示されます。Z 座標が同一の場合は、後に生成されたオブジェクトほど手前に表示されます。

ox 
プレーンの転送元原点の X 座標です。この値を変化させることによってスクロールを行います。

oy 
プレーンの転送元原点の Y 座標です。この値を変化させることによってスクロールを行います。

zoom_x 
プレーンの X 方向拡大率です。1.0 で等倍になります。

zoom_y 
プレーンの Y 方向拡大率です。1.0 で等倍になります。

opacity 
プレーンの不透明度です。0 ～ 255 の範囲で指定します。範囲外の値は自動で修正されます。

blend_type 
プレーンの合成方法 (0:通常、1:加算、2:減算) です。

color 
プレーンにブレンドする色 (Color) です。ブレンドの割合にはアルファ値が使用されます。

tone 
プレーンの色調 (Tone) です。

=end

class Plane
  attr_reader :bitmap
  attr_reader :visible
  attr_reader :z
  attr_reader :ox
  attr_reader :oy
  attr_reader :opacity
  attr_accessor :bitmap, :visible, :z, :ox, :oy, :zoom_x, :zoom_y, :blend_type, :color, :tone

  def initialize(viewport = nil)
    @viewport = viewport
    if viewport
      @sprite_id = RGSSEnv.sprite_new(viewport.viewport_id, true)
    else
      @sprite_id = RGSSEnv.sprite_new(-1, true)
    end
    @disposed = false
    @bitmap = nil
    @ox = 0
    @oy = 0
    @src_rect = Rect.new(0, 0, 0, 0)
  end

  def dispose
    @disposed = true
    Graphics._remove_sprite(self)
    if @viewport
      RGSSEnv.sprite_delete(@sprite_id, @viewport.viewport_id)
    else
      RGSSEnv.sprite_delete(@sprite_id, -1)
    end
  end

  def disposed?
    @disposed
  end

  def viewport
    @viewport
  end

  def bitmap=(bitmap)
    @bitmap = bitmap
    if bitmap
      @src_rect.set(0, 0, bitmap.width, bitmap.height)
      RGSSEnv.sprite_set_bitmap(@sprite_id, bitmap.bitmap_id)
    else
      RGSSEnv.sprite_set_bitmap(@sprite_id, -1)
    end
  end

  def ox=(ox)
    RGSSEnv.sprite_set_x(@sprite_id, -@ox)
    @ox = ox
  end

  def oy=(oy)
    RGSSEnv.sprite_set_y(@sprite_id, -@oy)
    @oy = oy
  end

  def z=(z)
    RGSSEnv.sprite_set_z(@sprite_id, z)
    @z = z
  end

  def visible=(visible)
    RGSSEnv.sprite_set_visible(@sprite_id, visible)
    @visible = visible
  end

  def opacity=(opacity)
    opacity = 255 if opacity > 255
    opacity = 0 if opacity < 0
    RGSSEnv.sprite_set_opacity(@sprite_id, opacity)
    @opacity = opacity
  end

  def _update_by_system
    RGSSEnv.sprite_update(@sprite_id)
    RGSSEnv.sprite_set_frame(@sprite_id, @src_rect.x, @src_rect.y, @src_rect.width, @src_rect.height)
    @bitmap._update_by_system if @bitmap
  end
end

=begin
Rect
四角形のクラス。

スーパークラスObject 
クラスメソッドRect.new(x, y, width, height) 
Rect オブジェクトを生成します。

メソッドset(x, y, width, height) 
各要素をまとめて設定します。

プロパティx 
四角形の左上隅の X 座標です。

y 
四角形の左上隅の Y 座標です。

width 
四角形の幅です。

height 
四角形の高さです。

=end

class Rect
  attr_accessor :x, :y, :width, :height

  def initialize(x, y, width, height)
    set(x, y, width, height)
  end

  def set(x, y, width, height)
    @x = x
    @y = y
    @width = width
    @height = height
  end

  def empty
    @x = 0
    @y = 0
    @width = 0
    @height = 0
  end
end

=begin
RGSSError
RGSS 内部のエラーを通知する例外クラス。

Bitmap クラスや Sprite クラスで、すでに解放したオブジェクトにアクセスしようとしたときなどに発生します。

スーパークラスStandardError 
=end

class RGSSError < StandardError
end

=begin
Sprite
スプライトのクラス。スプライトは、ゲーム画面上にキャラクター等を表示するための基本概念です。

スーパークラスObject 
クラスメソッドSprite.new([viewport]) 
Sprite オブジェクトを生成します。必要に応じてビューポート (Viewport) を指定します。

メソッドdispose 
スプライトを解放します。すでに解放されている場合は何も行いません。

disposed? 
スプライトがすでに解放されている場合に真を返します。

viewport 
生成時に指定されたビューポート (Viewport) を取得します。

flash(color, duration) 
スプライトのフラッシュを開始します。duration はフラッシュにかけるフレーム数です。

color に nil を指定した場合は、フラッシュの時間分スプライト自体を消去します。

update 
スプライトのフラッシュを進めます。このメソッドは、原則として 1 フレームに 1 回呼び出します。

フラッシュの必要がない場合は呼び出さなくても構いません。

プロパティbitmap 
転送元とするビットマップ (Bitmap) への参照です。

src_rect 
ビットマップから転送される矩形 (Rect) です。

visible 
スプライトの可視状態です。真のとき可視になります。

x 
スプライトの X 座標です。

y 
スプライトの Y 座標です。

z 
スプライトの Z 座標です。この値が大きいものほど手前に表示されます。Z 座標が同一の場合は、後に生成されたオブジェクトほど手前に表示されます。

ox 
スプライトの転送元原点の X 座標です。

oy 
スプライトの転送元原点の Y 座標です。

zoom_x 
スプライトの X 方向拡大率です。1.0 で等倍になります。

zoom_y 
スプライトの Y 方向拡大率です。1.0 で等倍になります。

angle 
スプライトの回転角度です。反時計回りを正とする 360 度系で指定します。回転描画には時間がかかりますので、多用は避けてください。

mirror 
スプライトの左右反転フラグです。真のとき反転して描画されます。

bush_depth 
スプライトの茂み深さです。茂み深さとは、スプライトの下部を半透明で表示するドット数です。この効果により、キャラクターの足元が茂みなどに隠れているような表現を簡単に行うことができます。

opacity 
スプライトの不透明度です。0 ～ 255 の範囲で指定します。範囲外の値は自動で修正されます。

blend_type 
スプライトの合成方法 (0:通常、1:加算、2:減算) です。

color 
スプライトにブレンドする色 (Color) です。ブレンドの割合にはアルファ値が使用されます。

flash によってブレンドされる色とは別に管理されます。ただし、表示の際にはアルファ値の大きいほうの色が優先してブレンドされます。

tone 
スプライトの色調 (Tone) です

=end

class Sprite
  attr_reader :bitmap
  attr_reader :x
  attr_reader :y
  attr_accessor :src_rect
  attr_reader :visible
  attr_reader :z
  attr_reader :ox
  attr_reader :oy
  attr_accessor :zoom_x
  attr_accessor :zoom_y
  attr_accessor :angle
  attr_accessor :mirror
  attr_accessor :bush_depth
  attr_reader :opacity
  attr_accessor :blend_type
  attr_accessor :color
  attr_accessor :tone

  def initialize(viewport = nil)
    @viewport = viewport
    if viewport
      @sprite_id = RGSSEnv.sprite_new(viewport.viewport_id, false)
    else
      @sprite_id = RGSSEnv.sprite_new(-1, false)
    end
    Graphics._add_sprite(self)
    @bitmap = nil
    @x = 0
    @y = 0
    @ox = 0
    @oy = 0
    @src_rect = Rect.new(0, 0, 0, 0)
    @color = Color.new(0, 0, 0)
    @visible = true
  end

  def bitmap
    @bitmap
  end

  def bitmap=(bitmap)
    @bitmap = bitmap
    if bitmap
      @src_rect.set(0, 0, bitmap.width, bitmap.height)
      RGSSEnv.sprite_set_bitmap(@sprite_id, bitmap.bitmap_id)
    else
      RGSSEnv.sprite_set_bitmap(@sprite_id, -1)
    end
  end

  def x=(x)
    RGSSEnv.sprite_set_x(@sprite_id, x - @ox)
    @x = x
  end

  def y=(y)
    RGSSEnv.sprite_set_y(@sprite_id, y - @oy)
    @y = y
  end

  def z=(z)
    RGSSEnv.sprite_set_z(@sprite_id, z)
    @z = z
  end

  def ox=(ox)
    RGSSEnv.sprite_set_x(@sprite_id, @x - ox)
    @ox = ox
  end

  def oy=(oy)
    RGSSEnv.sprite_set_y(@sprite_id, @y - oy)
    @oy = oy
  end

  def visible=(visible)
    RGSSEnv.sprite_set_visible(@sprite_id, visible)
    @visible = visible
  end

  def opacity=(opacity)
    opacity = 255 if opacity > 255
    opacity = 0 if opacity < 0
    RGSSEnv.sprite_set_opacity(@sprite_id, opacity)
    @opacity = opacity
  end

  def dispose
    @disposed = true
    Graphics._remove_sprite(self)
    if @viewport
      RGSSEnv.sprite_delete(@sprite_id, @viewport.viewport_id)
    else
      RGSSEnv.sprite_delete(@sprite_id, -1)
    end
  end

  def disposed?
    @disposed
  end

  def viewport
    @viewport
  end

  def flash(color, duration)

  end

  def update
  end

  def _update_by_system
    RGSSEnv.sprite_update(@sprite_id)
    RGSSEnv.sprite_set_frame(@sprite_id, @src_rect.x, @src_rect.y, @src_rect.width, @src_rect.height)
    @bitmap._update_by_system if @bitmap
  end
end

=begin
Table
多次元配列のクラス。各要素は符号付き 2 バイト型、すなわち -32,768 から 32,767 の範囲の整数となります。

大量のデータを扱う場合、Ruby の Array クラスでは実行効率が悪くなるため、このクラスが用意されています。

スーパークラスObject 
クラスメソッドTable.new(xsize[, ysize[, zsize]]) 
Table オブジェクトを生成します。多次元配列の各次元のサイズを指定します。生成できる配列は 1 ～ 3 次元です。要素数が 0 の配列を生成することも可能です。

メソッドresize(xsize[, ysize[, zsize]]) 
配列のサイズを変更します。変更前のデータは保持されます。

xsize 
ysize 
zsize 
配列の各次元のサイズを取得します。

プロパティself[x] 
self[x, y] 
self[x, y, z] 
配列の要素にアクセスします。生成した配列の次元数と同じ数の引数をとります。指定された要素が存在しないときには nil を返します。

=end

class Table
  attr_reader :array
  attr_reader :xsize, :ysize, :zsize

  def initialize(xsize, ysize = 1, zsize = 1)
    resize(xsize, ysize, zsize)
    @array = Array.new(zsize * ysize * xsize, 0)
  end

  def resize(xsize, ysize = 1, zsize = 1)
    @xsize = xsize
    @ysize = ysize
    @zsize = zsize
  end

  def [](x, y = 0, z = 0)
    return nil if x >= @xsize || y >= @ysize || z >= @zsize
    i = _calc_index(x, y, z)
    @array[i]
  end

  def []=(x, y = 0, z = 0, val)
    i = _calc_index(x, y, z)
    @array[i] = val
  end

  def _calc_index(x, y, z)
    z * @ysize * @xsize + y * @xsize + x
  end

  def self._load(array)
    obj = self.allocate
    obj.marshal_load(array)
    obj
  end

  def marshal_load(bin)
    ary = bin.unpack("I5S*")
    dim, xsize, ysize, zsize, size = *ary[0..4]
    @dim = dim
    @size = size
    @xsize = xsize
    @ysize = ysize
    @zsize = zsize
    @array = ary[5..-1]
  end

  def rpg_hash_dump
    {
      "class_name" => "Table",
      "@array" => @array,
      "@xsize" => @xsize,
      "@ysize" => @ysize,
      "@zsize" => @zsize,
    }
  end

  def rpg_hash_load(hash)
    @array = hash["@array"]
    @xsize = hash["@xsize"]
    @ysize = hash["@ysize"]
    @zsize = hash["@zsize"]
  end
end

=begin
Tilemap
タイルマップを管理するクラス。タイルマップは 2D ゲームのマップ表示に特化した概念で、内部的には複数のスプライトで構成されています。

スーパークラスObject 
クラスメソッドTilemap.new([viewport]) 
Tilemap オブジェクトを生成します。必要に応じてビューポート (Viewport) を指定します。

メソッドdispose 
タイルマップを解放します。すでに解放されている場合は何も行いません。

disposed? 
タイルマップがすでに解放されている場合に真を返します。

viewport 
生成時に指定されたビューポート (Viewport) を取得します。

update 
オートタイルのアニメーションなどを進めます。このメソッドは、原則として 1 フレームに 1 回呼び出します。

プロパティtileset 
タイルセットとして使用するビットマップ (Bitmap) への参照です。

autotiles[index] 
番号 index (0 ～ 6) のオートタイルとして使用するビットマップ (Bitmap) への参照です。

map_data 
マップデータ (Table) への参照です。横サイズ * 縦サイズ * 3 の 3 次元配列を設定します。

flash_data 
シミュレーションゲームの移動範囲の表示などに使用する、フラッシュデータ (Table) への参照です。横サイズ * 縦サイズの 2 次元配列を設定します。必ずマップデータと同じサイズでなければなりません。各要素は、タイルのフラッシュ色を RGB 各 4 ビットで表わします。たとえば 0xf84 の場合は、RGB(15,8,4) の色でフラッシュします。

priorities 
プライオリティテーブル (Table) への参照です。タイル ID に対応した要素を持つ 1 次元配列を設定します。

visible 
タイルマップの可視状態です。真のとき可視になります。

ox 
タイルマップの転送元原点の X 座標です。この値を変化させることによってスクロールを行います。

oy 
タイルマップの転送元原点の Y 座標です。この値を変化させることによってスクロールを行います。

備考タイルマップを構成する各スプライトの Z 座標は特定の値に固定されています。

プライオリティ 0 のタイルの Z 座標は必ず 0 になります。 
画面の上端に位置するプライオリティ 1 のタイルの Z 座標は 64 となります。 
プライオリティが 1 増えるかタイル 1 個分下に行くごとに、Z 座標は 32 ずつ増加します。 
タイルマップが縦にスクロールすると、Z 座標もそれに合わせて変化します。 
マップ上に表示させるキャラクターの Z 座標は、これを前提として決定しなければなりません。
=end

class Tilemap
  attr_reader :tileset
  attr_reader :map_data
  attr_accessor :flash_data
  attr_reader :priorities
  attr_accessor :visible
  attr_accessor :ox
  attr_accessor :oy

  def initialize(viewport)
    @viewport = viewport
    if viewport
      @tilemap_id = RGSSEnv.tilemap_new(viewport.viewport_id)
    else
      @tilemap_id = RGSSEnv.tilemap_new(-1)
    end
    @autotiles = Array.new(7)
    @disposed = false
    @map_data = nil
    @ox = 0
    @oy = 0
    @update_autotiles = false
  end

  def dispose
    @disposed = true
    if @viewport
      RGSSEnv.tilemap_delete(@tilemap_id, @viewport.viewport_id)
    else
      RGSSEnv.tilemap_delete(@tilemap_id, -1)
    end
  end

  def disposed?
    @disposed
  end

  def viewport
    @viewport
  end

  def update
    RGSSEnv.tilemap_set_origin(@tilemap_id, @ox, @oy)
    if @update_autotiles
      @autotiles.each.with_index do |autotile, i|
        if autotile
          RGSSEnv.tilemap_set_autotile(@tilemap_id, i, autotile.bitmap_id)
        else
          RGSSEnv.tilemap_set_autotile(@tilemap_id, i, -1)
        end
      end
      @update_autotiles = false
    end
    RGSSEnv.tilemap_update(@tilemap_id)
  end

  def tileset=(tileset)
    if tileset
      RGSSEnv.tilemap_set_tileset(@tilemap_id, tileset.bitmap_id)
    else
      RGSSEnv.tilemap_set_tileset(@tilesetid, -1)
    end
    @tileset = tileset
  end

  def autotiles
    @update_autotiles = true
    @autotiles
  end

  def map_data=(map_data)
    RGSSEnv.tilemap_set_map_data(@tilemap_id, map_data.array, map_data.xsize, map_data.ysize)
    @map_data = map_data
  end

  def priorities=(priorities)
    RGSSEnv.tilemap_set_priorities(@tilemap_id, priorities.array, priorities.array.length)
    @priorities = priorities
  end
end

=begin
Tone
色調のクラス。各要素は浮動小数点数 (Float) で管理されます。

スーパークラスObject 
クラスメソッドTone.new(red, green, blue[, gray]) 
Tone オブジェクトを生成します。gray を省略した場合は 0 になります。

メソッドset(red, green, blue[, gray]) 
全要素をまとめて設定します。

プロパティred 
赤成分のカラーバランス調整値 (-255 ～ 255) です。範囲外の値は自動で修正されます。

green 
緑成分のカラーバランス調整値 (-255 ～ 255) です。範囲外の値は自動で修正されます。

blue 
青成分のカラーバランス調整値 (-255 ～ 255) です。範囲外の値は自動で修正されます。

gray 
グレースケール化フィルタの強さ (0 ～ 255) です。範囲外の値は自動で修正されます。

この値が 0 以外の場合、色成分のバランス調整だけの場合よりも余分に処理時間がかかります。

=end

class Tone
  attr_accessor :red, :green, :blue, :gray

  def self._load(array)
    obj = self.allocate
    obj.marshal_load(array)
    obj
  end

  def initialize(red, green, blue, gray = 0)
    set(red, green, blue, gray)
  end

  def set(red, green, blue, gray = 0)
    @red = red
    @green = green
    @blue = blue
    @gray = gray
  end

  def marshal_load(bin)
    double_ary = bin.unpack("d*")
    @red = double_ary[0]
    @green = double_ary[1]
    @blue = double_ary[2]
    @gray = double_ary[3]
  end

  def rpg_hash_dump
    {
      "class_name" => "Tone",
      "@red" => @red,
      "@green" => @green,
      "@blue" => @blue,
      "@gray" => @gray,
    }
  end

  def rpg_hash_load(hash)
    @red = hash["@red"]
    @green = hash["@green"]
    @blue = hash["@blue"]
    @gray = hash["@gray"]
  end
end

=begin
Viewport
ビューポートのクラス。画面の一部にスプライトを表示し、他の部分にはみ出さないようにしたい場合に使用します。

スーパークラスObject 
クラスメソッドViewport.new(x, y, width, height) 
Viewport.new(rect) 
Viewport オブジェクトを生成します。

メソッドdispose 
ビューポートを解放します。すでに解放されている場合は何も行いません。

disposed? 
ビューポートがすでに解放されている場合に真を返します。

flash(color, duration) 
ビューポートのフラッシュを開始します。duration はフラッシュにかけるフレーム数です。

color に nil を指定した場合は、フラッシュの時間分ビューポート自体を消去します。

update 
ビューポートのフラッシュを進めます。このメソッドは、原則として 1 フレームに 1 回呼び出します。

フラッシュの必要がない場合は呼び出さなくても構いません。

プロパティrect 
ビューポートとして設定する矩形 (Rect) です。

visible 
ビューポートの可視状態です。真のとき可視になります。

z 
ビューポートの Z 座標です。この値が大きいものほど手前に表示されます。Z 座標が同一の場合は、後に生成されたオブジェクトほど手前に表示されます。

ox 
ビューポートの転送元原点の X 座標です。この値を変化させることによって画面のシェイクなどを行います。

oy 
ビューポートの転送元原点の Y 座標です。この値を変化させることによって画面のシェイクなどを行います。

color 
ビューポートにブレンドする色 (Color) です。ブレンドの割合にはアルファ値が使用されます。

flash によってブレンドされる色とは別に管理されます。

tone 
ビューポートの色調 (Tone) です。

=end

class Viewport
  attr_reader :viewport_id
  attr_accessor :rect
  attr_accessor :visible
  attr_reader :z
  attr_accessor :ox
  attr_accessor :oy
  attr_accessor :color
  attr_accessor :tone

  def initialize(*args)
    if args.length == 4
      initialize_1(*args)
    elsif args.length == 1
      initialize_2(*args)
    else
      raise ArgumentError, "invalid args."
    end
    @viewport_id = RGSSEnv.viewport_new
    @disposed = false
  end

  def initialize_1(x, y, width, height)
    @rect = Rect.new(x, y, width, height)
  end

  def initialize_2(rect)
    initialize_1(rect.x, rect.y, rect.width, rect.height)
  end

  def dispose
    @disposed = true
    RGSSEnv.viewport_delete(@viewport_id)
  end

  def disposed?
    @disposed
  end

  def z=(z)
    RGSSEnv.viewport_set_z(@viewport_id, z)
    @z = z
  end

  def flash(color, duration)

  end

  def update
    RGSSEnv.viewport_update(@viewport_id)
  end
end

=begin
Window
ゲーム内のウィンドウのクラス。内部的には複数のスプライトで構成されています。

スーパークラスObject 
クラスメソッドWindow.new([viewport]) 
Window オブジェクトを生成します。必要に応じてビューポート (Viewport) を指定します。

メソッドviewport 
生成時に指定されたビューポート (Viewport) を取得します。

dispose 
ウィンドウを解放します。すでに解放されている場合は何も行いません。

disposed? 
ウィンドウがすでに解放されている場合に真を返します。

update 
カーソルの点滅、ポーズサインのアニメーションを進めます。このメソッドは、原則として 1 フレームに 1 回呼び出します。

プロパティwindowskin 
ウィンドウスキンとして使用するビットマップ (Bitmap) への参照です。

contents 
ウィンドウ内容として表示するビットマップ (Bitmap) への参照です。

stretch 
壁紙の表示方法です。真のとき「拡大して表示」、偽のとき「並べて表示」になります。初期値は true です。

cursor_rect 
カーソルの矩形 (Rect) です。ウィンドウの左上隅を (-16, -16) とした相対座標で指定します。

active 
カーソルの点滅状態です。真のとき点滅します。

visible 
ウィンドウの可視状態です。真のとき可視になります。

pause 
ポーズサインの可視状態です。ポーズサインとは、メッセージウィンドウのボタン入力待ち状態を表わす記号のことです。真のとき可視になります。

x 
ウィンドウの X 座標です。

y 
ウィンドウの Y 座標です。

width 
ウィンドウの幅です。

height 
ウィンドウの高さです。

z 
ウィンドウ背景の Z 座標です。この値が大きいものほど手前に表示されます。Z 座標が同一の場合は、後に生成されたオブジェクトほど手前に表示されます。ウィンドウ内容の Z 座標は、ウィンドウ背景の Z 座標に 2 を加算した値になります。

ox 
ウィンドウ内容の転送元原点の X 座標です。この値を変化させることによってスクロールを行います。

oy 
ウィンドウ内容の転送元原点の Y 座標です。この値を変化させることによってスクロールを行います。

opacity 
ウィンドウの不透明度 (0 ～ 255) です。範囲外の値は自動で修正されます。

back_opacity 
ウィンドウ背景の不透明度 (0 ～ 255) です。範囲外の値は自動で修正されます。

contents_opacity 
ウィンドウ内容の不透明度 (0 ～ 255) です。範囲外の値は自動で修正されます。
=end

class Window
  attr_accessor :windowskin
  attr_accessor :stretch
  attr_accessor :cursor_rect
  attr_accessor :active
  attr_reader :visible
  attr_accessor :pause
  attr_reader :x
  attr_reader :y
  attr_reader :width
  attr_reader :height
  attr_reader :z
  attr_reader :ox
  attr_reader :oy
  attr_reader :opacity
  attr_reader :back_opacity
  attr_reader :contents_opacity

  def initialize(viewport = nil)
    @viewport = viewport
    if viewport
      @window_id = RGSSEnv.window_new(viewport.viewport_id)
    else
      @window_id = RGSSEnv.window_new(-1)
    end
    @disposed = false
    @x = 0
    @y = 0
    @z = 0
    @width = 0
    @height = 0
    @cursor_rect = Rect.new(0, 0, 0, 0)
    @ox = 0
    @oy = 0
    @active = true
    @bitmap = nil
    self.visible = true
    @stretch = true
    @pause = false
    self.opacity = 255
    self.back_opacity = 255
    self.contents_opacity = 255
  end

  def x=(x)
    RGSSEnv.window_set_x(@window_id, x - @ox)
    @x = x
  end

  def y=(y)
    RGSSEnv.window_set_y(@window_id, y - @oy)
    @y = y
  end

  def z=(z)
    RGSSEnv.window_set_z(@window_id, z)
    @z = z
  end

  def ox=(ox)
    RGSSEnv.window_set_x(@window_id, @x - ox)
    @ox = ox
  end

  def oy=(y)
    RGSSEnv.window_set_y(@window_id, @y - oy)
    @oy = oy
  end

  def width=(width)
    RGSSEnv.window_set_width(@window_id, width)
    @width = width
  end

  def height=(height)
    RGSSEnv.window_set_height(@window_id, height)
    @height = height
  end

  def contents
    @bitmap
  end

  def contents=(bitmap)
    if bitmap
      RGSSEnv.window_set_bitmap(@window_id, bitmap.bitmap_id)
    else
      RGSSEnv.window_set_bitmap(@window_id, -1)
    end
    @bitmap = bitmap
  end

  def visible=(visible)
    RGSSEnv.window_set_visible(@window_id, visible)
    @visible = visible
  end

  def dispose
    @disposed = true
    if @viewport
      RGSSEnv.window_delete(@window_id, @viewport.viewport_id)
    else
      RGSSEnv.window_delete(@window_id, -1)
    end
  end

  def disposed?
    @disposed
  end

  def update
    RGSSEnv.window_update(@window_id)
    x = @cursor_rect.x
    y = @cursor_rect.y
    width = @cursor_rect.width
    height = @cursor_rect.height
    RGSSEnv.window_set_cursor_rect(@window_id, x, y, width, height)
  end

  def opacity=(opacity)
    opacity = 255 if opacity > 255
    opacity = 0 if opacity < 0
    RGSSEnv.window_set_opacity(@window_id, opacity)
    @opacity = opacity
  end

  def back_opacity=(back_opacity)
    back_opacity = 255 if back_opacity > 255
    back_opacity = 0 if back_opacity < 0
    @back_opacity = back_opacity
  end

  def contents_opacity=(contents_opacity)
    contents_opacity = 255 if contents_opacity > 255
    contents_opacity = 0 if contents_opacity < 0
    RGSSEnv.window_set_contents_opacity(@window_id, contents_opacity)
    @contents_opacity = contents_opacity
  end
end

module RPG
  class Sprite < ::Sprite
    @@_animations = []
    @@_reference_count = {}
    def initialize(viewport = nil)
      super(viewport)
      @_whiten_duration = 0
      @_appear_duration = 0
      @_escape_duration = 0
      @_collapse_duration = 0
      @_damage_duration = 0
      @_animation_duration = 0
      @_blink = false
    end
    def dispose
      dispose_damage
      dispose_animation
      dispose_loop_animation
      super
    end
    def whiten
      self.blend_type = 0
      self.color.set(255, 255, 255, 128)
      self.opacity = 255
      @_whiten_duration = 16
      @_appear_duration = 0
      @_escape_duration = 0
      @_collapse_duration = 0
    end
    def appear
      self.blend_type = 0
      self.color.set(0, 0, 0, 0)
      self.opacity = 0
      @_appear_duration = 16
      @_whiten_duration = 0
      @_escape_duration = 0
      @_collapse_duration = 0
    end
    def escape
      self.blend_type = 0
      self.color.set(0, 0, 0, 0)
      self.opacity = 255
      @_escape_duration = 32
      @_whiten_duration = 0
      @_appear_duration = 0
      @_collapse_duration = 0
    end
    def collapse
      self.blend_type = 1
      self.color.set(255, 64, 64, 255)
      self.opacity = 255
      @_collapse_duration = 48
      @_whiten_duration = 0
      @_appear_duration = 0
      @_escape_duration = 0
    end
    def damage(value, critical)
      dispose_damage
      if value.is_a?(Numeric)
        damage_string = value.abs.to_s
      else
        damage_string = value.to_s
      end
      bitmap = Bitmap.new(160, 48)
      bitmap.font.name = "Arial Black"
      bitmap.font.size = 32
      bitmap.font.color.set(0, 0, 0)
      bitmap.draw_text(-1, 12-1, 160, 36, damage_string, 1)
      bitmap.draw_text(+1, 12-1, 160, 36, damage_string, 1)
      bitmap.draw_text(-1, 12+1, 160, 36, damage_string, 1)
      bitmap.draw_text(+1, 12+1, 160, 36, damage_string, 1)
      if value.is_a?(Numeric) and value < 0
        bitmap.font.color.set(176, 255, 144)
      else
        bitmap.font.color.set(255, 255, 255)
      end
      bitmap.draw_text(0, 12, 160, 36, damage_string, 1)
      if critical
        bitmap.font.size = 20
        bitmap.font.color.set(0, 0, 0)
        bitmap.draw_text(-1, -1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(+1, -1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(-1, +1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(+1, +1, 160, 20, "CRITICAL", 1)
        bitmap.font.color.set(255, 255, 255)
        bitmap.draw_text(0, 0, 160, 20, "CRITICAL", 1)
      end
      @_damage_sprite = ::Sprite.new(self.viewport)
      @_damage_sprite.bitmap = bitmap
      @_damage_sprite.ox = 80
      @_damage_sprite.oy = 20
      @_damage_sprite.x = self.x
      @_damage_sprite.y = self.y - self.oy / 2
      @_damage_sprite.z = 3000
      @_damage_duration = 40
    end
    def animation(animation, hit)
      dispose_animation
      @_animation = animation
      return if @_animation == nil
      @_animation_hit = hit
      @_animation_duration = @_animation.frame_max
      animation_name = @_animation.animation_name
      animation_hue = @_animation.animation_hue
      bitmap = RPG::Cache.animation(animation_name, animation_hue)
      if @@_reference_count.include?(bitmap)
        @@_reference_count[bitmap] += 1
      else
        @@_reference_count[bitmap] = 1
      end
      @_animation_sprites = []
      if @_animation.position != 3 or not @@_animations.include?(animation)
        for i in 0..15
          sprite = ::Sprite.new(self.viewport)
          sprite.bitmap = bitmap
          sprite.visible = false
          @_animation_sprites.push(sprite)
        end
        unless @@_animations.include?(animation)
          @@_animations.push(animation)
        end
      end
      update_animation
    end
    def loop_animation(animation)
      return if animation == @_loop_animation
      dispose_loop_animation
      @_loop_animation = animation
      return if @_loop_animation == nil
      @_loop_animation_index = 0
      animation_name = @_loop_animation.animation_name
      animation_hue = @_loop_animation.animation_hue
      bitmap = RPG::Cache.animation(animation_name, animation_hue)
      if @@_reference_count.include?(bitmap)
        @@_reference_count[bitmap] += 1
      else
        @@_reference_count[bitmap] = 1
      end
      @_loop_animation_sprites = []
      for i in 0..15
        sprite = ::Sprite.new(self.viewport)
        sprite.bitmap = bitmap
        sprite.visible = false
        @_loop_animation_sprites.push(sprite)
      end
      update_loop_animation
    end
    def dispose_damage
      if @_damage_sprite != nil
        @_damage_sprite.bitmap.dispose
        @_damage_sprite.dispose
        @_damage_sprite = nil
        @_damage_duration = 0
      end
    end
    def dispose_animation
      if @_animation_sprites != nil
        sprite = @_animation_sprites[0]
        if sprite != nil
          @@_reference_count[sprite.bitmap] -= 1
          if @@_reference_count[sprite.bitmap] == 0
            sprite.bitmap.dispose
          end
        end
        for sprite in @_animation_sprites
          sprite.dispose
        end
        @_animation_sprites = nil
        @_animation = nil
      end
    end
    def dispose_loop_animation
      if @_loop_animation_sprites != nil
        sprite = @_loop_animation_sprites[0]
        if sprite != nil
          @@_reference_count[sprite.bitmap] -= 1
          if @@_reference_count[sprite.bitmap] == 0
            sprite.bitmap.dispose
          end
        end
        for sprite in @_loop_animation_sprites
          sprite.dispose
        end
        @_loop_animation_sprites = nil
        @_loop_animation = nil
      end
    end
    def blink_on
      unless @_blink
        @_blink = true
        @_blink_count = 0
      end
    end
    def blink_off
      if @_blink
        @_blink = false
        self.color.set(0, 0, 0, 0)
      end
    end
    def blink?
      @_blink
    end
    def effect?
      @_whiten_duration > 0 or
      @_appear_duration > 0 or
      @_escape_duration > 0 or
      @_collapse_duration > 0 or
      @_damage_duration > 0 or
      @_animation_duration > 0
    end
    def update
      super
      if @_whiten_duration > 0
        @_whiten_duration -= 1
        self.color.alpha = 128 - (16 - @_whiten_duration) * 10
      end
      if @_appear_duration > 0
        @_appear_duration -= 1
        self.opacity = (16 - @_appear_duration) * 16
      end
      if @_escape_duration > 0
        @_escape_duration -= 1
        self.opacity = 256 - (32 - @_escape_duration) * 10
      end
      if @_collapse_duration > 0
        @_collapse_duration -= 1
        self.opacity = 256 - (48 - @_collapse_duration) * 6
      end
      if @_damage_duration > 0
        @_damage_duration -= 1
        case @_damage_duration
        when 38..39
          @_damage_sprite.y -= 4
        when 36..37
          @_damage_sprite.y -= 2
        when 34..35
          @_damage_sprite.y += 2
        when 28..33
          @_damage_sprite.y += 4
        end
        @_damage_sprite.opacity = 256 - (12 - @_damage_duration) * 32
        if @_damage_duration == 0
          dispose_damage
        end
      end
      if @_animation != nil and (Graphics.frame_count % 2 == 0)
        @_animation_duration -= 1
        update_animation
      end
      if @_loop_animation != nil and (Graphics.frame_count % 2 == 0)
        update_loop_animation
        @_loop_animation_index += 1
        @_loop_animation_index %= @_loop_animation.frame_max
      end
      if @_blink
        @_blink_count = (@_blink_count + 1) % 32
        if @_blink_count < 16
          alpha = (16 - @_blink_count) * 6
        else
          alpha = (@_blink_count - 16) * 6
        end
        self.color.set(255, 255, 255, alpha)
      end
      @@_animations.clear
    end
    def update_animation
      if @_animation_duration > 0
        frame_index = @_animation.frame_max - @_animation_duration
        cell_data = @_animation.frames[frame_index].cell_data
        position = @_animation.position
        animation_set_sprites(@_animation_sprites, cell_data, position)
        for timing in @_animation.timings
          if timing.frame == frame_index
            animation_process_timing(timing, @_animation_hit)
          end
        end
      else
        dispose_animation
      end
    end
    def update_loop_animation
      frame_index = @_loop_animation_index
      cell_data = @_loop_animation.frames[frame_index].cell_data
      position = @_loop_animation.position
      animation_set_sprites(@_loop_animation_sprites, cell_data, position)
      for timing in @_loop_animation.timings
        if timing.frame == frame_index
          animation_process_timing(timing, true)
        end
      end
    end
    def animation_set_sprites(sprites, cell_data, position)
      for i in 0..15
        sprite = sprites[i]
        pattern = cell_data[i, 0]
        if sprite == nil or pattern == nil or pattern == -1
          sprite.visible = false if sprite != nil
          next
        end
        sprite.visible = true
        sprite.src_rect.set(pattern % 5 * 192, pattern / 5 * 192, 192, 192)
        if position == 3
          if self.viewport != nil
            sprite.x = self.viewport.rect.width / 2
            sprite.y = self.viewport.rect.height - 160
          else
            sprite.x = 320
            sprite.y = 240
          end
        else
          sprite.x = self.x - self.ox + self.src_rect.width / 2
          sprite.y = self.y - self.oy + self.src_rect.height / 2
          sprite.y -= self.src_rect.height / 4 if position == 0
          sprite.y += self.src_rect.height / 4 if position == 2
        end
        sprite.x += cell_data[i, 1]
        sprite.y += cell_data[i, 2]
        sprite.z = 2000
        sprite.ox = 96
        sprite.oy = 96
        sprite.zoom_x = cell_data[i, 3] / 100.0
        sprite.zoom_y = cell_data[i, 3] / 100.0
        sprite.angle = cell_data[i, 4]
        sprite.mirror = (cell_data[i, 5] == 1)
        sprite.opacity = cell_data[i, 6] * self.opacity / 255.0
        sprite.blend_type = cell_data[i, 7]
      end
    end
    def animation_process_timing(timing, hit)
      if (timing.condition == 0) or
         (timing.condition == 1 and hit == true) or
         (timing.condition == 2 and hit == false)
        if timing.se.name != ""
          se = timing.se
          Audio.se_play("Audio/SE/" + se.name, se.volume, se.pitch)
        end
        case timing.flash_scope
        when 1
          self.flash(timing.flash_color, timing.flash_duration * 2)
        when 2
          if self.viewport != nil
            self.viewport.flash(timing.flash_color, timing.flash_duration * 2)
          end
        when 3
          self.flash(nil, timing.flash_duration * 2)
        end
      end
    end
    def x=(x)
      sx = x - self.x
      if sx != 0
        if @_animation_sprites != nil
          for i in 0..15
            @_animation_sprites[i].x += sx
          end
        end
        if @_loop_animation_sprites != nil
          for i in 0..15
            @_loop_animation_sprites[i].x += sx
          end
        end
      end
      super
    end
    def y=(y)
      sy = y - self.y
      if sy != 0
        if @_animation_sprites != nil
          for i in 0..15
            @_animation_sprites[i].y += sy
          end
        end
        if @_loop_animation_sprites != nil
          for i in 0..15
            @_loop_animation_sprites[i].y += sy
          end
        end
      end
      super
    end
  end
end

module RPG
  class Weather
    include MarshalConvertor

    def initialize(viewport = nil)
      @type = 0
      @max = 0
      @ox = 0
      @oy = 0
      color1 = Color.new(255, 255, 255, 255)
      color2 = Color.new(255, 255, 255, 128)
      @rain_bitmap = Bitmap.new(7, 56)
      for i in 0..6
        @rain_bitmap.fill_rect(6-i, i*8, 1, 8, color1)
      end
      @storm_bitmap = Bitmap.new(34, 64)
      for i in 0..31
        @storm_bitmap.fill_rect(33-i, i*2, 1, 2, color2)
        @storm_bitmap.fill_rect(32-i, i*2, 1, 2, color1)
        @storm_bitmap.fill_rect(31-i, i*2, 1, 2, color2)
      end
      @snow_bitmap = Bitmap.new(6, 6)
      @snow_bitmap.fill_rect(0, 1, 6, 4, color2)
      @snow_bitmap.fill_rect(1, 0, 4, 6, color2)
      @snow_bitmap.fill_rect(1, 2, 4, 2, color1)
      @snow_bitmap.fill_rect(2, 1, 2, 4, color1)
      @sprites = []
      for i in 1..40
        sprite = Sprite.new(viewport)
        sprite.z = 1000
        sprite.visible = false
        sprite.opacity = 0
        @sprites.push(sprite)
      end
    end
    def dispose
      for sprite in @sprites
        sprite.dispose
      end
      @rain_bitmap.dispose
      @storm_bitmap.dispose
      @snow_bitmap.dispose
    end
    def type=(type)
      return if @type == type
      @type = type
      case @type
      when 1
        bitmap = @rain_bitmap
      when 2
        bitmap = @storm_bitmap
      when 3
        bitmap = @snow_bitmap
      else
        bitmap = nil
      end
      for i in 1..40
        sprite = @sprites[i]
        if sprite != nil
          sprite.visible = (i <= @max)
          sprite.bitmap = bitmap
        end
      end
    end
    def ox=(ox)
      return if @ox == ox;
      @ox = ox
      for sprite in @sprites
        sprite.ox = @ox
      end
    end
    def oy=(oy)
      return if @oy == oy;
      @oy = oy
      for sprite in @sprites
        sprite.oy = @oy
      end
    end
    def max=(max)
      return if @max == max;
      @max = [[max, 0].max, 40].min
      for i in 1..40
        sprite = @sprites[i]
        if sprite != nil
          sprite.visible = (i <= @max)
        end
      end
    end
    def update
      return if @type == 0
      for i in 1..@max
        sprite = @sprites[i]
        if sprite == nil
          break
        end
        if @type == 1
          sprite.x -= 2
          sprite.y += 16
          sprite.opacity -= 8
        end
        if @type == 2
          sprite.x -= 8
          sprite.y += 16
          sprite.opacity -= 12
        end
        if @type == 3
          sprite.x -= 2
          sprite.y += 8
          sprite.opacity -= 8
        end
        x = sprite.x - @ox
        y = sprite.y - @oy
        if sprite.opacity < 64 or x < -50 or x > 750 or y < -300 or y > 500
          sprite.x = rand(800) - 50 + @ox
          sprite.y = rand(800) - 200 + @oy
          sprite.opacity = 255
        end
      end
    end
    attr_reader :type
    attr_reader :max
    attr_reader :ox
    attr_reader :oy
  end
end

module RPG
  module Cache
    @cache = {}
    def self.load_bitmap(folder_name, filename, hue = 0)
      path = folder_name + filename
      if not @cache.include?(path) or @cache[path].disposed?
        if filename != ""
          @cache[path] = Bitmap.new(path)
        else
          @cache[path] = Bitmap.new(32, 32)
        end
      end
      if hue == 0
        @cache[path]
      else
        key = [path, hue]
        if not @cache.include?(key) or @cache[key].disposed?
          @cache[key] = @cache[path].clone
          @cache[key].hue_change(hue)
        end
        @cache[key]
      end
    end
    def self.animation(filename, hue)
      self.load_bitmap("Graphics/Animations/", filename, hue)
    end
    def self.autotile(filename)
      self.load_bitmap("Graphics/Autotiles/", filename)
    end
    def self.battleback(filename)
      self.load_bitmap("Graphics/Battlebacks/", filename)
    end
    def self.battler(filename, hue)
      self.load_bitmap("Graphics/Battlers/", filename, hue)
    end
    def self.character(filename, hue)
      self.load_bitmap("Graphics/Characters/", filename, hue)
    end
    def self.fog(filename, hue)
      self.load_bitmap("Graphics/Fogs/", filename, hue)
    end
    def self.gameover(filename)
      self.load_bitmap("Graphics/Gameovers/", filename)
    end
    def self.icon(filename)
      self.load_bitmap("Graphics/Icons/", filename)
    end
    def self.panorama(filename, hue)
      self.load_bitmap("Graphics/Panoramas/", filename, hue)
    end
    def self.picture(filename)
      self.load_bitmap("Graphics/Pictures/", filename)
    end
    def self.tileset(filename)
      self.load_bitmap("Graphics/Tilesets/", filename)
    end
    def self.title(filename)
      self.load_bitmap("Graphics/Titles/", filename)
    end
    def self.windowskin(filename)
      self.load_bitmap("Graphics/Windowskins/", filename)
    end
    def self.tile(filename, tile_id, hue)
      key = [filename, tile_id, hue]
      if not @cache.include?(key) or @cache[key].disposed?
        @cache[key] = Bitmap.new(32, 32)
        x = (tile_id - 384) % 8 * 32
        y = (tile_id - 384) / 8 * 32
        rect = Rect.new(x, y, 32, 32)
        @cache[key].blt(0, 0, self.tileset(filename), rect)
        @cache[key].hue_change(hue)
      end
      @cache[key]
    end
    def self.clear
      @cache = {}
      GC.start
    end
  end
end

module RPG
  class Actor
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @class_id = 1
      @initial_level = 1
      @final_level = 99
      @exp_basis = 30
      @exp_inflation = 30
      @character_name = ""
      @character_hue = 0
      @battler_name = ""
      @battler_hue = 0
      @parameters = Table.new(6,100)
      for i in 1..99
        @parameters[0,i] = 500+i*50
        @parameters[1,i] = 500+i*50
        @parameters[2,i] = 50+i*5
        @parameters[3,i] = 50+i*5
        @parameters[4,i] = 50+i*5
        @parameters[5,i] = 50+i*5
      end
      @weapon_id = 0
      @armor1_id = 0
      @armor2_id = 0
      @armor3_id = 0
      @armor4_id = 0
      @weapon_fix = false
      @armor1_fix = false
      @armor2_fix = false
      @armor3_fix = false
      @armor4_fix = false
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :class_id
    attr_accessor :initial_level
    attr_accessor :final_level
    attr_accessor :exp_basis
    attr_accessor :exp_inflation
    attr_accessor :character_name
    attr_accessor :character_hue
    attr_accessor :battler_name
    attr_accessor :battler_hue
    attr_accessor :parameters
    attr_accessor :weapon_id
    attr_accessor :armor1_id
    attr_accessor :armor2_id
    attr_accessor :armor3_id
    attr_accessor :armor4_id
    attr_accessor :weapon_fix
    attr_accessor :armor1_fix
    attr_accessor :armor2_fix
    attr_accessor :armor3_fix
    attr_accessor :armor4_fix
  end
end

module RPG
  class Animation
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @animation_name = ""
      @animation_hue = 0
      @position = 1
      @frame_max = 1
      @frames = [RPG::Animation::Frame.new]
      @timings = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :animation_name
    attr_accessor :animation_hue
    attr_accessor :position
    attr_accessor :frame_max
    attr_accessor :frames
    attr_accessor :timings
  end
end

module RPG
  class Animation
    class Frame
      include MarshalConvertor

      def initialize
        @cell_max = 0
        @cell_data = Table.new(0, 0)
      end
      attr_accessor :cell_max
      attr_accessor :cell_data
    end
  end
end

module RPG
  class Animation
    class Timing
      include MarshalConvertor

      def initialize
        @frame = 0
        @se = RPG::AudioFile.new("", 80)
        @flash_scope = 0
        @flash_color = Color.new(255,255,255,255)
        @flash_duration = 5
        @condition = 0
      end
      attr_accessor :frame
      attr_accessor :se
      attr_accessor :flash_scope
      attr_accessor :flash_color
      attr_accessor :flash_duration
      attr_accessor :condition
    end
  end
end

module RPG
  class Armor
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @icon_name = ""
      @description = ""
      @kind = 0
      @auto_state_id = 0
      @price = 0
      @pdef = 0
      @mdef = 0
      @eva = 0
      @str_plus = 0
      @dex_plus = 0
      @agi_plus = 0
      @int_plus = 0
      @guard_element_set = []
      @guard_state_set = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :icon_name
    attr_accessor :description
    attr_accessor :kind
    attr_accessor :auto_state_id
    attr_accessor :price
    attr_accessor :pdef
    attr_accessor :mdef
    attr_accessor :eva
    attr_accessor :str_plus
    attr_accessor :dex_plus
    attr_accessor :agi_plus
    attr_accessor :int_plus
    attr_accessor :guard_element_set
    attr_accessor :guard_state_set
  end
end

module RPG
  class AudioFile
    include MarshalConvertor

    def initialize(name = "", volume = 100, pitch = 100)
      @name = name
      @volume = volume
      @pitch = pitch
    end
    attr_accessor :name
    attr_accessor :volume
    attr_accessor :pitch
  end
end

module RPG
  class Class
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @position = 0
      @weapon_set = []
      @armor_set = []
      @element_ranks = Table.new(1)
      @state_ranks = Table.new(1)
      @learnings = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :position
    attr_accessor :weapon_set
    attr_accessor :armor_set
    attr_accessor :element_ranks
    attr_accessor :state_ranks
    attr_accessor :learnings
  end
end

module RPG
  class Class
    class Learning
      include MarshalConvertor

      def initialize
        @level = 1
        @skill_id = 1
      end
      attr_accessor :level
      attr_accessor :skill_id
    end
  end
end

module RPG
  class CommonEvent
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @trigger = 0
      @switch_id = 1
      @list = [RPG::EventCommand.new]
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :trigger
    attr_accessor :switch_id
    attr_accessor :list
  end
end

module RPG
  class Enemy
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @battler_name = ""
      @battler_hue = 0
      @maxhp = 500
      @maxsp = 500
      @str = 50
      @dex = 50
      @agi = 50
      @int = 50
      @atk = 100
      @pdef = 100
      @mdef = 100
      @eva = 0
      @animation1_id = 0
      @animation2_id = 0
      @element_ranks = Table.new(1)
      @state_ranks = Table.new(1)
      @actions = [RPG::Enemy::Action.new]
      @exp = 0
      @gold = 0
      @item_id = 0
      @weapon_id = 0
      @armor_id = 0
      @treasure_prob = 100
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :battler_name
    attr_accessor :battler_hue
    attr_accessor :maxhp
    attr_accessor :maxsp
    attr_accessor :str
    attr_accessor :dex
    attr_accessor :agi
    attr_accessor :int
    attr_accessor :atk
    attr_accessor :pdef
    attr_accessor :mdef
    attr_accessor :eva
    attr_accessor :animation1_id
    attr_accessor :animation2_id
    attr_accessor :element_ranks
    attr_accessor :state_ranks
    attr_accessor :actions
    attr_accessor :exp
    attr_accessor :gold
    attr_accessor :item_id
    attr_accessor :weapon_id
    attr_accessor :armor_id
    attr_accessor :treasure_prob
  end
end

module RPG
  class Enemy
    class Action
      include MarshalConvertor

      def initialize
        @kind = 0
        @basic = 0
        @skill_id = 1
        @condition_turn_a = 0
        @condition_turn_b = 1
        @condition_hp = 100
        @condition_level = 1
        @condition_switch_id = 0
        @rating = 5
      end
      attr_accessor :kind
      attr_accessor :basic
      attr_accessor :skill_id
      attr_accessor :condition_turn_a
      attr_accessor :condition_turn_b
      attr_accessor :condition_hp
      attr_accessor :condition_level
      attr_accessor :condition_switch_id
      attr_accessor :rating
    end
  end
end

module RPG
  class Event
    include MarshalConvertor

    def initialize(x, y)
      @id = 0
      @name = ""
      @x = x
      @y = y
      @pages = [RPG::Event::Page.new]
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :x
    attr_accessor :y
    attr_accessor :pages
  end
end

module RPG
  class EventCommand
    include MarshalConvertor

    def initialize(code = 0, indent = 0, parameters = [])
      @code = code
      @indent = indent
      @parameters = parameters
    end
    attr_accessor :code
    attr_accessor :indent
    attr_accessor :parameters
  end
end

module RPG
  class Event
    class Page
      include MarshalConvertor

      def initialize
        @condition = RPG::Event::Page::Condition.new
        @graphic = RPG::Event::Page::Graphic.new
        @move_type = 0
        @move_speed = 3
        @move_frequency = 3
        @move_route = RPG::MoveRoute.new
        @walk_anime = true
        @step_anime = false
        @direction_fix = false
        @through = false
        @always_on_top = false
        @trigger = 0
        @list = [RPG::EventCommand.new]
      end
      attr_accessor :condition
      attr_accessor :graphic
      attr_accessor :move_type
      attr_accessor :move_speed
      attr_accessor :move_frequency
      attr_accessor :move_route
      attr_accessor :walk_anime
      attr_accessor :step_anime
      attr_accessor :direction_fix
      attr_accessor :through
      attr_accessor :always_on_top
      attr_accessor :trigger
      attr_accessor :list
    end
  end
end

module RPG
  class Event
    class Page
      class Condition
        include MarshalConvertor

        def initialize
          @switch1_valid = false
          @switch2_valid = false
          @variable_valid = false
          @self_switch_valid = false
          @switch1_id = 1
          @switch2_id = 1
          @variable_id = 1
          @variable_value = 0
          @self_switch_ch = "A"
        end
        attr_accessor :switch1_valid
        attr_accessor :switch2_valid
        attr_accessor :variable_valid
        attr_accessor :self_switch_valid
        attr_accessor :switch1_id
        attr_accessor :switch2_id
        attr_accessor :variable_id
        attr_accessor :variable_value
        attr_accessor :self_switch_ch
      end
    end
  end
end

module RPG
  class Event
    class Page
      class Graphic
        include MarshalConvertor

        def initialize
          @tile_id = 0
          @character_name = ""
          @character_hue = 0
          @direction = 2
          @pattern = 0
          @opacity = 255
          @blend_type = 0
        end
        attr_accessor :tile_id
        attr_accessor :character_name
        attr_accessor :character_hue
        attr_accessor :direction
        attr_accessor :pattern
        attr_accessor :opacity
        attr_accessor :blend_type
      end
    end
  end
end

module RPG
  class Item
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @icon_name = ""
      @description = ""
      @scope = 0
      @occasion = 0
      @animation1_id = 0
      @animation2_id = 0
      @menu_se = RPG::AudioFile.new("", 80)
      @common_event_id = 0
      @price = 0
      @consumable = true
      @parameter_type = 0
      @parameter_points = 0
      @recover_hp_rate = 0
      @recover_hp = 0
      @recover_sp_rate = 0
      @recover_sp = 0
      @hit = 100
      @pdef_f = 0
      @mdef_f = 0
      @variance = 0
      @element_set = []
      @plus_state_set = []
      @minus_state_set = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :icon_name
    attr_accessor :description
    attr_accessor :scope
    attr_accessor :occasion
    attr_accessor :animation1_id
    attr_accessor :animation2_id
    attr_accessor :menu_se
    attr_accessor :common_event_id
    attr_accessor :price
    attr_accessor :consumable
    attr_accessor :parameter_type
    attr_accessor :parameter_points
    attr_accessor :recover_hp_rate
    attr_accessor :recover_hp
    attr_accessor :recover_sp_rate
    attr_accessor :recover_sp
    attr_accessor :hit
    attr_accessor :pdef_f
    attr_accessor :mdef_f
    attr_accessor :variance
    attr_accessor :element_set
    attr_accessor :plus_state_set
    attr_accessor :minus_state_set
  end
end

module RPG
  class Map
    include MarshalConvertor

    def initialize(width, height)
      @tileset_id = 1
      @width = width
      @height = height
      @autoplay_bgm = false
      @bgm = RPG::AudioFile.new
      @autoplay_bgs = false
      @bgs = RPG::AudioFile.new("", 80)
      @encounter_list = []
      @encounter_step = 30
      @data = Table.new(width, height, 3)
      @events = {}
    end
    attr_accessor :tileset_id
    attr_accessor :width
    attr_accessor :height
    attr_accessor :autoplay_bgm
    attr_accessor :bgm
    attr_accessor :autoplay_bgs
    attr_accessor :bgs
    attr_accessor :encounter_list
    attr_accessor :encounter_step
    attr_accessor :data
    attr_accessor :events
  end
end

module RPG
  class MapInfo
    include MarshalConvertor

    def initialize
      @name = ""
      @parent_id = 0
      @order = 0
      @expanded = false
      @scroll_x = 0
      @scroll_y = 0
    end
    attr_accessor :name
    attr_accessor :parent_id
    attr_accessor :order
    attr_accessor :expanded
    attr_accessor :scroll_x
    attr_accessor :scroll_y
  end
end

module RPG
  class MoveCommand
    include MarshalConvertor

    def initialize(code = 0, parameters = [])
      @code = code
      @parameters = parameters
    end
    attr_accessor :code
    attr_accessor :parameters
  end
end

module RPG
  class MoveRoute
    include MarshalConvertor

    def initialize
      @repeat = true
      @skippable = false
      @list = [RPG::MoveCommand.new]
    end
    attr_accessor :repeat
    attr_accessor :skippable
    attr_accessor :list
  end
end

module RPG
  class Skill
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @icon_name = ""
      @description = ""
      @scope = 0
      @occasion = 1
      @animation1_id = 0
      @animation2_id = 0
      @menu_se = RPG::AudioFile.new("", 80)
      @common_event_id = 0
      @sp_cost = 0
      @power = 0
      @atk_f = 0
      @eva_f = 0
      @str_f = 0
      @dex_f = 0
      @agi_f = 0
      @int_f = 100
      @hit = 100
      @pdef_f = 0
      @mdef_f = 100
      @variance = 15
      @element_set = []
      @plus_state_set = []
      @minus_state_set = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :icon_name
    attr_accessor :description
    attr_accessor :scope
    attr_accessor :occasion
    attr_accessor :animation1_id
    attr_accessor :animation2_id
    attr_accessor :menu_se
    attr_accessor :common_event_id
    attr_accessor :sp_cost
    attr_accessor :power
    attr_accessor :atk_f
    attr_accessor :eva_f
    attr_accessor :str_f
    attr_accessor :dex_f
    attr_accessor :agi_f
    attr_accessor :int_f
    attr_accessor :hit
    attr_accessor :pdef_f
    attr_accessor :mdef_f
    attr_accessor :variance
    attr_accessor :element_set
    attr_accessor :plus_state_set
    attr_accessor :minus_state_set
  end
end

module RPG
  class State
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @animation_id = 0
      @restriction = 0
      @nonresistance = false
      @zero_hp = false
      @cant_get_exp = false
      @cant_evade = false
      @slip_damage = false
      @rating = 5
      @hit_rate = 100
      @maxhp_rate = 100
      @maxsp_rate = 100
      @str_rate = 100
      @dex_rate = 100
      @agi_rate = 100
      @int_rate = 100
      @atk_rate = 100
      @pdef_rate = 100
      @mdef_rate = 100
      @eva = 0
      @battle_only = true
      @hold_turn = 0
      @auto_release_prob = 0
      @shock_release_prob = 0
      @guard_element_set = []
      @plus_state_set = []
      @minus_state_set = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :animation_id
    attr_accessor :restriction
    attr_accessor :nonresistance
    attr_accessor :zero_hp
    attr_accessor :cant_get_exp
    attr_accessor :cant_evade
    attr_accessor :slip_damage
    attr_accessor :rating
    attr_accessor :hit_rate
    attr_accessor :maxhp_rate
    attr_accessor :maxsp_rate
    attr_accessor :str_rate
    attr_accessor :dex_rate
    attr_accessor :agi_rate
    attr_accessor :int_rate
    attr_accessor :atk_rate
    attr_accessor :pdef_rate
    attr_accessor :mdef_rate
    attr_accessor :eva
    attr_accessor :battle_only
    attr_accessor :hold_turn
    attr_accessor :auto_release_prob
    attr_accessor :shock_release_prob
    attr_accessor :guard_element_set
    attr_accessor :plus_state_set
    attr_accessor :minus_state_set
  end
end

module RPG
  class System
    include MarshalConvertor

    def initialize
      @magic_number = 0
      @party_members = [1]
      @elements = [nil, ""]
      @switches = [nil, ""]
      @variables = [nil, ""]
      @windowskin_name = ""
      @title_name = ""
      @gameover_name = ""
      @battle_transition = ""
      @title_bgm = RPG::AudioFile.new
      @battle_bgm = RPG::AudioFile.new
      @battle_end_me = RPG::AudioFile.new
      @gameover_me = RPG::AudioFile.new
      @cursor_se = RPG::AudioFile.new("", 80)
      @decision_se = RPG::AudioFile.new("", 80)
      @cancel_se = RPG::AudioFile.new("", 80)
      @buzzer_se = RPG::AudioFile.new("", 80)
      @equip_se = RPG::AudioFile.new("", 80)
      @shop_se = RPG::AudioFile.new("", 80)
      @save_se = RPG::AudioFile.new("", 80)
      @load_se = RPG::AudioFile.new("", 80)
      @battle_start_se = RPG::AudioFile.new("", 80)
      @escape_se = RPG::AudioFile.new("", 80)
      @actor_collapse_se = RPG::AudioFile.new("", 80)
      @enemy_collapse_se = RPG::AudioFile.new("", 80)
      @words = RPG::System::Words.new
      @test_battlers = []
      @test_troop_id = 1
      @start_map_id = 1
      @start_x = 0
      @start_y = 0
      @battleback_name = ""
      @battler_name = ""
      @battler_hue = 0
      @edit_map_id = 1
    end
    attr_accessor :magic_number
    attr_accessor :party_members
    attr_accessor :elements
    attr_accessor :switches
    attr_accessor :variables
    attr_accessor :windowskin_name
    attr_accessor :title_name
    attr_accessor :gameover_name
    attr_accessor :battle_transition
    attr_accessor :title_bgm
    attr_accessor :battle_bgm
    attr_accessor :battle_end_me
    attr_accessor :gameover_me
    attr_accessor :cursor_se
    attr_accessor :decision_se
    attr_accessor :cancel_se
    attr_accessor :buzzer_se
    attr_accessor :equip_se
    attr_accessor :shop_se
    attr_accessor :save_se
    attr_accessor :load_se
    attr_accessor :battle_start_se
    attr_accessor :escape_se
    attr_accessor :actor_collapse_se
    attr_accessor :enemy_collapse_se
    attr_accessor :words
    attr_accessor :test_battlers
    attr_accessor :test_troop_id
    attr_accessor :start_map_id
    attr_accessor :start_x
    attr_accessor :start_y
    attr_accessor :battleback_name
    attr_accessor :battler_name
    attr_accessor :battler_hue
    attr_accessor :edit_map_id
  end
end

module RPG
  class System
    class TestBattler
      include MarshalConvertor

      def initialize
        @actor_id = 1
        @level = 1
        @weapon_id = 0
        @armor1_id = 0
        @armor2_id = 0
        @armor3_id = 0
        @armor4_id = 0
      end
      attr_accessor :actor_id
      attr_accessor :level
      attr_accessor :weapon_id
      attr_accessor :armor1_id
      attr_accessor :armor2_id
      attr_accessor :armor3_id
      attr_accessor :armor4_id
    end
  end
end

module RPG
  class System
    class Words
      include MarshalConvertor

      def initialize
        @gold = ""
        @hp = ""
        @sp = ""
        @str = ""
        @dex = ""
        @agi = ""
        @int = ""
        @atk = ""
        @pdef = ""
        @mdef = ""
        @weapon = ""
        @armor1 = ""
        @armor2 = ""
        @armor3 = ""
        @armor4 = ""
        @attack = ""
        @skill = ""
        @guard = ""
        @item = ""
        @equip = ""
      end
      attr_accessor :gold
      attr_accessor :hp
      attr_accessor :sp
      attr_accessor :str
      attr_accessor :dex
      attr_accessor :agi
      attr_accessor :int
      attr_accessor :atk
      attr_accessor :pdef
      attr_accessor :mdef
      attr_accessor :weapon
      attr_accessor :armor1
      attr_accessor :armor2
      attr_accessor :armor3
      attr_accessor :armor4
      attr_accessor :attack
      attr_accessor :skill
      attr_accessor :guard
      attr_accessor :item
      attr_accessor :equip
    end
  end
end

module RPG
  class Tileset
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @tileset_name = ""
      @autotile_names = [""]*7
      @panorama_name = ""
      @panorama_hue = 0
      @fog_name = ""
      @fog_hue = 0
      @fog_opacity = 64
      @fog_blend_type = 0
      @fog_zoom = 200
      @fog_sx = 0
      @fog_sy = 0
      @battleback_name = ""
      @passages = Table.new(384)
      @priorities = Table.new(384)
      @priorities[0] = 5
      @terrain_tags = Table.new(384)
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :tileset_name
    attr_accessor :autotile_names
    attr_accessor :panorama_name
    attr_accessor :panorama_hue
    attr_accessor :fog_name
    attr_accessor :fog_hue
    attr_accessor :fog_opacity
    attr_accessor :fog_blend_type
    attr_accessor :fog_zoom
    attr_accessor :fog_sx
    attr_accessor :fog_sy
    attr_accessor :battleback_name
    attr_accessor :passages
    attr_accessor :priorities
    attr_accessor :terrain_tags
  end
end

module RPG
  class Troop
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @members = []
      @pages = [RPG::BattleEventPage.new]
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :members
    attr_accessor :pages
  end
end

module RPG
  class Troop
    class Member
      include MarshalConvertor

      def initialize
        @enemy_id = 1
        @x = 0
        @y = 0
        @hidden = false
        @immortal = false
      end
      attr_accessor :enemy_id
      attr_accessor :x
      attr_accessor :y
      attr_accessor :hidden
      attr_accessor :immortal
    end
  end
end

module RPG
  class Troop
    class Page
      include MarshalConvertor

      def initialize
        @condition = RPG::Troop::Page::Condition.new
        @span = 0
        @list = [RPG::EventCommand.new]
      end
      attr_accessor :condition
      attr_accessor :span
      attr_accessor :list
    end
  end
end

module RPG
  class Troop
    class Page
      class Condition
        include MarshalConvertor

        def initialize
          @turn_valid = false
          @enemy_valid = false
          @actor_valid = false
          @switch_valid = false
          @turn_a = 0
          @turn_b = 0
          @enemy_index = 0
          @enemy_hp = 50
          @actor_id = 1
          @actor_hp = 50
          @switch_id = 1
        end
        attr_accessor :turn_valid
        attr_accessor :enemy_valid
        attr_accessor :actor_valid
        attr_accessor :switch_valid
        attr_accessor :turn_a
        attr_accessor :turn_b
        attr_accessor :enemy_index
        attr_accessor :enemy_hp
        attr_accessor :actor_id
        attr_accessor :actor_hp
        attr_accessor :switch_id
      end
    end
  end
end

module RPG
  class Weapon
    include MarshalConvertor

    def initialize
      @id = 0
      @name = ""
      @icon_name = ""
      @description = ""
      @animation1_id = 0
      @animation2_id = 0
      @price = 0
      @atk = 0
      @pdef = 0
      @mdef = 0
      @str_plus = 0
      @dex_plus = 0
      @agi_plus = 0
      @int_plus = 0
      @element_set = []
      @plus_state_set = []
      @minus_state_set = []
    end
    attr_accessor :id
    attr_accessor :name
    attr_accessor :icon_name
    attr_accessor :description
    attr_accessor :animation1_id
    attr_accessor :animation2_id
    attr_accessor :price
    attr_accessor :atk
    attr_accessor :pdef
    attr_accessor :mdef
    attr_accessor :str_plus
    attr_accessor :dex_plus
    attr_accessor :agi_plus
    attr_accessor :int_plus
    attr_accessor :element_set
    attr_accessor :plus_state_set
    attr_accessor :minus_state_set
  end
end

#==============================================================================
# ■ Game_Temp
#------------------------------------------------------------------------------
# 　セーブデータに含まれない、一時的なデータを扱うクラスです。このクラスのイン
# スタンスは $game_temp で参照されます。
#==============================================================================

class Game_Temp
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :map_bgm                  # マップ画面 BGM (バトル時記憶用)
  attr_accessor :message_text             # メッセージ 文章
  attr_accessor :message_proc             # メッセージ コールバック (Proc)
  attr_accessor :choice_start             # 選択肢 開始行
  attr_accessor :choice_max               # 選択肢 項目数
  attr_accessor :choice_cancel_type       # 選択肢 キャンセルの場合
  attr_accessor :choice_proc              # 選択肢 コールバック (Proc)
  attr_accessor :num_input_start          # 数値入力 開始行
  attr_accessor :num_input_variable_id    # 数値入力 変数 ID
  attr_accessor :num_input_digits_max     # 数値入力 桁数
  attr_accessor :message_window_showing   # メッセージウィンドウ表示中
  attr_accessor :common_event_id          # コモンイベント ID
  attr_accessor :in_battle                # 戦闘中フラグ
  attr_accessor :battle_calling           # バトル 呼び出しフラグ
  attr_accessor :battle_troop_id          # バトル トループ ID
  attr_accessor :battle_can_escape        # バトル 逃走可能フラグ
  attr_accessor :battle_can_lose          # バトル 敗北可能フラグ
  attr_accessor :battle_proc              # バトル コールバック (Proc)
  attr_accessor :battle_turn              # バトル ターン数
  attr_accessor :battle_event_flags       # バトル イベント実行済みフラグ
  attr_accessor :battle_abort             # バトル 中断フラグ
  attr_accessor :battle_main_phase        # バトル メインフェーズフラグ
  attr_accessor :battleback_name          # バトルバック ファイル名
  attr_accessor :forcing_battler          # アクション強制対象のバトラー
  attr_accessor :shop_calling             # ショップ 呼び出しフラグ
  attr_accessor :shop_goods               # ショップ 商品リスト
  attr_accessor :name_calling             # 名前入力 呼び出しフラグ
  attr_accessor :name_actor_id            # 名前入力 アクター ID
  attr_accessor :name_max_char            # 名前入力 最大文字数
  attr_accessor :menu_calling             # メニュー 呼び出しフラグ
  attr_accessor :menu_beep                # メニュー SE 演奏フラグ
  attr_accessor :save_calling             # セーブ 呼び出しフラグ
  attr_accessor :debug_calling            # デバッグ 呼び出しフラグ
  attr_accessor :player_transferring      # プレイヤー場所移動フラグ
  attr_accessor :player_new_map_id        # プレイヤー移動先 マップ ID
  attr_accessor :player_new_x             # プレイヤー移動先 X 座標
  attr_accessor :player_new_y             # プレイヤー移動先 Y 座標
  attr_accessor :player_new_direction     # プレイヤー移動先 向き
  attr_accessor :transition_processing    # トランジション処理中フラグ
  attr_accessor :transition_name          # トランジション ファイル名
  attr_accessor :gameover                 # ゲームオーバーフラグ
  attr_accessor :to_title                 # タイトル画面に戻すフラグ
  attr_accessor :last_file_index          # 最後にセーブしたファイルの番号
  attr_accessor :debug_top_row            # デバッグ画面 状態保存用
  attr_accessor :debug_index              # デバッグ画面 状態保存用
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @map_bgm = nil
    @message_text = nil
    @message_proc = nil
    @choice_start = 99
    @choice_max = 0
    @choice_cancel_type = 0
    @choice_proc = nil
    @num_input_start = 99
    @num_input_variable_id = 0
    @num_input_digits_max = 0
    @message_window_showing = false
    @common_event_id = 0
    @in_battle = false
    @battle_calling = false
    @battle_troop_id = 0
    @battle_can_escape = false
    @battle_can_lose = false
    @battle_proc = nil
    @battle_turn = 0
    @battle_event_flags = {}
    @battle_abort = false
    @battle_main_phase = false
    @battleback_name = ''
    @forcing_battler = nil
    @shop_calling = false
    @shop_id = 0
    @name_calling = false
    @name_actor_id = 0
    @name_max_char = 0
    @menu_calling = false
    @menu_beep = false
    @save_calling = false
    @debug_calling = false
    @player_transferring = false
    @player_new_map_id = 0
    @player_new_x = 0
    @player_new_y = 0
    @player_new_direction = 0
    @transition_processing = false
    @transition_name = ""
    @gameover = false
    @to_title = false
    @last_file_index = 0
    @debug_top_row = 0
    @debug_index = 0
  end
end

#==============================================================================
# ■ Game_System
#------------------------------------------------------------------------------
# 　システム周りのデータを扱うクラスです。BGM などの管理も行います。このクラス
# のインスタンスは $game_system で参照されます。
#==============================================================================

class Game_System
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :map_interpreter          # マップイベント用インタプリタ
  attr_reader   :battle_interpreter       # バトルイベント用インタプリタ
  attr_accessor :timer                    # タイマー
  attr_accessor :timer_working            # タイマー作動中フラグ
  attr_accessor :save_disabled            # セーブ禁止
  attr_accessor :menu_disabled            # メニュー禁止
  attr_accessor :encounter_disabled       # エンカウント禁止
  attr_accessor :message_position         # 文章オプション 表示位置
  attr_accessor :message_frame            # 文章オプション ウィンドウ枠
  attr_accessor :save_count               # セーブ回数
  attr_accessor :magic_number             # マジックナンバー
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @map_interpreter = Interpreter.new(0, true)
    @battle_interpreter = Interpreter.new(0, false)
    @timer = 0
    @timer_working = false
    @save_disabled = false
    @menu_disabled = false
    @encounter_disabled = false
    @message_position = 2
    @message_frame = 0
    @save_count = 0
    @magic_number = 0
  end
  #--------------------------------------------------------------------------
  # ● BGM の演奏
  #     bgm : 演奏する BGM
  #--------------------------------------------------------------------------
  def bgm_play(bgm)
    @playing_bgm = bgm
    if bgm != nil and bgm.name != ""
      Audio.bgm_play("Audio/BGM/" + bgm.name, bgm.volume, bgm.pitch)
    else
      Audio.bgm_stop
    end
    Graphics.frame_reset
  end
  #--------------------------------------------------------------------------
  # ● BGM の停止
  #--------------------------------------------------------------------------
  def bgm_stop
    Audio.bgm_stop
  end
  #--------------------------------------------------------------------------
  # ● BGM のフェードアウト
  #     time : フェードアウト時間 (秒)
  #--------------------------------------------------------------------------
  def bgm_fade(time)
    @playing_bgm = nil
    Audio.bgm_fade(time * 1000)
  end
  #--------------------------------------------------------------------------
  # ● BGM の記憶
  #--------------------------------------------------------------------------
  def bgm_memorize
    @memorized_bgm = @playing_bgm
  end
  #--------------------------------------------------------------------------
  # ● BGM の復帰
  #--------------------------------------------------------------------------
  def bgm_restore
    bgm_play(@memorized_bgm)
  end
  #--------------------------------------------------------------------------
  # ● BGS の演奏
  #     bgs : 演奏する BGS
  #--------------------------------------------------------------------------
  def bgs_play(bgs)
    @playing_bgs = bgs
    if bgs != nil and bgs.name != ""
      Audio.bgs_play("Audio/BGS/" + bgs.name, bgs.volume, bgs.pitch)
    else
      Audio.bgs_stop
    end
    Graphics.frame_reset
  end
  #--------------------------------------------------------------------------
  # ● BGS のフェードアウト
  #     time : フェードアウト時間 (秒)
  #--------------------------------------------------------------------------
  def bgs_fade(time)
    @playing_bgs = nil
    Audio.bgs_fade(time * 1000)
  end
  #--------------------------------------------------------------------------
  # ● BGS の記憶
  #--------------------------------------------------------------------------
  def bgs_memorize
    @memorized_bgs = @playing_bgs
  end
  #--------------------------------------------------------------------------
  # ● BGS の復帰
  #--------------------------------------------------------------------------
  def bgs_restore
    bgs_play(@memorized_bgs)
  end
  #--------------------------------------------------------------------------
  # ● ME の演奏
  #     me : 演奏する ME
  #--------------------------------------------------------------------------
  def me_play(me)
    if me != nil and me.name != ""
      Audio.me_play("Audio/ME/" + me.name, me.volume, me.pitch)
    else
      Audio.me_stop
    end
    Graphics.frame_reset
  end
  #--------------------------------------------------------------------------
  # ● SE の演奏
  #     se : 演奏する SE
  #--------------------------------------------------------------------------
  def se_play(se)
    if se != nil and se.name != ""
      Audio.se_play("Audio/SE/" + se.name, se.volume, se.pitch)
    end
  end
  #--------------------------------------------------------------------------
  # ● SE の停止
  #--------------------------------------------------------------------------
  def se_stop
    Audio.se_stop
  end
  #--------------------------------------------------------------------------
  # ● 演奏中 BGM の取得
  #--------------------------------------------------------------------------
  def playing_bgm
    return @playing_bgm
  end
  #--------------------------------------------------------------------------
  # ● 演奏中 BGS の取得
  #--------------------------------------------------------------------------
  def playing_bgs
    return @playing_bgs
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウスキン ファイル名の取得
  #--------------------------------------------------------------------------
  def windowskin_name
    if @windowskin_name == nil
      return $data_system.windowskin_name
    else
      return @windowskin_name
    end
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウスキン ファイル名の設定
  #     windowskin_name : 新しいウィンドウスキン ファイル名
  #--------------------------------------------------------------------------
  def windowskin_name=(windowskin_name)
    @windowskin_name = windowskin_name
  end
  #--------------------------------------------------------------------------
  # ● バトル BGM の取得
  #--------------------------------------------------------------------------
  def battle_bgm
    if @battle_bgm == nil
      return $data_system.battle_bgm
    else
      return @battle_bgm
    end
  end
  #--------------------------------------------------------------------------
  # ● バトル BGM の設定
  #     battle_bgm : 新しいバトル BGM
  #--------------------------------------------------------------------------
  def battle_bgm=(battle_bgm)
    @battle_bgm = battle_bgm
  end
  #--------------------------------------------------------------------------
  # ● バトル終了 BGM の取得
  #--------------------------------------------------------------------------
  def battle_end_me
    if @battle_end_me == nil
      return $data_system.battle_end_me
    else
      return @battle_end_me
    end
  end
  #--------------------------------------------------------------------------
  # ● バトル終了 BGM の設定
  #     battle_end_me : 新しいバトル終了 BGM
  #--------------------------------------------------------------------------
  def battle_end_me=(battle_end_me)
    @battle_end_me = battle_end_me
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # タイマーを 1 減らす
    if @timer_working and @timer > 0
      @timer -= 1
    end
  end
end

#==============================================================================
# ■ Game_Switches
#------------------------------------------------------------------------------
# 　スイッチを扱うクラスです。組み込みクラス Array のラッパーです。このクラス
# のインスタンスは $game_switches で参照されます。
#==============================================================================

class Game_Switches
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @data = []
  end
  #--------------------------------------------------------------------------
  # ● スイッチの取得
  #     switch_id : スイッチ ID
  #--------------------------------------------------------------------------
  def [](switch_id)
    if switch_id <= 5000 and @data[switch_id] != nil
      return @data[switch_id]
    else
      return false
    end
  end
  #--------------------------------------------------------------------------
  # ● スイッチの設定
  #     switch_id : スイッチ ID
  #     value     : ON (true) / OFF (false)
  #--------------------------------------------------------------------------
  def []=(switch_id, value)
    if switch_id <= 5000
      @data[switch_id] = value
    end
  end
end

#==============================================================================
# ■ Game_Variables
#------------------------------------------------------------------------------
# 　変数を扱うクラスです。組み込みクラス Array のラッパーです。このクラスのイ
# ンスタンスは $game_variables で参照されます。
#==============================================================================

class Game_Variables
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @data = []
  end
  #--------------------------------------------------------------------------
  # ● 変数の取得
  #     variable_id : 変数 ID
  #--------------------------------------------------------------------------
  def [](variable_id)
    if variable_id <= 5000 and @data[variable_id] != nil
      return @data[variable_id]
    else
      return 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 変数の設定
  #     variable_id : 変数 ID
  #     value       : 変数の値
  #--------------------------------------------------------------------------
  def []=(variable_id, value)
    if variable_id <= 5000
      @data[variable_id] = value
    end
  end
end

#==============================================================================
# ■ Game_SelfSwitches
#------------------------------------------------------------------------------
# 　セルフスイッチを扱うクラスです。組み込みクラス Hash のラッパーです。このク
# ラスのインスタンスは $game_self_switches で参照されます。
#==============================================================================

class Game_SelfSwitches
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @data = {}
  end
  #--------------------------------------------------------------------------
  # ● セルフスイッチの取得
  #     key : キー
  #--------------------------------------------------------------------------
  def [](key)
    return @data[key] == true ? true : false
  end
  #--------------------------------------------------------------------------
  # ● セルフスイッチの設定
  #     key   : キー
  #     value : ON (true) / OFF (false)
  #--------------------------------------------------------------------------
  def []=(key, value)
    @data[key] = value
  end
end

#==============================================================================
# ■ Game_Screen
#------------------------------------------------------------------------------
# 　色調変更やフラッシュなど、画面全体に関係する処理のデータを保持するクラスで
# す。このクラスのインスタンスは $game_screen で参照されます。
#==============================================================================

class Game_Screen
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :tone                     # 色調
  attr_reader   :flash_color              # フラッシュ色
  attr_reader   :shake                    # シェイク位置
  attr_reader   :pictures                 # ピクチャ
  attr_reader   :weather_type             # 天候 タイプ
  attr_reader   :weather_max              # 天候 画像の最大数
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @flash_color = Color.new(0, 0, 0, 0)
    @flash_duration = 0
    @shake_power = 0
    @shake_speed = 0
    @shake_duration = 0
    @shake_direction = 1
    @shake = 0
    @pictures = [nil]
    for i in 1..100
      @pictures.push(Game_Picture.new(i))
    end
    @weather_type = 0
    @weather_max = 0.0
    @weather_type_target = 0
    @weather_max_target = 0.0
    @weather_duration = 0
  end
  #--------------------------------------------------------------------------
  # ● 色調変更の開始
  #     tone     : 色調
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_tone_change(tone, duration)
    @tone_target = tone.clone
    @tone_duration = duration
    if @tone_duration == 0
      @tone = @tone_target.clone
    end
  end
  #--------------------------------------------------------------------------
  # ● フラッシュの開始
  #     color    : 色
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_flash(color, duration)
    @flash_color = color.clone
    @flash_duration = duration
  end
  #--------------------------------------------------------------------------
  # ● シェイクの開始
  #     power    : 強さ
  #     speed    : 速さ
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_shake(power, speed, duration)
    @shake_power = power
    @shake_speed = speed
    @shake_duration = duration
  end
  #--------------------------------------------------------------------------
  # ● 天候の設定
  #     type     : タイプ
  #     power    : 強さ
  #     duration : 時間
  #--------------------------------------------------------------------------
  def weather(type, power, duration)
    @weather_type_target = type
    if @weather_type_target != 0
      @weather_type = @weather_type_target
    end
    if @weather_type_target == 0
      @weather_max_target = 0.0
    else
      @weather_max_target = (power + 1) * 4.0
    end
    @weather_duration = duration
    if @weather_duration == 0
      @weather_type = @weather_type_target
      @weather_max = @weather_max_target
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    if @tone_duration >= 1
      d = @tone_duration
      @tone.red = (@tone.red * (d - 1) + @tone_target.red) / d
      @tone.green = (@tone.green * (d - 1) + @tone_target.green) / d
      @tone.blue = (@tone.blue * (d - 1) + @tone_target.blue) / d
      @tone.gray = (@tone.gray * (d - 1) + @tone_target.gray) / d
      @tone_duration -= 1
    end
    if @flash_duration >= 1
      d = @flash_duration
      @flash_color.alpha = @flash_color.alpha * (d - 1) / d
      @flash_duration -= 1
    end
    if @shake_duration >= 1 or @shake != 0
      delta = (@shake_power * @shake_speed * @shake_direction) / 10.0
      if @shake_duration <= 1 and @shake * (@shake + delta) < 0
        @shake = 0
      else
        @shake += delta
      end
      if @shake > @shake_power * 2
        @shake_direction = -1
      end
      if @shake < - @shake_power * 2
        @shake_direction = 1
      end
      if @shake_duration >= 1
        @shake_duration -= 1
      end
    end
    if @weather_duration >= 1
      d = @weather_duration
      @weather_max = (@weather_max * (d - 1) + @weather_max_target) / d
      @weather_duration -= 1
      if @weather_duration == 0
        @weather_type = @weather_type_target
      end
    end
    if $game_temp.in_battle
      for i in 51..100
        @pictures[i].update
      end
    else
      for i in 1..50
        @pictures[i].update
      end
    end
  end
end

#==============================================================================
# ■ Game_Picture
#------------------------------------------------------------------------------
# 　ピクチャを扱うクラスです。このクラスは Game_Screen クラス ($game_screen)
# の内部で使用されます。
#==============================================================================

class Game_Picture
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :number                   # ピクチャ番号
  attr_reader   :name                     # ファイル名
  attr_reader   :origin                   # 原点
  attr_reader   :x                        # X 座標
  attr_reader   :y                        # Y 座標
  attr_reader   :zoom_x                   # X 方向拡大率
  attr_reader   :zoom_y                   # Y 方向拡大率
  attr_reader   :opacity                  # 不透明度
  attr_reader   :blend_type               # ブレンド方法
  attr_reader   :tone                     # 色調
  attr_reader   :angle                    # 回転角度
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     number : ピクチャ番号
  #--------------------------------------------------------------------------
  def initialize(number)
    @number = number
    @name = ""
    @origin = 0
    @x = 0.0
    @y = 0.0
    @zoom_x = 100.0
    @zoom_y = 100.0
    @opacity = 255.0
    @blend_type = 1
    @duration = 0
    @target_x = @x
    @target_y = @y
    @target_zoom_x = @zoom_x
    @target_zoom_y = @zoom_y
    @target_opacity = @opacity
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @angle = 0
    @rotate_speed = 0
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの表示
  #     name         : ファイル名
  #     origin       : 原点
  #     x            : X 座標
  #     y            : Y 座標
  #     zoom_x       : X 方向拡大率
  #     zoom_y       : Y 方向拡大率
  #     opacity      : 不透明度
  #     blend_type   : ブレンド方法
  #--------------------------------------------------------------------------
  def show(name, origin, x, y, zoom_x, zoom_y, opacity, blend_type)
    @name = name
    @origin = origin
    @x = x.to_f
    @y = y.to_f
    @zoom_x = zoom_x.to_f
    @zoom_y = zoom_y.to_f
    @opacity = opacity.to_f
    @blend_type = blend_type
    @duration = 0
    @target_x = @x
    @target_y = @y
    @target_zoom_x = @zoom_x
    @target_zoom_y = @zoom_y
    @target_opacity = @opacity
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @angle = 0
    @rotate_speed = 0
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの移動
  #     duration     : 時間
  #     origin       : 原点
  #     x            : X 座標
  #     y            : Y 座標
  #     zoom_x       : X 方向拡大率
  #     zoom_y       : Y 方向拡大率
  #     opacity      : 不透明度
  #     blend_type   : ブレンド方法
  #--------------------------------------------------------------------------
  def move(duration, origin, x, y, zoom_x, zoom_y, opacity, blend_type)
    @duration = duration
    @origin = origin
    @target_x = x.to_f
    @target_y = y.to_f
    @target_zoom_x = zoom_x.to_f
    @target_zoom_y = zoom_y.to_f
    @target_opacity = opacity.to_f
    @blend_type = blend_type
  end
  #--------------------------------------------------------------------------
  # ● 回転速度の変更
  #     speed : 回転速度
  #--------------------------------------------------------------------------
  def rotate(speed)
    @rotate_speed = speed
  end
  #--------------------------------------------------------------------------
  # ● 色調変更の開始
  #     tone     : 色調
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_tone_change(tone, duration)
    @tone_target = tone.clone
    @tone_duration = duration
    if @tone_duration == 0
      @tone = @tone_target.clone
    end
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの消去
  #--------------------------------------------------------------------------
  def erase
    @name = ""
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    if @duration >= 1
      d = @duration
      @x = (@x * (d - 1) + @target_x) / d
      @y = (@y * (d - 1) + @target_y) / d
      @zoom_x = (@zoom_x * (d - 1) + @target_zoom_x) / d
      @zoom_y = (@zoom_y * (d - 1) + @target_zoom_y) / d
      @opacity = (@opacity * (d - 1) + @target_opacity) / d
      @duration -= 1
    end
    if @tone_duration >= 1
      d = @tone_duration
      @tone.red = (@tone.red * (d - 1) + @tone_target.red) / d
      @tone.green = (@tone.green * (d - 1) + @tone_target.green) / d
      @tone.blue = (@tone.blue * (d - 1) + @tone_target.blue) / d
      @tone.gray = (@tone.gray * (d - 1) + @tone_target.gray) / d
      @tone_duration -= 1
    end
    if @rotate_speed != 0
      @angle += @rotate_speed / 2.0
      while @angle < 0
        @angle += 360
      end
      @angle %= 360
    end
  end
end

#==============================================================================
# ■ Game_Battler (分割定義 1)
#------------------------------------------------------------------------------
# 　バトラーを扱うクラスです。このクラスは Game_Actor クラスと Game_Enemy クラ
# スのスーパークラスとして使用されます。
#==============================================================================

class Game_Battler
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :battler_name             # バトラー ファイル名
  attr_reader   :battler_hue              # バトラー 色相
  attr_reader   :hp                       # HP
  attr_reader   :sp                       # SP
  attr_reader   :states                   # ステート
  attr_accessor :hidden                   # 隠れフラグ
  attr_accessor :immortal                 # 不死身フラグ
  attr_accessor :damage_pop               # ダメージ表示フラグ
  attr_accessor :damage                   # ダメージ値
  attr_accessor :critical                 # クリティカルフラグ
  attr_accessor :animation_id             # アニメーション ID
  attr_accessor :animation_hit            # アニメーション ヒットフラグ
  attr_accessor :white_flash              # 白フラッシュフラグ
  attr_accessor :blink                    # 明滅フラグ
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @battler_name = ""
    @battler_hue = 0
    @hp = 0
    @sp = 0
    @states = []
    @states_turn = {}
    @maxhp_plus = 0
    @maxsp_plus = 0
    @str_plus = 0
    @dex_plus = 0
    @agi_plus = 0
    @int_plus = 0
    @hidden = false
    @immortal = false
    @damage_pop = false
    @damage = nil
    @critical = false
    @animation_id = 0
    @animation_hit = false
    @white_flash = false
    @blink = false
    @current_action = Game_BattleAction.new
  end
  #--------------------------------------------------------------------------
  # ● MaxHP の取得
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 999999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● MaxSP の取得
  #--------------------------------------------------------------------------
  def maxsp
    n = [[base_maxsp + @maxsp_plus, 0].max, 9999].min
    for i in @states
      n *= $data_states[i].maxsp_rate / 100.0
    end
    n = [[Integer(n), 0].max, 9999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● 腕力の取得
  #--------------------------------------------------------------------------
  def str
    n = [[base_str + @str_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].str_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● 器用さの取得
  #--------------------------------------------------------------------------
  def dex
    n = [[base_dex + @dex_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].dex_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● 素早さの取得
  #--------------------------------------------------------------------------
  def agi
    n = [[base_agi + @agi_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].agi_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● 魔力の取得
  #--------------------------------------------------------------------------
  def int
    n = [[base_int + @int_plus, 1].max, 999].min
    for i in @states
      n *= $data_states[i].int_rate / 100.0
    end
    n = [[Integer(n), 1].max, 999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● MaxHP の設定
  #     maxhp : 新しい MaxHP
  #--------------------------------------------------------------------------
  def maxhp=(maxhp)
    @maxhp_plus += maxhp - self.maxhp
    @maxhp_plus = [[@maxhp_plus, -9999].max, 9999].min
    @hp = [@hp, self.maxhp].min
  end
  #--------------------------------------------------------------------------
  # ● MaxSP の設定
  #     maxsp : 新しい MaxSP
  #--------------------------------------------------------------------------
  def maxsp=(maxsp)
    @maxsp_plus += maxsp - self.maxsp
    @maxsp_plus = [[@maxsp_plus, -9999].max, 9999].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # ● 腕力の設定
  #     str : 新しい腕力
  #--------------------------------------------------------------------------
  def str=(str)
    @str_plus += str - self.str
    @str_plus = [[@str_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 器用さの設定
  #     dex : 新しい器用さ
  #--------------------------------------------------------------------------
  def dex=(dex)
    @dex_plus += dex - self.dex
    @dex_plus = [[@dex_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 素早さの設定
  #     agi : 新しい素早さ
  #--------------------------------------------------------------------------
  def agi=(agi)
    @agi_plus += agi - self.agi
    @agi_plus = [[@agi_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 魔力の設定
  #     int : 新しい魔力
  #--------------------------------------------------------------------------
  def int=(int)
    @int_plus += int - self.int
    @int_plus = [[@int_plus, -999].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 命中率の取得
  #--------------------------------------------------------------------------
  def hit
    n = 100
    for i in @states
      n *= $data_states[i].hit_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # ● 攻撃力の取得
  #--------------------------------------------------------------------------
  def atk
    n = base_atk
    for i in @states
      n *= $data_states[i].atk_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # ● 物理防御の取得
  #--------------------------------------------------------------------------
  def pdef
    n = base_pdef
    for i in @states
      n *= $data_states[i].pdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # ● 魔法防御の取得
  #--------------------------------------------------------------------------
  def mdef
    n = base_mdef
    for i in @states
      n *= $data_states[i].mdef_rate / 100.0
    end
    return Integer(n)
  end
  #--------------------------------------------------------------------------
  # ● 回避修正の取得
  #--------------------------------------------------------------------------
  def eva
    n = base_eva
    for i in @states
      n += $data_states[i].eva
    end
    return n
  end
  #--------------------------------------------------------------------------
  # ● HP の変更
  #     hp : 新しい HP
  #--------------------------------------------------------------------------
  def hp=(hp)
    @hp = [[hp, maxhp].min, 0].max
    # 戦闘不能を付加または解除
    for i in 1...$data_states.size
      if $data_states[i].zero_hp
        if self.dead?
          add_state(i)
        else
          remove_state(i)
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● SP の変更
  #     sp : 新しい SP
  #--------------------------------------------------------------------------
  def sp=(sp)
    @sp = [[sp, maxsp].min, 0].max
  end
  #--------------------------------------------------------------------------
  # ● 全回復
  #--------------------------------------------------------------------------
  def recover_all
    @hp = maxhp
    @sp = maxsp
    for i in @states.clone
      remove_state(i)
    end
  end
  #--------------------------------------------------------------------------
  # ● カレントアクションの取得
  #--------------------------------------------------------------------------
  def current_action
    return @current_action
  end
  #--------------------------------------------------------------------------
  # ● アクションスピードの決定
  #--------------------------------------------------------------------------
  def make_action_speed
    @current_action.speed = agi + rand(10 + agi / 4)
  end
  #--------------------------------------------------------------------------
  # ● 戦闘不能判定
  #--------------------------------------------------------------------------
  def dead?
    return (@hp == 0 and not @immortal)
  end
  #--------------------------------------------------------------------------
  # ● 存在判定
  #--------------------------------------------------------------------------
  def exist?
    return (not @hidden and (@hp > 0 or @immortal))
  end
  #--------------------------------------------------------------------------
  # ● HP 0 判定
  #--------------------------------------------------------------------------
  def hp0?
    return (not @hidden and @hp == 0)
  end
  #--------------------------------------------------------------------------
  # ● コマンド入力可能判定
  #--------------------------------------------------------------------------
  def inputable?
    return (not @hidden and restriction <= 1)
  end
  #--------------------------------------------------------------------------
  # ● 行動可能判定
  #--------------------------------------------------------------------------
  def movable?
    return (not @hidden and restriction < 4)
  end
  #--------------------------------------------------------------------------
  # ● 防御中判定
  #--------------------------------------------------------------------------
  def guarding?
    return (@current_action.kind == 0 and @current_action.basic == 1)
  end
  #--------------------------------------------------------------------------
  # ● 休止中判定
  #--------------------------------------------------------------------------
  def resting?
    return (@current_action.kind == 0 and @current_action.basic == 3)
  end
end

#==============================================================================
# ■ Game_Battler (分割定義 2)
#------------------------------------------------------------------------------
# 　バトラーを扱うクラスです。このクラスは Game_Actor クラスと Game_Enemy クラ
# スのスーパークラスとして使用されます。
#==============================================================================

class Game_Battler
  #--------------------------------------------------------------------------
  # ● ステートの検査
  #     state_id : ステート ID
  #--------------------------------------------------------------------------
  def state?(state_id)
    # 該当するステートが付加されていれば true を返す
    return @states.include?(state_id)
  end
  #--------------------------------------------------------------------------
  # ● ステートがフルかどうかの判定
  #     state_id : ステート ID
  #--------------------------------------------------------------------------
  def state_full?(state_id)
    # 該当するステートが付加されていなけば false を返す
    unless self.state?(state_id)
      return false
    end
    # 持続ターン数が -1 (オートステート) なら true を返す
    if @states_turn[state_id] == -1
      return true
    end
    # 持続ターン数が自然解除の最低ターン数と同じなら true を返す
    return @states_turn[state_id] == $data_states[state_id].hold_turn
  end
  #--------------------------------------------------------------------------
  # ● ステートの付加
  #     state_id : ステート ID
  #     force    : 強制付加フラグ (オートステートの処理で使用)
  #--------------------------------------------------------------------------
  def add_state(state_id, force = false)
    # 無効なステートの場合
    if $data_states[state_id] == nil
      # メソッド終了
      return
    end
    # 強制付加ではない場合
    unless force
      # 既存のステートのループ
      for i in @states
        # 新しいステートが既存のステートのステート変化 (-) に含まれており、
        # そのステートが新しいステートのステート変化 (-) には含まれない場合
        # (ex : 戦闘不能のときに毒を付加しようとした場合)
        if $data_states[i].minus_state_set.include?(state_id) and
           not $data_states[state_id].minus_state_set.include?(i)
          # メソッド終了
          return
        end
      end
    end
    # このステートが付加されていない場合
    unless state?(state_id)
      # ステート ID を @states 配列に追加
      @states.push(state_id)
      # オプション [HP 0 の状態とみなす] が有効の場合
      if $data_states[state_id].zero_hp
        # HP を 0 に変更
        @hp = 0
      end
      # 全ステートのループ
      for i in 1...$data_states.size
        # ステート変化 (+) 処理
        if $data_states[state_id].plus_state_set.include?(i)
          add_state(i)
        end
        # ステート変化 (-) 処理
        if $data_states[state_id].minus_state_set.include?(i)
          remove_state(i)
        end
      end
      # レーティングの大きい順 (同値の場合は制約の強い順) に並び替え
      @states.sort! do |a, b|
        state_a = $data_states[a]
        state_b = $data_states[b]
        if state_a.rating > state_b.rating
          -1
        elsif state_a.rating < state_b.rating
          +1
        elsif state_a.restriction > state_b.restriction
          -1
        elsif state_a.restriction < state_b.restriction
          +1
        else
          a <=> b
        end
      end
    end
    # 強制付加の場合
    if force
      # 自然解除の最低ターン数を -1 (無効) に設定
      @states_turn[state_id] = -1
    end
    # 強制付加ではない場合
    unless  @states_turn[state_id] == -1
      # 自然解除の最低ターン数を設定
      @states_turn[state_id] = $data_states[state_id].hold_turn
    end
    # 行動不能の場合
    unless movable?
      # アクションをクリア
      @current_action.clear
    end
    # HP および SP の最大値チェック
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # ● ステートの解除
  #     state_id : ステート ID
  #     force    : 強制解除フラグ (オートステートの処理で使用)
  #--------------------------------------------------------------------------
  def remove_state(state_id, force = false)
    # このステートが付加されている場合
    if state?(state_id)
      # 強制付加されたステートで、かつ解除が強制ではない場合
      if @states_turn[state_id] == -1 and not force
        # メソッド終了
        return
      end
      # 現在の HP が 0 かつ オプション [HP 0 の状態とみなす] が有効の場合
      if @hp == 0 and $data_states[state_id].zero_hp
        # ほかに [HP 0 の状態とみなす] ステートがあるかどうか判定
        zero_hp = false
        for i in @states
          if i != state_id and $data_states[i].zero_hp
            zero_hp = true
          end
        end
        # 戦闘不能を解除してよければ、HP を 1 に変更
        if zero_hp == false
          @hp = 1
        end
      end
      # ステート ID を @states 配列および @states_turn ハッシュから削除
      @states.delete(state_id)
      @states_turn.delete(state_id)
    end
    # HP および SP の最大値チェック
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # ● ステートのアニメーション ID 取得
  #--------------------------------------------------------------------------
  def state_animation_id
    # ステートがひとつも付加されていない場合
    if @states.size == 0
      return 0
    end
    # レーティング最大のステートのアニメーション ID を返す
    return $data_states[@states[0]].animation_id
  end
  #--------------------------------------------------------------------------
  # ● 制約の取得
  #--------------------------------------------------------------------------
  def restriction
    restriction_max = 0
    # 現在付加されているステートから最大の restriction を取得
    for i in @states
      if $data_states[i].restriction >= restriction_max
        restriction_max = $data_states[i].restriction
      end
    end
    return restriction_max
  end
  #--------------------------------------------------------------------------
  # ● ステート [EXP を獲得できない] 判定
  #--------------------------------------------------------------------------
  def cant_get_exp?
    for i in @states
      if $data_states[i].cant_get_exp
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● ステート [攻撃を回避できない] 判定
  #--------------------------------------------------------------------------
  def cant_evade?
    for i in @states
      if $data_states[i].cant_evade
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● ステート [スリップダメージ] 判定
  #--------------------------------------------------------------------------
  def slip_damage?
    for i in @states
      if $data_states[i].slip_damage
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● バトル用ステートの解除 (バトル終了時に呼び出し)
  #--------------------------------------------------------------------------
  def remove_states_battle
    for i in @states.clone
      if $data_states[i].battle_only
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● ステート自然解除 (ターンごとに呼び出し)
  #--------------------------------------------------------------------------
  def remove_states_auto
    for i in @states_turn.keys.clone
      if @states_turn[i] > 0
        @states_turn[i] -= 1
      elsif rand(100) < $data_states[i].auto_release_prob
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● ステート衝撃解除 (物理ダメージごとに呼び出し)
  #--------------------------------------------------------------------------
  def remove_states_shock
    for i in @states.clone
      if rand(100) < $data_states[i].shock_release_prob
        remove_state(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● ステート変化 (+) の適用
  #     plus_state_set  : ステート変化 (+)
  #--------------------------------------------------------------------------
  def states_plus(plus_state_set)
    # 有効フラグをクリア
    effective = false
    # ループ (付加するステート)
    for i in plus_state_set
      # このステートが防御されていない場合
      unless self.state_guard?(i)
        # このステートがフルでなければ有効フラグをセット
        effective |= self.state_full?(i) == false
        # ステートが [抵抗しない] の場合
        if $data_states[i].nonresistance
          # ステート変化フラグをセット
          @state_changed = true
          # ステートを付加
          add_state(i)
        # このステートがフルではない場合
        elsif self.state_full?(i) == false
          # ステート有効度を確率に変換し、乱数と比較
          if rand(100) < [0,100,80,60,40,20,0][self.state_ranks[i]]
            # ステート変化フラグをセット
            @state_changed = true
            # ステートを付加
            add_state(i)
          end
        end
      end
    end
    # メソッド終了
    return effective
  end
  #--------------------------------------------------------------------------
  # ● ステート変化 (-) の適用
  #     minus_state_set : ステート変化 (-)
  #--------------------------------------------------------------------------
  def states_minus(minus_state_set)
    # 有効フラグをクリア
    effective = false
    # ループ (解除するステート)
    for i in minus_state_set
      # このステートが付加されていれば有効フラグをセット
      effective |= self.state?(i)
      # ステート変化フラグをセット
      @state_changed = true
      # ステートを解除
      remove_state(i)
    end
    # メソッド終了
    return effective
  end
end

#==============================================================================
# ■ Game_Battler (分割定義 3)
#------------------------------------------------------------------------------
# 　バトラーを扱うクラスです。このクラスは Game_Actor クラスと Game_Enemy クラ
# スのスーパークラスとして使用されます。
#==============================================================================

class Game_Battler
  #--------------------------------------------------------------------------
  # ● スキルの使用可能判定
  #     skill_id : スキル ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    # SP が足りない場合は使用不可
    if $data_skills[skill_id].sp_cost > self.sp
      return false
    end
    # 戦闘不能の場合は使用不可
    if dead?
      return false
    end
    # 沈黙状態の場合、物理スキル以外は使用不可
    if $data_skills[skill_id].atk_f == 0 and self.restriction == 1
      return false
    end
    # 使用可能時を取得
    occasion = $data_skills[skill_id].occasion
    # 戦闘中の場合
    if $game_temp.in_battle
      # [常時] または [バトルのみ] なら使用可
      return (occasion == 0 or occasion == 1)
    # 戦闘中ではない場合
    else
      # [常時] または [メニューのみ] なら使用可
      return (occasion == 0 or occasion == 2)
    end
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃の効果適用
  #     attacker : 攻撃者 (バトラー)
  #--------------------------------------------------------------------------
  def attack_effect(attacker)
    # クリティカルフラグをクリア
    self.critical = false
    # 第一命中判定
    hit_result = (rand(100) < attacker.hit)
    # 命中の場合
    if hit_result == true
      # 基本ダメージを計算
      atk = [attacker.atk - self.pdef / 2, 0].max
      self.damage = atk * (20 + attacker.str) / 20
      # 属性修正
      self.damage *= elements_correct(attacker.element_set)
      self.damage /= 100
      # ダメージの符号が正の場合
      if self.damage > 0
        # クリティカル修正
        if rand(100) < 4 * attacker.dex / self.agi
          self.damage *= 2
          self.critical = true
        end
        # 防御修正
        if self.guarding?
          self.damage /= 2
        end
      end
      # 分散
      if self.damage.abs > 0
        amp = [self.damage.abs * 15 / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # 第二命中判定
      eva = 8 * self.agi / attacker.dex + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
    end
    # 命中の場合
    if hit_result == true
      # ステート衝撃解除
      remove_states_shock
      # HP からダメージを減算
      self.hp -= self.damage
      # ステート変化
      @state_changed = false
      states_plus(attacker.plus_state_set)
      states_minus(attacker.minus_state_set)
    # ミスの場合
    else
      # ダメージに "Miss" を設定
      self.damage = "Miss"
      # クリティカルフラグをクリア
      self.critical = false
    end
    # メソッド終了
    return true
  end
  #--------------------------------------------------------------------------
  # ● スキルの効果適用
  #     user  : スキルの使用者 (バトラー)
  #     skill : スキル
  #--------------------------------------------------------------------------
  def skill_effect(user, skill)
    # クリティカルフラグをクリア
    self.critical = false
    # スキルの効果範囲が HP 1 以上の味方で、自分の HP が 0、
    # またはスキルの効果範囲が HP 0 の味方で、自分の HP が 1 以上の場合
    if ((skill.scope == 3 or skill.scope == 4) and self.hp == 0) or
       ((skill.scope == 5 or skill.scope == 6) and self.hp >= 1)
      # メソッド終了
      return false
    end
    # 有効フラグをクリア
    effective = false
    # コモンイベント ID が有効の場合は有効フラグをセット
    effective |= skill.common_event_id > 0
    # 第一命中判定
    hit = skill.hit
    if skill.atk_f > 0
      hit *= user.hit / 100
    end
    hit_result = (rand(100) < hit)
    # 不確実なスキルの場合は有効フラグをセット
    effective |= hit < 100
    # 命中の場合
    if hit_result == true
      # 威力を計算
      power = skill.power + user.atk * skill.atk_f / 100
      if power > 0
        power -= self.pdef * skill.pdef_f / 200
        power -= self.mdef * skill.mdef_f / 200
        power = [power, 0].max
      end
      # 倍率を計算
      rate = 20
      rate += (user.str * skill.str_f / 100)
      rate += (user.dex * skill.dex_f / 100)
      rate += (user.agi * skill.agi_f / 100)
      rate += (user.int * skill.int_f / 100)
      # 基本ダメージを計算
      self.damage = power * rate / 20
      # 属性修正
      self.damage *= elements_correct(skill.element_set)
      self.damage /= 100
      # ダメージの符号が正の場合
      if self.damage > 0
        # 防御修正
        if self.guarding?
          self.damage /= 2
        end
      end
      # 分散
      if skill.variance > 0 and self.damage.abs > 0
        amp = [self.damage.abs * skill.variance / 100, 1].max
        self.damage += rand(amp+1) + rand(amp+1) - amp
      end
      # 第二命中判定
      eva = 8 * self.agi / user.dex + self.eva
      hit = self.damage < 0 ? 100 : 100 - eva * skill.eva_f / 100
      hit = self.cant_evade? ? 100 : hit
      hit_result = (rand(100) < hit)
      # 不確実なスキルの場合は有効フラグをセット
      effective |= hit < 100
    end
    # 命中の場合
    if hit_result == true
      # 威力 0 以外の物理攻撃の場合
      if skill.power != 0 and skill.atk_f > 0
        # ステート衝撃解除
        remove_states_shock
        # 有効フラグをセット
        effective = true
      end
      # HP からダメージを減算
      last_hp = self.hp
      self.hp -= self.damage
      effective |= self.hp != last_hp
      # ステート変化
      @state_changed = false
      effective |= states_plus(skill.plus_state_set)
      effective |= states_minus(skill.minus_state_set)
      # 威力が 0 の場合
      if skill.power == 0
        # ダメージに空文字列を設定
        self.damage = ""
        # ステートに変化がない場合
        unless @state_changed
          # ダメージに "Miss" を設定
          self.damage = "Miss"
        end
      end
    # ミスの場合
    else
      # ダメージに "Miss" を設定
      self.damage = "Miss"
    end
    # 戦闘中でない場合
    unless $game_temp.in_battle
      # ダメージに nil を設定
      self.damage = nil
    end
    # メソッド終了
    return effective
  end
  #--------------------------------------------------------------------------
  # ● アイテムの効果適用
  #     item : アイテム
  #--------------------------------------------------------------------------
  def item_effect(item)
    # クリティカルフラグをクリア
    self.critical = false
    # アイテムの効果範囲が HP 1 以上の味方で、自分の HP が 0、
    # またはアイテムの効果範囲が HP 0 の味方で、自分の HP が 1 以上の場合
    if ((item.scope == 3 or item.scope == 4) and self.hp == 0) or
       ((item.scope == 5 or item.scope == 6) and self.hp >= 1)
      # メソッド終了
      return false
    end
    # 有効フラグをクリア
    effective = false
    # コモンイベント ID が有効の場合は有効フラグをセット
    effective |= item.common_event_id > 0
    # 命中判定
    hit_result = (rand(100) < item.hit)
    # 不確実なスキルの場合は有効フラグをセット
    effective |= item.hit < 100
    # 命中の場合
    if hit_result == true
      # 回復量を計算
      recover_hp = maxhp * item.recover_hp_rate / 100 + item.recover_hp
      recover_sp = maxsp * item.recover_sp_rate / 100 + item.recover_sp
      if recover_hp < 0
        recover_hp += self.pdef * item.pdef_f / 20
        recover_hp += self.mdef * item.mdef_f / 20
        recover_hp = [recover_hp, 0].min
      end
      # 属性修正
      recover_hp *= elements_correct(item.element_set)
      recover_hp /= 100
      recover_sp *= elements_correct(item.element_set)
      recover_sp /= 100
      # 分散
      if item.variance > 0 and recover_hp.abs > 0
        amp = [recover_hp.abs * item.variance / 100, 1].max
        recover_hp += rand(amp+1) + rand(amp+1) - amp
      end
      if item.variance > 0 and recover_sp.abs > 0
        amp = [recover_sp.abs * item.variance / 100, 1].max
        recover_sp += rand(amp+1) + rand(amp+1) - amp
      end
      # 回復量の符号が負の場合
      if recover_hp < 0
        # 防御修正
        if self.guarding?
          recover_hp /= 2
        end
      end
      # HP 回復量の符号を反転し、ダメージの値に設定
      self.damage = -recover_hp
      # HP および SP を回復
      last_hp = self.hp
      last_sp = self.sp
      self.hp += recover_hp
      self.sp += recover_sp
      effective |= self.hp != last_hp
      effective |= self.sp != last_sp
      # ステート変化
      @state_changed = false
      effective |= states_plus(item.plus_state_set)
      effective |= states_minus(item.minus_state_set)
      # パラメータ上昇値が有効の場合
      if item.parameter_type > 0 and item.parameter_points != 0
        # パラメータで分岐
        case item.parameter_type
        when 1  # MaxHP
          @maxhp_plus += item.parameter_points
        when 2  # MaxSP
          @maxsp_plus += item.parameter_points
        when 3  # 腕力
          @str_plus += item.parameter_points
        when 4  # 器用さ
          @dex_plus += item.parameter_points
        when 5  # 素早さ
          @agi_plus += item.parameter_points
        when 6  # 魔力
          @int_plus += item.parameter_points
        end
        # 有効フラグをセット
        effective = true
      end
      # HP 回復率と回復量が 0 の場合
      if item.recover_hp_rate == 0 and item.recover_hp == 0
        # ダメージに空文字列を設定
        self.damage = ""
        # SP 回復率と回復量が 0、パラメータ上昇値が無効の場合
        if item.recover_sp_rate == 0 and item.recover_sp == 0 and
           (item.parameter_type == 0 or item.parameter_points == 0)
          # ステートに変化がない場合
          unless @state_changed
            # ダメージに "Miss" を設定
            self.damage = "Miss"
          end
        end
      end
    # ミスの場合
    else
      # ダメージに "Miss" を設定
      self.damage = "Miss"
    end
    # 戦闘中でない場合
    unless $game_temp.in_battle
      # ダメージに nil を設定
      self.damage = nil
    end
    # メソッド終了
    return effective
  end
  #--------------------------------------------------------------------------
  # ● スリップダメージの効果適用
  #--------------------------------------------------------------------------
  def slip_damage_effect
    # ダメージを設定
    self.damage = self.maxhp / 10
    # 分散
    if self.damage.abs > 0
      amp = [self.damage.abs * 15 / 100, 1].max
      self.damage += rand(amp+1) + rand(amp+1) - amp
    end
    # HP からダメージを減算
    self.hp -= self.damage
    # メソッド終了
    return true
  end
  #--------------------------------------------------------------------------
  # ● 属性修正の計算
  #     element_set : 属性
  #--------------------------------------------------------------------------
  def elements_correct(element_set)
    # 無属性の場合
    if element_set == []
      # 100 を返す
      return 100
    end
    # 与えられた属性の中で最も弱いものを返す
    # ※メソッド element_rate は、このクラスから継承される Game_Actor
    #   および Game_Enemy クラスで定義される
    weakest = -100
    for i in element_set
      weakest = [weakest, self.element_rate(i)].max
    end
    return weakest
  end
end

#==============================================================================
# ■ Game_BattleAction
#------------------------------------------------------------------------------
# 　アクション (戦闘中の行動) を扱うクラスです。このクラスは Game_Battler クラ
# スの内部で使用されます。
#==============================================================================

class Game_BattleAction
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :speed                    # スピード
  attr_accessor :kind                     # 種別 (基本 / スキル / アイテム)
  attr_accessor :basic                    # 基本 (攻撃 / 防御 / 逃げる)
  attr_accessor :skill_id                 # スキル ID
  attr_accessor :item_id                  # アイテム ID
  attr_accessor :target_index             # 対象インデックス
  attr_accessor :forcing                  # 強制フラグ
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    clear
  end
  #--------------------------------------------------------------------------
  # ● クリア
  #--------------------------------------------------------------------------
  def clear
    @speed = 0
    @kind = 0
    @basic = 3
    @skill_id = 0
    @item_id = 0
    @target_index = -1
    @forcing = false
  end
  #--------------------------------------------------------------------------
  # ● 有効判定
  #--------------------------------------------------------------------------
  def valid?
    return (not (@kind == 0 and @basic == 3))
  end
  #--------------------------------------------------------------------------
  # ● 味方単体用判定
  #--------------------------------------------------------------------------
  def for_one_friend?
    # 種別がスキルで、効果範囲が味方単体 (HP 0 を含む) の場合
    if @kind == 1 and [3, 5].include?($data_skills[@skill_id].scope)
      return true
    end
    # 種別がアイテムで、効果範囲が味方単体 (HP 0 を含む) の場合
    if @kind == 2 and [3, 5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 味方単体用 (HP 0) 判定
  #--------------------------------------------------------------------------
  def for_one_friend_hp0?
    # 種別がスキルで、効果範囲が味方単体 (HP 0 のみ) の場合
    if @kind == 1 and [5].include?($data_skills[@skill_id].scope)
      return true
    end
    # 種別がアイテムで、効果範囲が味方単体 (HP 0 のみ) の場合
    if @kind == 2 and [5].include?($data_items[@item_id].scope)
      return true
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● ランダムターゲット (アクター用)
  #--------------------------------------------------------------------------
  def decide_random_target_for_actor
    # 効果範囲で分岐
    if for_one_friend_hp0?
      battler = $game_party.random_target_actor_hp0
    elsif for_one_friend?
      battler = $game_party.random_target_actor
    else
      battler = $game_troop.random_target_enemy
    end
    # 対象が存在するならインデックスを取得し、
    # 対象が存在しない場合はアクションをクリア
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # ● ランダムターゲット (エネミー用)
  #--------------------------------------------------------------------------
  def decide_random_target_for_enemy
    # 効果範囲で分岐
    if for_one_friend_hp0?
      battler = $game_troop.random_target_enemy_hp0
    elsif for_one_friend?
      battler = $game_troop.random_target_enemy
    else
      battler = $game_party.random_target_actor
    end
    # 対象が存在するならインデックスを取得し、
    # 対象が存在しない場合はアクションをクリア
    if battler != nil
      @target_index = battler.index
    else
      clear
    end
  end
  #--------------------------------------------------------------------------
  # ● ラストターゲット (アクター用)
  #--------------------------------------------------------------------------
  def decide_last_target_for_actor
    # 効果範囲が味方単体ならアクター、それ以外ならエネミー
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_party.actors[@target_index]
    else
      battler = $game_troop.enemies[@target_index]
    end
    # 対象が存在しない場合はアクションをクリア
    if battler == nil or not battler.exist?
      clear
    end
  end
  #--------------------------------------------------------------------------
  # ● ラストターゲット (エネミー用)
  #--------------------------------------------------------------------------
  def decide_last_target_for_enemy
    # 効果範囲が味方単体ならエネミー、それ以外ならアクター
    if @target_index == -1
      battler = nil
    elsif for_one_friend?
      battler = $game_troop.enemies[@target_index]
    else
      battler = $game_party.actors[@target_index]
    end
    # 対象が存在しない場合はアクションをクリア
    if battler == nil or not battler.exist?
      clear
    end
  end
end

#==============================================================================
# ■ Game_Actor
#------------------------------------------------------------------------------
# 　アクターを扱うクラスです。このクラスは Game_Actors クラス ($game_actors)
# の内部で使用され、Game_Party クラス ($game_party) からも参照されます。
#==============================================================================

class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :name                     # 名前
  attr_reader   :character_name           # キャラクター ファイル名
  attr_reader   :character_hue            # キャラクター 色相
  attr_reader   :class_id                 # クラス ID
  attr_reader   :weapon_id                # 武器 ID
  attr_reader   :armor1_id                # 盾 ID
  attr_reader   :armor2_id                # 頭防具 ID
  attr_reader   :armor3_id                # 体防具 ID
  attr_reader   :armor4_id                # 装飾品 ID
  attr_reader   :level                    # レベル
  attr_reader   :exp                      # EXP
  attr_reader   :skills                   # スキル
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor_id : アクター ID
  #--------------------------------------------------------------------------
  def initialize(actor_id)
    super()
    setup(actor_id)
  end
  #--------------------------------------------------------------------------
  # ● セットアップ
  #     actor_id : アクター ID
  #--------------------------------------------------------------------------
  def setup(actor_id)
    actor = $data_actors[actor_id]
    @actor_id = actor_id
    @name = actor.name
    @character_name = actor.character_name
    @character_hue = actor.character_hue
    @battler_name = actor.battler_name
    @battler_hue = actor.battler_hue
    @class_id = actor.class_id
    @weapon_id = actor.weapon_id
    @armor1_id = actor.armor1_id
    @armor2_id = actor.armor2_id
    @armor3_id = actor.armor3_id
    @armor4_id = actor.armor4_id
    @level = actor.initial_level
    @exp_list = Array.new(101)
    make_exp_list
    @exp = @exp_list[@level]
    @skills = []
    @hp = maxhp
    @sp = maxsp
    @states = []
    @states_turn = {}
    @maxhp_plus = 0
    @maxsp_plus = 0
    @str_plus = 0
    @dex_plus = 0
    @agi_plus = 0
    @int_plus = 0
    # スキル習得
    for i in 1..@level
      for j in $data_classes[@class_id].learnings
        if j.level == i
          learn_skill(j.skill_id)
        end
      end
    end
    # オートステートを更新
    update_auto_state(nil, $data_armors[@armor1_id])
    update_auto_state(nil, $data_armors[@armor2_id])
    update_auto_state(nil, $data_armors[@armor3_id])
    update_auto_state(nil, $data_armors[@armor4_id])
  end
  #--------------------------------------------------------------------------
  # ● アクター ID 取得
  #--------------------------------------------------------------------------
  def id
    return @actor_id
  end
  #--------------------------------------------------------------------------
  # ● インデックス取得
  #--------------------------------------------------------------------------
  def index
    return $game_party.actors.index(self)
  end
  #--------------------------------------------------------------------------
  # ● EXP 計算
  #--------------------------------------------------------------------------
  def make_exp_list
    actor = $data_actors[@actor_id]
    @exp_list[1] = 0
    pow_i = 2.4 + actor.exp_inflation / 100.0
    for i in 2..100
      if i > actor.final_level
        @exp_list[i] = 0
      else
        n = actor.exp_basis * ((i + 3) ** pow_i) / (5 ** pow_i)
        @exp_list[i] = @exp_list[i-1] + Integer(n)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 属性補正値の取得
  #     element_id : 属性 ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # 属性有効度に対応する数値を取得
    table = [0,200,150,100,50,0,-100]
    result = table[$data_classes[@class_id].element_ranks[element_id]]
    # 防具でこの属性が防御されている場合は半減
    for i in [@armor1_id, @armor2_id, @armor3_id, @armor4_id]
      armor = $data_armors[i]
      if armor != nil and armor.guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # ステートでこの属性が防御されている場合は半減
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # メソッド終了
    return result
  end
  #--------------------------------------------------------------------------
  # ● ステート有効度の取得
  #--------------------------------------------------------------------------
  def state_ranks
    return $data_classes[@class_id].state_ranks
  end
  #--------------------------------------------------------------------------
  # ● ステート防御判定
  #     state_id : ステート ID
  #--------------------------------------------------------------------------
  def state_guard?(state_id)
    for i in [@armor1_id, @armor2_id, @armor3_id, @armor4_id]
      armor = $data_armors[i]
      if armor != nil
        if armor.guard_state_set.include?(state_id)
          return true
        end
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃の属性取得
  #--------------------------------------------------------------------------
  def element_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.element_set : []
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃のステート変化 (+) 取得
  #--------------------------------------------------------------------------
  def plus_state_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.plus_state_set : []
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃のステート変化 (-) 取得
  #--------------------------------------------------------------------------
  def minus_state_set
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.minus_state_set : []
  end
  #--------------------------------------------------------------------------
  # ● MaxHP の取得
  #--------------------------------------------------------------------------
  def maxhp
    n = [[base_maxhp + @maxhp_plus, 1].max, 9999].min
    for i in @states
      n *= $data_states[i].maxhp_rate / 100.0
    end
    n = [[Integer(n), 1].max, 9999].min
    return n
  end
  #--------------------------------------------------------------------------
  # ● 基本 MaxHP の取得
  #--------------------------------------------------------------------------
  def base_maxhp
    return $data_actors[@actor_id].parameters[0, @level]
  end
  #--------------------------------------------------------------------------
  # ● 基本 MaxSP の取得
  #--------------------------------------------------------------------------
  def base_maxsp
    return $data_actors[@actor_id].parameters[1, @level]
  end
  #--------------------------------------------------------------------------
  # ● 基本腕力の取得
  #--------------------------------------------------------------------------
  def base_str
    n = $data_actors[@actor_id].parameters[2, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.str_plus : 0
    n += armor1 != nil ? armor1.str_plus : 0
    n += armor2 != nil ? armor2.str_plus : 0
    n += armor3 != nil ? armor3.str_plus : 0
    n += armor4 != nil ? armor4.str_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 基本器用さの取得
  #--------------------------------------------------------------------------
  def base_dex
    n = $data_actors[@actor_id].parameters[3, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.dex_plus : 0
    n += armor1 != nil ? armor1.dex_plus : 0
    n += armor2 != nil ? armor2.dex_plus : 0
    n += armor3 != nil ? armor3.dex_plus : 0
    n += armor4 != nil ? armor4.dex_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 基本素早さの取得
  #--------------------------------------------------------------------------
  def base_agi
    n = $data_actors[@actor_id].parameters[4, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.agi_plus : 0
    n += armor1 != nil ? armor1.agi_plus : 0
    n += armor2 != nil ? armor2.agi_plus : 0
    n += armor3 != nil ? armor3.agi_plus : 0
    n += armor4 != nil ? armor4.agi_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 基本魔力の取得
  #--------------------------------------------------------------------------
  def base_int
    n = $data_actors[@actor_id].parameters[5, @level]
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    n += weapon != nil ? weapon.int_plus : 0
    n += armor1 != nil ? armor1.int_plus : 0
    n += armor2 != nil ? armor2.int_plus : 0
    n += armor3 != nil ? armor3.int_plus : 0
    n += armor4 != nil ? armor4.int_plus : 0
    return [[n, 1].max, 999].min
  end
  #--------------------------------------------------------------------------
  # ● 基本攻撃力の取得
  #--------------------------------------------------------------------------
  def base_atk
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.atk : 0
  end
  #--------------------------------------------------------------------------
  # ● 基本物理防御の取得
  #--------------------------------------------------------------------------
  def base_pdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    pdef1 = weapon != nil ? weapon.pdef : 0
    pdef2 = armor1 != nil ? armor1.pdef : 0
    pdef3 = armor2 != nil ? armor2.pdef : 0
    pdef4 = armor3 != nil ? armor3.pdef : 0
    pdef5 = armor4 != nil ? armor4.pdef : 0
    return pdef1 + pdef2 + pdef3 + pdef4 + pdef5
  end
  #--------------------------------------------------------------------------
  # ● 基本魔法防御の取得
  #--------------------------------------------------------------------------
  def base_mdef
    weapon = $data_weapons[@weapon_id]
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    mdef1 = weapon != nil ? weapon.mdef : 0
    mdef2 = armor1 != nil ? armor1.mdef : 0
    mdef3 = armor2 != nil ? armor2.mdef : 0
    mdef4 = armor3 != nil ? armor3.mdef : 0
    mdef5 = armor4 != nil ? armor4.mdef : 0
    return mdef1 + mdef2 + mdef3 + mdef4 + mdef5
  end
  #--------------------------------------------------------------------------
  # ● 基本回避修正の取得
  #--------------------------------------------------------------------------
  def base_eva
    armor1 = $data_armors[@armor1_id]
    armor2 = $data_armors[@armor2_id]
    armor3 = $data_armors[@armor3_id]
    armor4 = $data_armors[@armor4_id]
    eva1 = armor1 != nil ? armor1.eva : 0
    eva2 = armor2 != nil ? armor2.eva : 0
    eva3 = armor3 != nil ? armor3.eva : 0
    eva4 = armor4 != nil ? armor4.eva : 0
    return eva1 + eva2 + eva3 + eva4
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃 攻撃側アニメーション ID の取得
  #--------------------------------------------------------------------------
  def animation1_id
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.animation1_id : 0
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃 対象側アニメーション ID の取得
  #--------------------------------------------------------------------------
  def animation2_id
    weapon = $data_weapons[@weapon_id]
    return weapon != nil ? weapon.animation2_id : 0
  end
  #--------------------------------------------------------------------------
  # ● クラス名の取得
  #--------------------------------------------------------------------------
  def class_name
    return $data_classes[@class_id].name
  end
  #--------------------------------------------------------------------------
  # ● EXP の文字列取得
  #--------------------------------------------------------------------------
  def exp_s
    return @exp_list[@level+1] > 0 ? @exp.to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # ● 次のレベルの EXP の文字列取得
  #--------------------------------------------------------------------------
  def next_exp_s
    return @exp_list[@level+1] > 0 ? @exp_list[@level+1].to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # ● 次のレベルまでの EXP の文字列取得
  #--------------------------------------------------------------------------
  def next_rest_exp_s
    return @exp_list[@level+1] > 0 ?
      (@exp_list[@level+1] - @exp).to_s : "-------"
  end
  #--------------------------------------------------------------------------
  # ● オートステートの更新
  #     old_armor : 外した防具
  #     new_armor : 装備した防具
  #--------------------------------------------------------------------------
  def update_auto_state(old_armor, new_armor)
    # 外した防具のオートステートを強制解除
    if old_armor != nil and old_armor.auto_state_id != 0
      remove_state(old_armor.auto_state_id, true)
    end
    # 装備した防具のオートステートを強制付加
    if new_armor != nil and new_armor.auto_state_id != 0
      add_state(new_armor.auto_state_id, true)
    end
  end
  #--------------------------------------------------------------------------
  # ● 装備固定判定
  #     equip_type : 装備タイプ
  #--------------------------------------------------------------------------
  def equip_fix?(equip_type)
    case equip_type
    when 0  # 武器
      return $data_actors[@actor_id].weapon_fix
    when 1  # 盾
      return $data_actors[@actor_id].armor1_fix
    when 2  # 頭
      return $data_actors[@actor_id].armor2_fix
    when 3  # 身体
      return $data_actors[@actor_id].armor3_fix
    when 4  # 装飾品
      return $data_actors[@actor_id].armor4_fix
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 装備の変更
  #     equip_type : 装備タイプ
  #     id    : 武器 or 防具 ID  (0 なら装備解除)
  #--------------------------------------------------------------------------
  def equip(equip_type, id)
    case equip_type
    when 0  # 武器
      if id == 0 or $game_party.weapon_number(id) > 0
        $game_party.gain_weapon(@weapon_id, 1)
        @weapon_id = id
        $game_party.lose_weapon(id, 1)
      end
    when 1  # 盾
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor1_id], $data_armors[id])
        $game_party.gain_armor(@armor1_id, 1)
        @armor1_id = id
        $game_party.lose_armor(id, 1)
      end
    when 2  # 頭
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor2_id], $data_armors[id])
        $game_party.gain_armor(@armor2_id, 1)
        @armor2_id = id
        $game_party.lose_armor(id, 1)
      end
    when 3  # 身体
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor3_id], $data_armors[id])
        $game_party.gain_armor(@armor3_id, 1)
        @armor3_id = id
        $game_party.lose_armor(id, 1)
      end
    when 4  # 装飾品
      if id == 0 or $game_party.armor_number(id) > 0
        update_auto_state($data_armors[@armor4_id], $data_armors[id])
        $game_party.gain_armor(@armor4_id, 1)
        @armor4_id = id
        $game_party.lose_armor(id, 1)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 装備可能判定
  #     item : アイテム
  #--------------------------------------------------------------------------
  def equippable?(item)
    # 武器の場合
    if item.is_a?(RPG::Weapon)
      # 現在のクラスの装備可能な武器に含まれている場合
      if $data_classes[@class_id].weapon_set.include?(item.id)
        return true
      end
    end
    # 防具の場合
    if item.is_a?(RPG::Armor)
      # 現在のクラスの装備可能な防具に含まれている場合
      if $data_classes[@class_id].armor_set.include?(item.id)
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● EXP の変更
  #     exp : 新しい EXP
  #--------------------------------------------------------------------------
  def exp=(exp)
    @exp = [[exp, 9999999].min, 0].max
    # レベルアップ
    while @exp >= @exp_list[@level+1] and @exp_list[@level+1] > 0
      @level += 1
      # スキル習得
      for j in $data_classes[@class_id].learnings
        if j.level == @level
          learn_skill(j.skill_id)
        end
      end
    end
    # レベルダウン
    while @exp < @exp_list[@level]
      @level -= 1
    end
    # 現在の HP と SP が最大値を超えていたら修正
    @hp = [@hp, self.maxhp].min
    @sp = [@sp, self.maxsp].min
  end
  #--------------------------------------------------------------------------
  # ● レベルの変更
  #     level : 新しいレベル
  #--------------------------------------------------------------------------
  def level=(level)
    # 上下限チェック
    level = [[level, $data_actors[@actor_id].final_level].min, 1].max
    # EXP を変更
    self.exp = @exp_list[level]
  end
  #--------------------------------------------------------------------------
  # ● スキルを覚える
  #     skill_id : スキル ID
  #--------------------------------------------------------------------------
  def learn_skill(skill_id)
    if skill_id > 0 and not skill_learn?(skill_id)
      @skills.push(skill_id)
      @skills.sort!
    end
  end
  #--------------------------------------------------------------------------
  # ● スキルを忘れる
  #     skill_id : スキル ID
  #--------------------------------------------------------------------------
  def forget_skill(skill_id)
    @skills.delete(skill_id)
  end
  #--------------------------------------------------------------------------
  # ● スキルの習得済み判定
  #     skill_id : スキル ID
  #--------------------------------------------------------------------------
  def skill_learn?(skill_id)
    return @skills.include?(skill_id)
  end
  #--------------------------------------------------------------------------
  # ● スキルの使用可能判定
  #     skill_id : スキル ID
  #--------------------------------------------------------------------------
  def skill_can_use?(skill_id)
    if not skill_learn?(skill_id)
      return false
    end
    return super
  end
  #--------------------------------------------------------------------------
  # ● 名前の変更
  #     name : 新しい名前
  #--------------------------------------------------------------------------
  def name=(name)
    @name = name
  end
  #--------------------------------------------------------------------------
  # ● クラス ID の変更
  #     class_id : 新しいクラス ID
  #--------------------------------------------------------------------------
  def class_id=(class_id)
    if $data_classes[class_id] != nil
      @class_id = class_id
      # 装備できなくなったアイテムを外す
      unless equippable?($data_weapons[@weapon_id])
        equip(0, 0)
      end
      unless equippable?($data_armors[@armor1_id])
        equip(1, 0)
      end
      unless equippable?($data_armors[@armor2_id])
        equip(2, 0)
      end
      unless equippable?($data_armors[@armor3_id])
        equip(3, 0)
      end
      unless equippable?($data_armors[@armor4_id])
        equip(4, 0)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● グラフィックの変更
  #     character_name : 新しいキャラクター ファイル名
  #     character_hue  : 新しいキャラクター 色相
  #     battler_name   : 新しいバトラー ファイル名
  #     battler_hue    : 新しいバトラー 色相
  #--------------------------------------------------------------------------
  def set_graphic(character_name, character_hue, battler_name, battler_hue)
    @character_name = character_name
    @character_hue = character_hue
    @battler_name = battler_name
    @battler_hue = battler_hue
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 X 座標の取得
  #--------------------------------------------------------------------------
  def screen_x
    # パーティ内の並び順から X 座標を計算して返す
    if self.index != nil
      return self.index * 160 + 80
    else
      return 0
    end
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 Y 座標の取得
  #--------------------------------------------------------------------------
  def screen_y
    return 464
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 Z 座標の取得
  #--------------------------------------------------------------------------
  def screen_z
    # パーティ内の並び順から Z 座標を計算して返す
    if self.index != nil
      return 4 - self.index
    else
      return 0
    end
  end
end

#==============================================================================
# ■ Game_Enemy
#------------------------------------------------------------------------------
# 　エネミーを扱うクラスです。このクラスは Game_Troop クラス ($game_troop) の
# 内部で使用されます。
#==============================================================================

class Game_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     troop_id     : トループ ID
  #     member_index : トループメンバーのインデックス
  #--------------------------------------------------------------------------
  def initialize(troop_id, member_index)
    super()
    @troop_id = troop_id
    @member_index = member_index
    troop = $data_troops[@troop_id]
    @enemy_id = troop.members[@member_index].enemy_id
    enemy = $data_enemies[@enemy_id]
    @battler_name = enemy.battler_name
    @battler_hue = enemy.battler_hue
    @hp = maxhp
    @sp = maxsp
    @hidden = troop.members[@member_index].hidden
    @immortal = troop.members[@member_index].immortal
  end
  #--------------------------------------------------------------------------
  # ● エネミー ID 取得
  #--------------------------------------------------------------------------
  def id
    return @enemy_id
  end
  #--------------------------------------------------------------------------
  # ● インデックス取得
  #--------------------------------------------------------------------------
  def index
    return @member_index
  end
  #--------------------------------------------------------------------------
  # ● 名前の取得
  #--------------------------------------------------------------------------
  def name
    return $data_enemies[@enemy_id].name
  end
  #--------------------------------------------------------------------------
  # ● 基本 MaxHP の取得
  #--------------------------------------------------------------------------
  def base_maxhp
    return $data_enemies[@enemy_id].maxhp
  end
  #--------------------------------------------------------------------------
  # ● 基本 MaxSP の取得
  #--------------------------------------------------------------------------
  def base_maxsp
    return $data_enemies[@enemy_id].maxsp
  end
  #--------------------------------------------------------------------------
  # ● 基本腕力の取得
  #--------------------------------------------------------------------------
  def base_str
    return $data_enemies[@enemy_id].str
  end
  #--------------------------------------------------------------------------
  # ● 基本器用さの取得
  #--------------------------------------------------------------------------
  def base_dex
    return $data_enemies[@enemy_id].dex
  end
  #--------------------------------------------------------------------------
  # ● 基本素早さの取得
  #--------------------------------------------------------------------------
  def base_agi
    return $data_enemies[@enemy_id].agi
  end
  #--------------------------------------------------------------------------
  # ● 基本魔力の取得
  #--------------------------------------------------------------------------
  def base_int
    return $data_enemies[@enemy_id].int
  end
  #--------------------------------------------------------------------------
  # ● 基本攻撃力の取得
  #--------------------------------------------------------------------------
  def base_atk
    return $data_enemies[@enemy_id].atk
  end
  #--------------------------------------------------------------------------
  # ● 基本物理防御の取得
  #--------------------------------------------------------------------------
  def base_pdef
    return $data_enemies[@enemy_id].pdef
  end
  #--------------------------------------------------------------------------
  # ● 基本魔法防御の取得
  #--------------------------------------------------------------------------
  def base_mdef
    return $data_enemies[@enemy_id].mdef
  end
  #--------------------------------------------------------------------------
  # ● 基本回避修正の取得
  #--------------------------------------------------------------------------
  def base_eva
    return $data_enemies[@enemy_id].eva
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃 攻撃側アニメーション ID の取得
  #--------------------------------------------------------------------------
  def animation1_id
    return $data_enemies[@enemy_id].animation1_id
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃 対象側アニメーション ID の取得
  #--------------------------------------------------------------------------
  def animation2_id
    return $data_enemies[@enemy_id].animation2_id
  end
  #--------------------------------------------------------------------------
  # ● 属性補正値の取得
  #     element_id : 属性 ID
  #--------------------------------------------------------------------------
  def element_rate(element_id)
    # 属性有効度に対応する数値を取得
    table = [0,200,150,100,50,0,-100]
    result = table[$data_enemies[@enemy_id].element_ranks[element_id]]
    # ステートでこの属性が防御されている場合は半減
    for i in @states
      if $data_states[i].guard_element_set.include?(element_id)
        result /= 2
      end
    end
    # メソッド終了
    return result
  end
  #--------------------------------------------------------------------------
  # ● ステート有効度の取得
  #--------------------------------------------------------------------------
  def state_ranks
    return $data_enemies[@enemy_id].state_ranks
  end
  #--------------------------------------------------------------------------
  # ● ステート防御判定
  #     state_id : ステート ID
  #--------------------------------------------------------------------------
  def state_guard?(state_id)
    return false
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃の属性取得
  #--------------------------------------------------------------------------
  def element_set
    return []
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃のステート変化 (+) 取得
  #--------------------------------------------------------------------------
  def plus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # ● 通常攻撃のステート変化 (-) 取得
  #--------------------------------------------------------------------------
  def minus_state_set
    return []
  end
  #--------------------------------------------------------------------------
  # ● アクションの取得
  #--------------------------------------------------------------------------
  def actions
    return $data_enemies[@enemy_id].actions
  end
  #--------------------------------------------------------------------------
  # ● EXP の取得
  #--------------------------------------------------------------------------
  def exp
    return $data_enemies[@enemy_id].exp
  end
  #--------------------------------------------------------------------------
  # ● ゴールドの取得
  #--------------------------------------------------------------------------
  def gold
    return $data_enemies[@enemy_id].gold
  end
  #--------------------------------------------------------------------------
  # ● アイテム ID の取得
  #--------------------------------------------------------------------------
  def item_id
    return $data_enemies[@enemy_id].item_id
  end
  #--------------------------------------------------------------------------
  # ● 武器 ID の取得
  #--------------------------------------------------------------------------
  def weapon_id
    return $data_enemies[@enemy_id].weapon_id
  end
  #--------------------------------------------------------------------------
  # ● 防具 ID の取得
  #--------------------------------------------------------------------------
  def armor_id
    return $data_enemies[@enemy_id].armor_id
  end
  #--------------------------------------------------------------------------
  # ● トレジャー出現率の取得
  #--------------------------------------------------------------------------
  def treasure_prob
    return $data_enemies[@enemy_id].treasure_prob
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 X 座標の取得
  #--------------------------------------------------------------------------
  def screen_x
    return $data_troops[@troop_id].members[@member_index].x
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 Y 座標の取得
  #--------------------------------------------------------------------------
  def screen_y
    return $data_troops[@troop_id].members[@member_index].y
  end
  #--------------------------------------------------------------------------
  # ● バトル画面 Z 座標の取得
  #--------------------------------------------------------------------------
  def screen_z
    return screen_y
  end
  #--------------------------------------------------------------------------
  # ● 逃げる
  #--------------------------------------------------------------------------
  def escape
    # ヒドゥンフラグをセット
    @hidden = true
    # カレントアクションをクリア
    self.current_action.clear
  end
  #--------------------------------------------------------------------------
  # ● 変身
  #     enemy_id : 変身先のエネミー ID
  #--------------------------------------------------------------------------
  def transform(enemy_id)
    # エネミー ID を変更
    @enemy_id = enemy_id
    # バトラー グラフィックを変更
    @battler_name = $data_enemies[@enemy_id].battler_name
    @battler_hue = $data_enemies[@enemy_id].battler_hue
    # アクション再作成
    make_action
  end
  #--------------------------------------------------------------------------
  # ● アクション作成
  #--------------------------------------------------------------------------
  def make_action
    # カレントアクションをクリア
    self.current_action.clear
    # 動けない場合
    unless self.movable?
      # メソッド終了
      return
    end
    # 現在有効なアクションを抽出
    available_actions = []
    rating_max = 0
    for action in self.actions
      # ターン 条件確認
      n = $game_temp.battle_turn
      a = action.condition_turn_a
      b = action.condition_turn_b
      if (b == 0 and n != a) or
         (b > 0 and (n < 1 or n < a or n % b != a % b))
        next
      end
      # HP 条件確認
      if self.hp * 100.0 / self.maxhp > action.condition_hp
        next
      end
      # レベル 条件確認
      if $game_party.max_level < action.condition_level
        next
      end
      # スイッチ 条件確認
      switch_id = action.condition_switch_id
      if switch_id > 0 and $game_switches[switch_id] == false
        next
      end
      # 条件に該当 : このアクションを追加
      available_actions.push(action)
      if action.rating > rating_max
        rating_max = action.rating
      end
    end
    # 最大のレーティング値を 3 として合計を計算 (0 以下は除外)
    ratings_total = 0
    for action in available_actions
      if action.rating > rating_max - 3
        ratings_total += action.rating - (rating_max - 3)
      end
    end
    # レーティングの合計が 0 ではない場合
    if ratings_total > 0
      # 乱数を作成
      value = rand(ratings_total)
      # 作成した乱数に対応するものをカレントアクションに設定
      for action in available_actions
        if action.rating > rating_max - 3
          if value < action.rating - (rating_max - 3)
            self.current_action.kind = action.kind
            self.current_action.basic = action.basic
            self.current_action.skill_id = action.skill_id
            self.current_action.decide_random_target_for_enemy
            return
          else
            value -= action.rating - (rating_max - 3)
          end
        end
      end
    end
  end
end

#==============================================================================
# ■ Game_Actors
#------------------------------------------------------------------------------
# 　アクターの配列を扱うクラスです。このクラスのインスタンスは $game_actors で
# 参照されます。
#==============================================================================

class Game_Actors
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @data = []
  end
  #--------------------------------------------------------------------------
  # ● アクターの取得
  #     actor_id : アクター ID
  #--------------------------------------------------------------------------
  def [](actor_id)
    if actor_id > 999 or $data_actors[actor_id] == nil
      return nil
    end
    if @data[actor_id] == nil
      @data[actor_id] = Game_Actor.new(actor_id)
    end
    return @data[actor_id]
  end
end

#==============================================================================
# ■ Game_Party
#------------------------------------------------------------------------------
# 　パーティを扱うクラスです。ゴールドやアイテムなどの情報が含まれます。このク
# ラスのインスタンスは $game_party で参照されます。
#==============================================================================

class Game_Party
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :actors                   # アクター
  attr_reader   :gold                     # ゴールド
  attr_reader   :steps                    # 歩数
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    # アクターの配列を作成
    @actors = []
    # ゴールドと歩数を初期化
    @gold = 0
    @steps = 0
    # アイテム、武器、防具の所持数ハッシュを作成
    @items = {}
    @weapons = {}
    @armors = {}
  end
  #--------------------------------------------------------------------------
  # ● 初期パーティのセットアップ
  #--------------------------------------------------------------------------
  def setup_starting_members
    @actors = []
    for i in $data_system.party_members
      @actors.push($game_actors[i])
    end
  end
  #--------------------------------------------------------------------------
  # ● 戦闘テスト用パーティのセットアップ
  #--------------------------------------------------------------------------
  def setup_battle_test_members
    @actors = []
    for battler in $data_system.test_battlers
      actor = $game_actors[battler.actor_id]
      actor.level = battler.level
      gain_weapon(battler.weapon_id, 1)
      gain_armor(battler.armor1_id, 1)
      gain_armor(battler.armor2_id, 1)
      gain_armor(battler.armor3_id, 1)
      gain_armor(battler.armor4_id, 1)
      actor.equip(0, battler.weapon_id)
      actor.equip(1, battler.armor1_id)
      actor.equip(2, battler.armor2_id)
      actor.equip(3, battler.armor3_id)
      actor.equip(4, battler.armor4_id)
      actor.recover_all
      @actors.push(actor)
    end
    @items = {}
    for i in 1...$data_items.size
      if $data_items[i].name != ""
        occasion = $data_items[i].occasion
        if occasion == 0 or occasion == 1
          @items[i] = 99
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● パーティメンバーのリフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # ゲームデータをロードした直後はアクターオブジェクトが
    # $game_actors から分離してしまっている。
    # ロードのたびにアクターを再設定することで問題を回避する。
    new_actors = []
    for i in 0...@actors.size
      if $data_actors[@actors[i].id] != nil
        new_actors.push($game_actors[@actors[i].id])
      end
    end
    @actors = new_actors
  end
  #--------------------------------------------------------------------------
  # ● 最大レベルの取得
  #--------------------------------------------------------------------------
  def max_level
    # パーティ人数が 0 人の場合
    if @actors.size == 0
      return 0
    end
    # ローカル変数 level を初期化
    level = 0
    # パーティメンバーの最大レベルを求める
    for actor in @actors
      if level < actor.level
        level = actor.level
      end
    end
    return level
  end
  #--------------------------------------------------------------------------
  # ● アクターを加える
  #     actor_id : アクター ID
  #--------------------------------------------------------------------------
  def add_actor(actor_id)
    # アクターを取得
    actor = $game_actors[actor_id]
    # パーティ人数が 4 人未満で、このアクターがパーティにいない場合
    if @actors.size < 4 and not @actors.include?(actor)
      # アクターを追加
      @actors.push(actor)
      # プレイヤーをリフレッシュ
      $game_player.refresh
    end
  end
  #--------------------------------------------------------------------------
  # ● アクターを外す
  #     actor_id : アクター ID
  #--------------------------------------------------------------------------
  def remove_actor(actor_id)
    # アクターを削除
    @actors.delete($game_actors[actor_id])
    # プレイヤーをリフレッシュ
    $game_player.refresh
  end
  #--------------------------------------------------------------------------
  # ● ゴールドの増加 (減少)
  #     n : 金額
  #--------------------------------------------------------------------------
  def gain_gold(n)
    @gold = [[@gold + n, 0].max, 9999999].min
  end
  #--------------------------------------------------------------------------
  # ● ゴールドの減少
  #     n : 金額
  #--------------------------------------------------------------------------
  def lose_gold(n)
    # 数値を逆転して gain_gold を呼ぶ
    gain_gold(-n)
  end
  #--------------------------------------------------------------------------
  # ● 歩数増加
  #--------------------------------------------------------------------------
  def increase_steps
    @steps = [@steps + 1, 9999999].min
  end
  #--------------------------------------------------------------------------
  # ● アイテムの所持数取得
  #     item_id : アイテム ID
  #--------------------------------------------------------------------------
  def item_number(item_id)
    # ハッシュに個数データがあればその数値を、なければ 0 を返す
    return @items.include?(item_id) ? @items[item_id] : 0
  end
  #--------------------------------------------------------------------------
  # ● 武器の所持数取得
  #     weapon_id : 武器 ID
  #--------------------------------------------------------------------------
  def weapon_number(weapon_id)
    # ハッシュに個数データがあればその数値を、なければ 0 を返す
    return @weapons.include?(weapon_id) ? @weapons[weapon_id] : 0
  end
  #--------------------------------------------------------------------------
  # ● 防具の所持数取得
  #     armor_id : 防具 ID
  #--------------------------------------------------------------------------
  def armor_number(armor_id)
    # ハッシュに個数データがあればその数値を、なければ 0 を返す
    return @armors.include?(armor_id) ? @armors[armor_id] : 0
  end
  #--------------------------------------------------------------------------
  # ● アイテムの増加 (減少)
  #     item_id : アイテム ID
  #     n       : 個数
  #--------------------------------------------------------------------------
  def gain_item(item_id, n)
    # ハッシュの個数データを更新
    if item_id > 0
      @items[item_id] = [[item_number(item_id) + n, 0].max, 99].min
    end
  end
  #--------------------------------------------------------------------------
  # ● 武器の増加 (減少)
  #     weapon_id : 武器 ID
  #     n         : 個数
  #--------------------------------------------------------------------------
  def gain_weapon(weapon_id, n)
    # ハッシュの個数データを更新
    if weapon_id > 0
      @weapons[weapon_id] = [[weapon_number(weapon_id) + n, 0].max, 99].min
    end
  end
  #--------------------------------------------------------------------------
  # ● 防具の増加 (減少)
  #     armor_id : 防具 ID
  #     n        : 個数
  #--------------------------------------------------------------------------
  def gain_armor(armor_id, n)
    # ハッシュの個数データを更新
    if armor_id > 0
      @armors[armor_id] = [[armor_number(armor_id) + n, 0].max, 99].min
    end
  end
  #--------------------------------------------------------------------------
  # ● アイテムの減少
  #     item_id : アイテム ID
  #     n       : 個数
  #--------------------------------------------------------------------------
  def lose_item(item_id, n)
    # 数値を逆転して gain_item を呼ぶ
    gain_item(item_id, -n)
  end
  #--------------------------------------------------------------------------
  # ● 武器の減少
  #     weapon_id : 武器 ID
  #     n         : 個数
  #--------------------------------------------------------------------------
  def lose_weapon(weapon_id, n)
    # 数値を逆転して gain_weapon を呼ぶ
    gain_weapon(weapon_id, -n)
  end
  #--------------------------------------------------------------------------
  # ● 防具の減少
  #     armor_id : 防具 ID
  #     n        : 個数
  #--------------------------------------------------------------------------
  def lose_armor(armor_id, n)
    # 数値を逆転して gain_armor を呼ぶ
    gain_armor(armor_id, -n)
  end
  #--------------------------------------------------------------------------
  # ● アイテムの使用可能判定
  #     item_id : アイテム ID
  #--------------------------------------------------------------------------
  def item_can_use?(item_id)
    # アイテムの個数が 0 個の場合
    if item_number(item_id) == 0
      # 使用不能
      return false
    end
    # 使用可能時を取得
    occasion = $data_items[item_id].occasion
    # バトルの場合
    if $game_temp.in_battle
      # 使用可能時が 0 (常時) または 1 (バトルのみ) なら使用可能
      return (occasion == 0 or occasion == 1)
    end
    # 使用可能時が 0 (常時) または 2 (メニューのみ) なら使用可能
    return (occasion == 0 or occasion == 2)
  end
  #--------------------------------------------------------------------------
  # ● 全員のアクションクリア
  #--------------------------------------------------------------------------
  def clear_actions
    # パーティ全員のアクションをクリア
    for actor in @actors
      actor.current_action.clear
    end
  end
  #--------------------------------------------------------------------------
  # ● コマンド入力可能判定
  #--------------------------------------------------------------------------
  def inputable?
    # 一人でもコマンド入力可能なら true を返す
    for actor in @actors
      if actor.inputable?
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 全滅判定
  #--------------------------------------------------------------------------
  def all_dead?
    # パーティ人数が 0 人の場合
    if $game_party.actors.size == 0
      return false
    end
    # HP 0 以上のアクターがパーティにいる場合
    for actor in @actors
      if actor.hp > 0
        return false
      end
    end
    # 全滅
    return true
  end
  #--------------------------------------------------------------------------
  # ● スリップダメージチェック (マップ用)
  #--------------------------------------------------------------------------
  def check_map_slip_damage
    for actor in @actors
      if actor.hp > 0 and actor.slip_damage?
        actor.hp -= [actor.maxhp / 100, 1].max
        if actor.hp == 0
          $game_system.se_play($data_system.actor_collapse_se)
        end
        $game_screen.start_flash(Color.new(255,0,0,128), 4)
        $game_temp.gameover = $game_party.all_dead?
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 対象アクターのランダムな決定
  #     hp0 : HP 0 のアクターに限る
  #--------------------------------------------------------------------------
  def random_target_actor(hp0 = false)
    # ルーレットを初期化
    roulette = []
    # ループ
    for actor in @actors
      # 条件に該当する場合
      if (not hp0 and actor.exist?) or (hp0 and actor.hp0?)
        # アクターのクラスの [位置] を取得
        position = $data_classes[actor.class_id].position
        # 前衛のとき n = 4、中衛のとき n = 3、後衛のとき n = 2
        n = 4 - position
        # ルーレットにアクターを n 回追加
        n.times do
          roulette.push(actor)
        end
      end
    end
    # ルーレットのサイズが 0 の場合
    if roulette.size == 0
      return nil
    end
    # ルーレットを回し、アクターを決定
    return roulette[rand(roulette.size)]
  end
  #--------------------------------------------------------------------------
  # ● 対象アクターのランダムな決定 (HP 0)
  #--------------------------------------------------------------------------
  def random_target_actor_hp0
    return random_target_actor(true)
  end
  #--------------------------------------------------------------------------
  # ● 対象アクターのスムーズな決定
  #     actor_index : アクターインデックス
  #--------------------------------------------------------------------------
  def smooth_target_actor(actor_index)
    # アクターを取得
    actor = @actors[actor_index]
    # アクターが存在する場合
    if actor != nil and actor.exist?
      return actor
    end
    # ループ
    for actor in @actors
      # アクターが存在する場合
      if actor.exist?
        return actor
      end
    end
  end
end

#==============================================================================
# ■ Game_Troop
#------------------------------------------------------------------------------
# 　トループを扱うクラスです。このクラスのインスタンスは $game_troop で参照さ
# れます。
#==============================================================================

class Game_Troop
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    # エネミーの配列を作成
    @enemies = []
  end
  #--------------------------------------------------------------------------
  # ● エネミーの取得
  #--------------------------------------------------------------------------
  def enemies
    return @enemies
  end
  #--------------------------------------------------------------------------
  # ● セットアップ
  #     troop_id : トループ ID
  #--------------------------------------------------------------------------
  def setup(troop_id)
    # トループに設定されているエネミーを配列に設定
    @enemies = []
    troop = $data_troops[troop_id]
    for i in 0...troop.members.size
      enemy = $data_enemies[troop.members[i].enemy_id]
      if enemy != nil
        @enemies.push(Game_Enemy.new(troop_id, i))
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 対象エネミーのランダムな決定
  #     hp0 : HP 0 のエネミーに限る
  #--------------------------------------------------------------------------
  def random_target_enemy(hp0 = false)
    # ルーレットを初期化
    roulette = []
    # ループ
    for enemy in @enemies
      # 条件に該当する場合
      if (not hp0 and enemy.exist?) or (hp0 and enemy.hp0?)
        # ルーレットにエネミーを追加
        roulette.push(enemy)
      end
    end
    # ルーレットのサイズが 0 の場合
    if roulette.size == 0
      return nil
    end
    # ルーレットを回し、エネミーを決定
    return roulette[rand(roulette.size)]
  end
  #--------------------------------------------------------------------------
  # ● 対象エネミーのランダムな決定 (HP 0)
  #--------------------------------------------------------------------------
  def random_target_enemy_hp0
    return random_target_enemy(true)
  end
  #--------------------------------------------------------------------------
  # ● 対象エネミーのスムーズな決定
  #     enemy_index : エネミーインデックス
  #--------------------------------------------------------------------------
  def smooth_target_enemy(enemy_index)
    # エネミーを取得
    enemy = @enemies[enemy_index]
    # エネミーが存在する場合
    if enemy != nil and enemy.exist?
      return enemy
    end
    # ループ
    for enemy in @enemies
      # エネミーが存在する場合
      if enemy.exist?
        return enemy
      end
    end
  end
end

#==============================================================================
# ■ Game_Map
#------------------------------------------------------------------------------
# 　マップを扱うクラスです。スクロールや通行可能判定などの機能を持っています。
# このクラスのインスタンスは $game_map で参照されます。
#==============================================================================

class Game_Map
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :tileset_name             # タイルセット ファイル名
  attr_accessor :autotile_names           # オートタイル ファイル名
  attr_accessor :panorama_name            # パノラマ ファイル名
  attr_accessor :panorama_hue             # パノラマ 色相
  attr_accessor :fog_name                 # フォグ ファイル名
  attr_accessor :fog_hue                  # フォグ 色相
  attr_accessor :fog_opacity              # フォグ 不透明度
  attr_accessor :fog_blend_type           # フォグ ブレンド方法
  attr_accessor :fog_zoom                 # フォグ 拡大率
  attr_accessor :fog_sx                   # フォグ SX
  attr_accessor :fog_sy                   # フォグ SY
  attr_accessor :battleback_name          # バトルバック ファイル名
  attr_accessor :display_x                # 表示 X 座標 * 128
  attr_accessor :display_y                # 表示 Y 座標 * 128
  attr_accessor :need_refresh             # リフレッシュ要求フラグ
  attr_reader   :passages                 # 通行 テーブル
  attr_reader   :priorities               # プライオリティ テーブル
  attr_reader   :terrain_tags             # 地形タグ テーブル
  attr_reader   :events                   # イベント
  attr_reader   :fog_ox                   # フォグ 原点 X 座標
  attr_reader   :fog_oy                   # フォグ 原点 Y 座標
  attr_reader   :fog_tone                 # フォグ 色調
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @map_id = 0
    @display_x = 0
    @display_y = 0
  end
  #--------------------------------------------------------------------------
  # ● セットアップ
  #     map_id : マップ ID
  #--------------------------------------------------------------------------
  def setup(map_id)
    # マップ ID を @map_id に記憶
    @map_id = map_id
    # マップをファイルからロードし、@map に設定
    if RUBY_ENGINE == "opal"
      @map = load_data(sprintf("rgss/converted/Map%03d.json", @map_id))
    else
      if RGSS_ENABLE_MARSHAL
        @map = load_data(sprintf("Data/Map%03d.rxdata", @map_id))
      else
        @map = load_data(sprintf("rgss/converted/Map%03d.json", @map_id))
      end
    end
    # 公開インスタンス変数にタイルセットの情報を設定
    tileset = $data_tilesets[@map.tileset_id]
    @tileset_name = tileset.tileset_name
    @autotile_names = tileset.autotile_names
    @panorama_name = tileset.panorama_name
    @panorama_hue = tileset.panorama_hue
    @fog_name = tileset.fog_name
    @fog_hue = tileset.fog_hue
    @fog_opacity = tileset.fog_opacity
    @fog_blend_type = tileset.fog_blend_type
    @fog_zoom = tileset.fog_zoom
    @fog_sx = tileset.fog_sx
    @fog_sy = tileset.fog_sy
    @battleback_name = tileset.battleback_name
    @passages = tileset.passages
    @priorities = tileset.priorities
    @terrain_tags = tileset.terrain_tags
    # 表示座標を初期化
    @display_x = 0
    @display_y = 0
    # リフレッシュ要求フラグをクリア
    @need_refresh = false
    # マップイベントのデータを設定
    @events = {}
    for i in @map.events.keys
      @events[i] = Game_Event.new(@map_id, @map.events[i])
    end
    # コモンイベントのデータを設定
    @common_events = {}
    for i in 1...$data_common_events.size
      @common_events[i] = Game_CommonEvent.new(i)
    end
    # フォグの各情報を初期化
    @fog_ox = 0
    @fog_oy = 0
    @fog_tone = Tone.new(0, 0, 0, 0)
    @fog_tone_target = Tone.new(0, 0, 0, 0)
    @fog_tone_duration = 0
    @fog_opacity_duration = 0
    @fog_opacity_target = 0
    # スクロール情報を初期化
    @scroll_direction = 2
    @scroll_rest = 0
    @scroll_speed = 4
  end
  #--------------------------------------------------------------------------
  # ● マップ ID の取得
  #--------------------------------------------------------------------------
  def map_id
    return @map_id
  end
  #--------------------------------------------------------------------------
  # ● 幅の取得
  #--------------------------------------------------------------------------
  def width
    return @map.width
  end
  #--------------------------------------------------------------------------
  # ● 高さの取得
  #--------------------------------------------------------------------------
  def height
    return @map.height
  end
  #--------------------------------------------------------------------------
  # ● エンカウントリストの取得
  #--------------------------------------------------------------------------
  def encounter_list
    return @map.encounter_list
  end
  #--------------------------------------------------------------------------
  # ● エンカウント歩数の取得
  #--------------------------------------------------------------------------
  def encounter_step
    return @map.encounter_step
  end
  #--------------------------------------------------------------------------
  # ● マップデータの取得
  #--------------------------------------------------------------------------
  def data
    return @map.data
  end
  #--------------------------------------------------------------------------
  # ● BGM / BGS 自動切り替え
  #--------------------------------------------------------------------------
  def autoplay
    if @map.autoplay_bgm
      $game_system.bgm_play(@map.bgm)
    end
    if @map.autoplay_bgs
      $game_system.bgs_play(@map.bgs)
    end
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # マップ ID が有効なら
    if @map_id > 0
      # すべてのマップイベントをリフレッシュ
      for event in @events.values
        event.refresh
      end
      # すべてのコモンイベントをリフレッシュ
      for common_event in @common_events.values
        common_event.refresh
      end
    end
    # リフレッシュ要求フラグをクリア
    @need_refresh = false
  end
  #--------------------------------------------------------------------------
  # ● 下にスクロール
  #     distance : スクロールする距離
  #--------------------------------------------------------------------------
  def scroll_down(distance)
    @display_y = [@display_y + distance, (self.height - 15) * 128].min
  end
  #--------------------------------------------------------------------------
  # ● 左にスクロール
  #     distance : スクロールする距離
  #--------------------------------------------------------------------------
  def scroll_left(distance)
    @display_x = [@display_x - distance, 0].max
  end
  #--------------------------------------------------------------------------
  # ● 右にスクロール
  #     distance : スクロールする距離
  #--------------------------------------------------------------------------
  def scroll_right(distance)
    @display_x = [@display_x + distance, (self.width - 20) * 128].min
  end
  #--------------------------------------------------------------------------
  # ● 上にスクロール
  #     distance : スクロールする距離
  #--------------------------------------------------------------------------
  def scroll_up(distance)
    @display_y = [@display_y - distance, 0].max
  end
  #--------------------------------------------------------------------------
  # ● 有効座標判定
  #     x          : X 座標
  #     y          : Y 座標
  #--------------------------------------------------------------------------
  def valid?(x, y)
    return (x >= 0 and x < width and y >= 0 and y < height)
  end
  #--------------------------------------------------------------------------
  # ● 通行可能判定
  #     x          : X 座標
  #     y          : Y 座標
  #     d          : 方向 (0,2,4,6,8,10)
  #                  ※ 0,10 = 全方向通行不可の場合を判定 (ジャンプなど)
  #     self_event : 自分 (イベントが通行判定をする場合)
  #--------------------------------------------------------------------------
  def passable?(x, y, d, self_event = nil)
    # 与えられた座標がマップ外の場合
    unless valid?(x, y)
      # 通行不可
      return false
    end
    # 方向 (0,2,4,6,8,10) から 障害物ビット (0,1,2,4,8,0) に変換
    bit = (1 << (d / 2 - 1)) & 0x0f
    # すべてのイベントでループ
    for event in events.values
      # 自分以外のタイルと座標が一致した場合
      if event.tile_id >= 0 and event != self_event and
         event.x == x and event.y == y and not event.through
        # 障害物ビットがセットされている場合
        if @passages[event.tile_id] & bit != 0
          # 通行不可
          return false
        # 全方向の障害物ビットがセットされている場合
        elsif @passages[event.tile_id] & 0x0f == 0x0f
          # 通行不可
          return false
        # それ以外で プライオリティが 0 の場合
        elsif @priorities[event.tile_id] == 0
          # 通行可
          return true
        end
      end
    end
    # レイヤーの上から順に調べるループ
    for i in [2, 1, 0]
      # タイル ID を取得
      tile_id = data[x, y, i]
      # タイル ID 取得失敗
      if tile_id == nil
        # 通行不可
        return false
      # 障害物ビットがセットされている場合
      elsif @passages[tile_id] & bit != 0
        # 通行不可
        return false
      # 全方向の障害物ビットがセットされている場合
      elsif @passages[tile_id] & 0x0f == 0x0f
        # 通行不可
        return false
      # それ以外で プライオリティが 0 の場合
      elsif @priorities[tile_id] == 0
        # 通行可
        return true
      end
    end
    # 通行可
    return true
  end
  #--------------------------------------------------------------------------
  # ● 茂み判定
  #     x          : X 座標
  #     y          : Y 座標
  #--------------------------------------------------------------------------
  def bush?(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return false
        elsif @passages[tile_id] & 0x40 == 0x40
          return true
        end
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● カウンター判定
  #     x          : X 座標
  #     y          : Y 座標
  #--------------------------------------------------------------------------
  def counter?(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return false
        elsif @passages[tile_id] & 0x80 == 0x80
          return true
        end
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● 地形タグの取得
  #     x          : X 座標
  #     y          : Y 座標
  #--------------------------------------------------------------------------
  def terrain_tag(x, y)
    if @map_id != 0
      for i in [2, 1, 0]
        tile_id = data[x, y, i]
        if tile_id == nil
          return 0
        elsif @terrain_tags[tile_id] > 0
          return @terrain_tags[tile_id]
        end
      end
    end
    return 0
  end
  #--------------------------------------------------------------------------
  # ● 指定位置のイベント ID 取得
  #     x          : X 座標
  #     y          : Y 座標
  #--------------------------------------------------------------------------
  def check_event(x, y)
    for event in $game_map.events.values
      if event.x == x and event.y == y
        return event.id
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● スクロールの開始
  #     direction : スクロールする方向
  #     distance  : スクロールする距離
  #     speed     : スクロールする速度
  #--------------------------------------------------------------------------
  def start_scroll(direction, distance, speed)
    @scroll_direction = direction
    @scroll_rest = distance * 128
    @scroll_speed = speed
  end
  #--------------------------------------------------------------------------
  # ● スクロール中判定
  #--------------------------------------------------------------------------
  def scrolling?
    return @scroll_rest > 0
  end
  #--------------------------------------------------------------------------
  # ● フォグの色調変更の開始
  #     tone     : 色調
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_fog_tone_change(tone, duration)
    @fog_tone_target = tone.clone
    @fog_tone_duration = duration
    if @fog_tone_duration == 0
      @fog_tone = @fog_tone_target.clone
    end
  end
  #--------------------------------------------------------------------------
  # ● フォグの不透明度変更の開始
  #     opacity  : 不透明度
  #     duration : 時間
  #--------------------------------------------------------------------------
  def start_fog_opacity_change(opacity, duration)
    @fog_opacity_target = opacity * 1.0
    @fog_opacity_duration = duration
    if @fog_opacity_duration == 0
      @fog_opacity = @fog_opacity_target
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # 必要ならマップをリフレッシュ
    if $game_map.need_refresh
      refresh
    end
    # スクロール中の場合
    if @scroll_rest > 0
      # スクロール速度からマップ座標系での距離に変換
      distance = 2 ** @scroll_speed
      # スクロールを実行
      case @scroll_direction
      when 2  # 下
        scroll_down(distance)
      when 4  # 左
        scroll_left(distance)
      when 6  # 右
        scroll_right(distance)
      when 8  # 上
        scroll_up(distance)
      end
      # スクロールした距離を減算
      @scroll_rest -= distance
    end
    # マップイベントを更新
    for event in @events.values
      event.update
    end
    # コモンイベントを更新
    for common_event in @common_events.values
      common_event.update
    end
    # フォグのスクロール処理
    @fog_ox -= @fog_sx / 8.0
    @fog_oy -= @fog_sy / 8.0
    # フォグの色調変更処理
    if @fog_tone_duration >= 1
      d = @fog_tone_duration
      target = @fog_tone_target
      @fog_tone.red = (@fog_tone.red * (d - 1) + target.red) / d
      @fog_tone.green = (@fog_tone.green * (d - 1) + target.green) / d
      @fog_tone.blue = (@fog_tone.blue * (d - 1) + target.blue) / d
      @fog_tone.gray = (@fog_tone.gray * (d - 1) + target.gray) / d
      @fog_tone_duration -= 1
    end
    # フォグの不透明度変更処理
    if @fog_opacity_duration >= 1
      d = @fog_opacity_duration
      @fog_opacity = (@fog_opacity * (d - 1) + @fog_opacity_target) / d
      @fog_opacity_duration -= 1
    end
  end
end

#==============================================================================
# ■ Game_CommonEvent
#------------------------------------------------------------------------------
# 　コモンイベントを扱うクラスです。並列処理イベントを実行する機能を持っていま
# す。このクラスは Game_Map クラス ($game_map) の内部で使用されます。
#==============================================================================

class Game_CommonEvent
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     common_event_id : コモンイベント ID
  #--------------------------------------------------------------------------
  def initialize(common_event_id)
    @common_event_id = common_event_id
    @interpreter = nil
    refresh
  end
  #--------------------------------------------------------------------------
  # ● 名前の取得
  #--------------------------------------------------------------------------
  def name
    return $data_common_events[@common_event_id].name
  end
  #--------------------------------------------------------------------------
  # ● トリガーの取得
  #--------------------------------------------------------------------------
  def trigger
    return $data_common_events[@common_event_id].trigger
  end
  #--------------------------------------------------------------------------
  # ● 条件スイッチ ID の取得
  #--------------------------------------------------------------------------
  def switch_id
    return $data_common_events[@common_event_id].switch_id
  end
  #--------------------------------------------------------------------------
  # ● 実行内容の取得
  #--------------------------------------------------------------------------
  def list
    return $data_common_events[@common_event_id].list
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # 必要なら並列処理用インタプリタを作成
    if self.trigger == 2 and $game_switches[self.switch_id] == true
      if @interpreter == nil
        @interpreter = Interpreter.new
      end
    else
      @interpreter = nil
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # 並列処理が有効の場合
    if @interpreter != nil
      # 実行中でなければセットアップ
      unless @interpreter.running?
        @interpreter.setup(self.list, 0)
      end
      # インタプリタを更新
      @interpreter.update
    end
  end
end

#==============================================================================
# ■ Game_Character (分割定義 1)
#------------------------------------------------------------------------------
# 　キャラクターを扱うクラスです。このクラスは Game_Player クラスと Game_Event
# クラスのスーパークラスとして使用されます。
#==============================================================================

class Game_Character
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :id                       # ID
  attr_reader   :x                        # マップ X 座標 (論理座標)
  attr_reader   :y                        # マップ Y 座標 (論理座標)
  attr_reader   :real_x                   # マップ X 座標 (実座標 * 128)
  attr_reader   :real_y                   # マップ Y 座標 (実座標 * 128)
  attr_reader   :tile_id                  # タイル ID  (0 なら無効)
  attr_reader   :character_name           # キャラクター ファイル名
  attr_reader   :character_hue            # キャラクター 色相
  attr_reader   :opacity                  # 不透明度
  attr_reader   :blend_type               # 合成方法
  attr_reader   :direction                # 向き
  attr_reader   :pattern                  # パターン
  attr_reader   :move_route_forcing       # 移動ルート強制フラグ
  attr_reader   :through                  # すり抜け
  attr_accessor :animation_id             # アニメーション ID
  attr_accessor :transparent              # 透明状態
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    @id = 0
    @x = 0
    @y = 0
    @real_x = 0
    @real_y = 0
    @tile_id = 0
    @character_name = ""
    @character_hue = 0
    @opacity = 255
    @blend_type = 0
    @direction = 2
    @pattern = 0
    @move_route_forcing = false
    @through = false
    @animation_id = 0
    @transparent = false
    @original_direction = 2
    @original_pattern = 0
    @move_type = 0
    @move_speed = 4
    @move_frequency = 6
    @move_route = nil
    @move_route_index = 0
    @original_move_route = nil
    @original_move_route_index = 0
    @walk_anime = true
    @step_anime = false
    @direction_fix = false
    @always_on_top = false
    @anime_count = 0
    @stop_count = 0
    @jump_count = 0
    @jump_peak = 0
    @wait_count = 0
    @locked = false
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # ● 移動中判定
  #--------------------------------------------------------------------------
  def moving?
    # 論理座標と実座標が違っていれば移動中
    return (@real_x != @x * 128 or @real_y != @y * 128)
  end
  #--------------------------------------------------------------------------
  # ● ジャンプ中判定
  #--------------------------------------------------------------------------
  def jumping?
    # ジャンプカウントが 0 より大きければジャンプ中
    return @jump_count > 0
  end
  #--------------------------------------------------------------------------
  # ● 姿勢の矯正
  #--------------------------------------------------------------------------
  def straighten
    # 移動時アニメまたは停止時アニメが ON の場合
    if @walk_anime or @step_anime
      # パターンを 0 に設定
      @pattern = 0
    end
    # アニメカウントをクリア
    @anime_count = 0
    # ロック前の向きをクリア
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # ● 移動ルートの強制
  #     move_route : 新しい移動ルート
  #--------------------------------------------------------------------------
  def force_move_route(move_route)
    # オリジナルの移動ルートを保存
    if @original_move_route == nil
      @original_move_route = @move_route
      @original_move_route_index = @move_route_index
    end
    # 移動ルートを変更
    @move_route = move_route
    @move_route_index = 0
    # 移動ルート強制フラグをセット
    @move_route_forcing = true
    # ロック前の向きをクリア
    @prelock_direction = 0
    # ウェイトカウントをクリア
    @wait_count = 0
    # カスタム移動
    move_type_custom
  end
  #--------------------------------------------------------------------------
  # ● 通行可能判定
  #     x : X 座標
  #     y : Y 座標
  #     d : 方向 (0,2,4,6,8)  ※ 0 = 全方向通行不可の場合を判定 (ジャンプ用)
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    # 新しい座標を求める
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    # 座標がマップ外の場合
    unless $game_map.valid?(new_x, new_y)
      # 通行不可
      return false
    end
    # すり抜け ON の場合
    if @through
      # 通行可
      return true
    end
    # 移動元のタイルから指定方向に出られない場合
    unless $game_map.passable?(x, y, d, self)
      # 通行不可
      return false
    end
    # 移動先のタイルに指定方向から入れない場合
    unless $game_map.passable?(new_x, new_y, 10 - d)
      # 通行不可
      return false
    end
    # 全イベントのループ
    for event in $game_map.events.values
      # イベントの座標が移動先と一致した場合
      if event.x == new_x and event.y == new_y
        # すり抜け OFF なら
        unless event.through
          # 自分がイベントの場合
          if self != $game_player
            # 通行不可
            return false
          end
          # 自分がプレイヤーで、相手のグラフィックがキャラクターの場合
          if event.character_name != ""
            # 通行不可
            return false
          end
        end
      end
    end
    # プレイヤーの座標が移動先と一致した場合
    if $game_player.x == new_x and $game_player.y == new_y
      # すり抜け OFF なら
      unless $game_player.through
        # 自分のグラフィックがキャラクターの場合
        if @character_name != ""
          # 通行不可
          return false
        end
      end
    end
    # 通行可
    return true
  end
  #--------------------------------------------------------------------------
  # ● ロック
  #--------------------------------------------------------------------------
  def lock
    # すでにロックされている場合
    if @locked
      # メソッド終了
      return
    end
    # ロック前の向きを保存
    @prelock_direction = @direction
    # プレイヤーの方を向く
    turn_toward_player
    # ロック中フラグをセット
    @locked = true
  end
  #--------------------------------------------------------------------------
  # ● ロック中判定
  #--------------------------------------------------------------------------
  def lock?
    return @locked
  end
  #--------------------------------------------------------------------------
  # ● ロック解除
  #--------------------------------------------------------------------------
  def unlock
    # ロックされていない場合
    unless @locked
      # メソッド終了
      return
    end
    # ロック中フラグをクリア
    @locked = false
    # 向き固定でない場合
    unless @direction_fix
      # ロック前の向きが保存されていれば
      if @prelock_direction != 0
        # ロック前の向きを復帰
        @direction = @prelock_direction
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 指定位置に移動
  #     x : X 座標
  #     y : Y 座標
  #--------------------------------------------------------------------------
  def moveto(x, y)
    @x = x % $game_map.width
    @y = y % $game_map.height
    @real_x = @x * 128
    @real_y = @y * 128
    @prelock_direction = 0
  end
  #--------------------------------------------------------------------------
  # ● 画面 X 座標の取得
  #--------------------------------------------------------------------------
  def screen_x
    # 実座標とマップの表示位置から画面座標を求める
    return (@real_x - $game_map.display_x + 3) / 4 + 16
  end
  #--------------------------------------------------------------------------
  # ● 画面 Y 座標の取得
  #--------------------------------------------------------------------------
  def screen_y
    # 実座標とマップの表示位置から画面座標を求める
    y = (@real_y - $game_map.display_y + 3) / 4 + 32
    # ジャンプカウントに応じて Y 座標を小さくする
    if @jump_count >= @jump_peak
      n = @jump_count - @jump_peak
    else
      n = @jump_peak - @jump_count
    end
    return y - (@jump_peak * @jump_peak - n * n) / 2
  end
  #--------------------------------------------------------------------------
  # ● 画面 Z 座標の取得
  #     height : キャラクターの高さ
  #--------------------------------------------------------------------------
  def screen_z(height = 0)
    # 最前面に表示フラグが ON の場合
    if @always_on_top
      # 無条件に 999
      return 999
    end
    # 実座標とマップの表示位置から画面座標を求める
    z = (@real_y - $game_map.display_y + 3) / 4 + 32
    # タイルの場合
    if @tile_id > 0
      # タイルのプライオリティ * 32 を足す
      return z + $game_map.priorities[@tile_id] * 32
    # キャラクターの場合
    else
      # 高さが 32 を超えていれば 31 を足す
      return z + ((height > 32) ? 31 : 0)
    end
  end
  #--------------------------------------------------------------------------
  # ● 茂み深さの取得
  #--------------------------------------------------------------------------
  def bush_depth
    # タイルの場合、または最前面に表示フラグが ON の場合
    if @tile_id > 0 or @always_on_top
      return 0
    end
    # ジャンプ中以外で茂み属性のタイルなら 12、それ以外なら 0
    if @jump_count == 0 and $game_map.bush?(@x, @y)
      return 12
    else
      return 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 地形タグの取得
  #--------------------------------------------------------------------------
  def terrain_tag
    return $game_map.terrain_tag(@x, @y)
  end
end

#==============================================================================
# ■ Game_Character (分割定義 2)
#------------------------------------------------------------------------------
# 　キャラクターを扱うクラスです。このクラスは Game_Player クラスと Game_Event
# クラスのスーパークラスとして使用されます。
#==============================================================================

class Game_Character
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ジャンプ中、移動中、停止中で分岐
    if jumping?
      update_jump
    elsif moving?
      update_move
    else
      update_stop
    end
    # アニメカウントが最大値を超えた場合
    # ※最大値は、基本値 18 から移動速度 * 1 を引いた値
    if @anime_count > 18 - @move_speed * 2
      # 停止時アニメが OFF かつ 停止中の場合
      if not @step_anime and @stop_count > 0
        # パターンをオリジナルに戻す
        @pattern = @original_pattern
      # 停止時アニメが ON または 移動中の場合
      else
        # パターンを更新
        @pattern = (@pattern + 1) % 4
      end
      # アニメカウントをクリア
      @anime_count = 0
    end
    # ウェイト中の場合
    if @wait_count > 0
      # ウェイトカウントを減らす
      @wait_count -= 1
      return
    end
    # 移動ルート強制中の場合
    if @move_route_forcing
      # カスタム移動
      move_type_custom
      return
    end
    # イベント実行待機中またはロック状態の場合
    if @starting or lock?
      # 自律移動はしない
      return
    end
    # 停止カウントが一定の値 (移動頻度から算出) を超えた場合
    if @stop_count > (40 - @move_frequency * 2) * (6 - @move_frequency)
      # 移動タイプで分岐
      case @move_type
      when 1  # ランダム
        move_type_random
      when 2  # 近づく
        move_type_toward_player
      when 3  # カスタム
        move_type_custom
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ジャンプ)
  #--------------------------------------------------------------------------
  def update_jump
    # ジャンプカウントを 1 減らす
    @jump_count -= 1
    # 新しい座標を計算
    @real_x = (@real_x * @jump_count + @x * 128) / (@jump_count + 1)
    @real_y = (@real_y * @jump_count + @y * 128) / (@jump_count + 1)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (移動)
  #--------------------------------------------------------------------------
  def update_move
    # 移動速度からマップ座標系での移動距離に変換
    distance = 2 ** @move_speed
    # 論理座標が実座標より下の場合
    if @y * 128 > @real_y
      # 下に移動
      @real_y = [@real_y + distance, @y * 128].min
    end
    # 論理座標が実座標より左の場合
    if @x * 128 < @real_x
      # 左に移動
      @real_x = [@real_x - distance, @x * 128].max
    end
    # 論理座標が実座標より右の場合
    if @x * 128 > @real_x
      # 右に移動
      @real_x = [@real_x + distance, @x * 128].min
    end
    # 論理座標が実座標より上の場合
    if @y * 128 < @real_y
      # 上に移動
      @real_y = [@real_y - distance, @y * 128].max
    end
    # 移動時アニメが ON の場合
    if @walk_anime
      # アニメカウントを 1.5 増やす
      @anime_count += 1.5
    # 移動時アニメが OFF で、停止時アニメが ON の場合
    elsif @step_anime
      # アニメカウントを 1 増やす
      @anime_count += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (停止)
  #--------------------------------------------------------------------------
  def update_stop
    # 停止時アニメが ON の場合
    if @step_anime
      # アニメカウントを 1 増やす
      @anime_count += 1
    # 停止時アニメが OFF だが、現在のパターンがオリジナルと異なる場合
    elsif @pattern != @original_pattern
      # アニメカウントを 1.5 増やす
      @anime_count += 1.5
    end
    # イベント実行待機中またはロック状態ではない場合
    # ※ロックは、実行中のイベントが立ち止まる処理
    unless @starting or lock?
      # 停止カウントを 1 増やす
      @stop_count += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 移動タイプ : ランダム
  #--------------------------------------------------------------------------
  def move_type_random
    # 乱数 0～5 で分岐
    case rand(6)
    when 0..3  # ランダム
      move_random
    when 4  # 一歩前進
      move_forward
    when 5  # 一時停止
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 移動タイプ : 近づく
  #--------------------------------------------------------------------------
  def move_type_toward_player
    # プレイヤーの座標との差を求める
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # 差の絶対値を求める
    abs_sx = sx > 0 ? sx : -sx
    abs_sy = sy > 0 ? sy : -sy
    # 縦横あわせて 20 タイル以上離れている場合
    if sx + sy >= 20
      # ランダム
      move_random
      return
    end
    # 乱数 0～5 で分岐
    case rand(6)
    when 0..3  # プレイヤーに近づく
      move_toward_player
    when 4  # ランダム
      move_random
    when 5  # 一歩前進
      move_forward
    end
  end
  #--------------------------------------------------------------------------
  # ● 移動タイプ : カスタム
  #--------------------------------------------------------------------------
  def move_type_custom
    # 停止中でなければ中断
    if jumping? or moving?
      return
    end
    # 移動コマンドのリストの最後に到達するまでループ
    while @move_route_index < @move_route.list.size
      # 移動コマンドを取得
      command = @move_route.list[@move_route_index]
      # コマンドコード 0 番 (リストの最後) の場合
      if command.code == 0
        # オプション [動作を繰り返す] が ON の場合
        if @move_route.repeat
          # 移動ルートのインデックスを最初に戻す
          @move_route_index = 0
        end
        # オプション [動作を繰り返す] が OFF の場合
        unless @move_route.repeat
          # 移動ルート強制中の場合
          if @move_route_forcing and not @move_route.repeat
            # 移動ルートの強制を解除
            @move_route_forcing = false
            # オリジナルの移動ルートを復帰
            @move_route = @original_move_route
            @move_route_index = @original_move_route_index
            @original_move_route = nil
          end
          # 停止カウントをクリア
          @stop_count = 0
        end
        return
      end
      # 移動系コマンド (下に移動～ジャンプ) の場合
      if command.code <= 14
        # コマンドコードで分岐
        case command.code
        when 1  # 下に移動
          move_down
        when 2  # 左に移動
          move_left
        when 3  # 右に移動
          move_right
        when 4  # 上に移動
          move_up
        when 5  # 左下に移動
          move_lower_left
        when 6  # 右下に移動
          move_lower_right
        when 7  # 左上に移動
          move_upper_left
        when 8  # 右上に移動
          move_upper_right
        when 9  # ランダムに移動
          move_random
        when 10  # プレイヤーに近づく
          move_toward_player
        when 11  # プレイヤーから遠ざかる
          move_away_from_player
        when 12  # 一歩前進
          move_forward
        when 13  # 一歩後退
          move_backward
        when 14  # ジャンプ
          jump(command.parameters[0], command.parameters[1])
        end
        # オプション [移動できない場合は無視] が OFF で、移動失敗の場合
        if not @move_route.skippable and not moving? and not jumping?
          return
        end
        @move_route_index += 1
        return
      end
      # ウェイトの場合
      if command.code == 15
        # ウェイトカウントを設定
        @wait_count = command.parameters[0] * 2 - 1
        @move_route_index += 1
        return
      end
      # 向き変更系のコマンドの場合
      if command.code >= 16 and command.code <= 26
        # コマンドコードで分岐
        case command.code
        when 16  # 下を向く
          turn_down
        when 17  # 左を向く
          turn_left
        when 18  # 右を向く
          turn_right
        when 19  # 上を向く
          turn_up
        when 20  # 右に 90 度回転
          turn_right_90
        when 21  # 左に 90 度回転
          turn_left_90
        when 22  # 180 度回転
          turn_180
        when 23  # 右か左に 90 度回転
          turn_right_or_left_90
        when 24  # ランダムに方向転換
          turn_random
        when 25  # プレイヤーの方を向く
          turn_toward_player
        when 26  # プレイヤーの逆を向く
          turn_away_from_player
        end
        @move_route_index += 1
        return
      end
      # その他のコマンドの場合
      if command.code >= 27
        # コマンドコードで分岐
        case command.code
        when 27  # スイッチ ON
          $game_switches[command.parameters[0]] = true
          $game_map.need_refresh = true
        when 28  # スイッチ OFF
          $game_switches[command.parameters[0]] = false
          $game_map.need_refresh = true
        when 29  # 移動速度の変更
          @move_speed = command.parameters[0]
        when 30  # 移動頻度の変更
          @move_frequency = command.parameters[0]
        when 31  # 移動時アニメ ON
          @walk_anime = true
        when 32  # 移動時アニメ OFF
          @walk_anime = false
        when 33  # 停止時アニメ ON
          @step_anime = true
        when 34  # 停止時アニメ OFF
          @step_anime = false
        when 35  # 向き固定 ON
          @direction_fix = true
        when 36  # 向き固定 OFF
          @direction_fix = false
        when 37  # すり抜け ON
          @through = true
        when 38  # すり抜け OFF
          @through = false
        when 39  # 最前面に表示 ON
          @always_on_top = true
        when 40  # 最前面に表示 OFF
          @always_on_top = false
        when 41  # グラフィック変更
          @tile_id = 0
          @character_name = command.parameters[0]
          @character_hue = command.parameters[1]
          if @original_direction != command.parameters[2]
            @direction = command.parameters[2]
            @original_direction = @direction
            @prelock_direction = 0
          end
          if @original_pattern != command.parameters[3]
            @pattern = command.parameters[3]
            @original_pattern = @pattern
          end
        when 42  # 不透明度の変更
          @opacity = command.parameters[0]
        when 43  # 合成方法の変更
          @blend_type = command.parameters[0]
        when 44  # SE の演奏
          $game_system.se_play(command.parameters[0])
        when 45  # スクリプト
          result = eval(command.parameters[0])
        end
        @move_route_index += 1
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 歩数増加
  #--------------------------------------------------------------------------
  def increase_steps
    # 停止カウントをクリア
    @stop_count = 0
  end
end

#==============================================================================
# ■ Game_Character (分割定義 3)
#------------------------------------------------------------------------------
# 　キャラクターを扱うクラスです。このクラスは Game_Player クラスと Game_Event
# クラスのスーパークラスとして使用されます。
#==============================================================================

class Game_Character
  #--------------------------------------------------------------------------
  # ● 下に移動
  #     turn_enabled : その場での向き変更を許可するフラグ
  #--------------------------------------------------------------------------
  def move_down(turn_enabled = true)
    # 下を向く
    if turn_enabled
      turn_down
    end
    # 通行可能な場合
    if passable?(@x, @y, 2)
      # 下を向く
      turn_down
      # 座標を更新
      @y += 1
      # 歩数増加
      increase_steps
    # 通行不可能な場合
    else
      # 接触イベントの起動判定
      check_event_trigger_touch(@x, @y+1)
    end
  end
  #--------------------------------------------------------------------------
  # ● 左に移動
  #     turn_enabled : その場での向き変更を許可するフラグ
  #--------------------------------------------------------------------------
  def move_left(turn_enabled = true)
    # 左を向く
    if turn_enabled
      turn_left
    end
    # 通行可能な場合
    if passable?(@x, @y, 4)
      # 左を向く
      turn_left
      # 座標を更新
      @x -= 1
      # 歩数増加
      increase_steps
    # 通行不可能な場合
    else
      # 接触イベントの起動判定
      check_event_trigger_touch(@x-1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # ● 右に移動
  #     turn_enabled : その場での向き変更を許可するフラグ
  #--------------------------------------------------------------------------
  def move_right(turn_enabled = true)
    # 右を向く
    if turn_enabled
      turn_right
    end
    # 通行可能な場合
    if passable?(@x, @y, 6)
      # 右を向く
      turn_right
      # 座標を更新
      @x += 1
      # 歩数増加
      increase_steps
    # 通行不可能な場合
    else
      # 接触イベントの起動判定
      check_event_trigger_touch(@x+1, @y)
    end
  end
  #--------------------------------------------------------------------------
  # ● 上に移動
  #     turn_enabled : その場での向き変更を許可するフラグ
  #--------------------------------------------------------------------------
  def move_up(turn_enabled = true)
    # 上を向く
    if turn_enabled
      turn_up
    end
    # 通行可能な場合
    if passable?(@x, @y, 8)
      # 上を向く
      turn_up
      # 座標を更新
      @y -= 1
      # 歩数増加
      increase_steps
    # 通行不可能な場合
    else
      # 接触イベントの起動判定
      check_event_trigger_touch(@x, @y-1)
    end
  end
  #--------------------------------------------------------------------------
  # ● 左下に移動
  #--------------------------------------------------------------------------
  def move_lower_left
    # 向き固定でない場合
    unless @direction_fix
      # 右向きだった場合は左を、上向きだった場合は下を向く
      @direction = (@direction == 6 ? 4 : @direction == 8 ? 2 : @direction)
    end
    # 下→左、左→下 のどちらかのコースが通行可能な場合
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 2))
      # 座標を更新
      @x -= 1
      @y += 1
      # 歩数増加
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # ● 右下に移動
  #--------------------------------------------------------------------------
  def move_lower_right
    # 向き固定でない場合
    unless @direction_fix
      # 左向きだった場合は右を、上向きだった場合は下を向く
      @direction = (@direction == 4 ? 6 : @direction == 8 ? 2 : @direction)
    end
    # 下→右、右→下 のどちらかのコースが通行可能な場合
    if (passable?(@x, @y, 2) and passable?(@x, @y + 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 2))
      # 座標を更新
      @x += 1
      @y += 1
      # 歩数増加
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # ● 左上に移動
  #--------------------------------------------------------------------------
  def move_upper_left
    # 向き固定でない場合
    unless @direction_fix
      # 右向きだった場合は左を、下向きだった場合は上を向く
      @direction = (@direction == 6 ? 4 : @direction == 2 ? 8 : @direction)
    end
    # 上→左、左→上 のどちらかのコースが通行可能な場合
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 4)) or
       (passable?(@x, @y, 4) and passable?(@x - 1, @y, 8))
      # 座標を更新
      @x -= 1
      @y -= 1
      # 歩数増加
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # ● 右上に移動
  #--------------------------------------------------------------------------
  def move_upper_right
    # 向き固定でない場合
    unless @direction_fix
      # 左向きだった場合は右を、下向きだった場合は上を向く
      @direction = (@direction == 4 ? 6 : @direction == 2 ? 8 : @direction)
    end
    # 上→右、右→上 のどちらかのコースが通行可能な場合
    if (passable?(@x, @y, 8) and passable?(@x, @y - 1, 6)) or
       (passable?(@x, @y, 6) and passable?(@x + 1, @y, 8))
      # 座標を更新
      @x += 1
      @y -= 1
      # 歩数増加
      increase_steps
    end
  end
  #--------------------------------------------------------------------------
  # ● ランダムに移動
  #--------------------------------------------------------------------------
  def move_random
    case rand(4)
    when 0  # 下に移動
      move_down(false)
    when 1  # 左に移動
      move_left(false)
    when 2  # 右に移動
      move_right(false)
    when 3  # 上に移動
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # ● プレイヤーに近づく
  #--------------------------------------------------------------------------
  def move_toward_player
    # プレイヤーの座標との差を求める
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # 座標が等しい場合
    if sx == 0 and sy == 0
      return
    end
    # 差の絶対値を求める
    abs_sx = sx.abs
    abs_sy = sy.abs
    # 横の距離と縦の距離が等しい場合
    if abs_sx == abs_sy
      # ランダムでどちらかを 1 増やす
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # 横の距離のほうが長い場合
    if abs_sx > abs_sy
      # 左右方向を優先し、プレイヤーのいるほうへ移動
      sx > 0 ? move_left : move_right
      if not moving? and sy != 0
        sy > 0 ? move_up : move_down
      end
    # 縦の距離のほうが長い場合
    else
      # 上下方向を優先し、プレイヤーのいるほうへ移動
      sy > 0 ? move_up : move_down
      if not moving? and sx != 0
        sx > 0 ? move_left : move_right
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● プレイヤーから遠ざかる
  #--------------------------------------------------------------------------
  def move_away_from_player
    # プレイヤーの座標との差を求める
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # 座標が等しい場合
    if sx == 0 and sy == 0
      return
    end
    # 差の絶対値を求める
    abs_sx = sx.abs
    abs_sy = sy.abs
    # 横の距離と縦の距離が等しい場合
    if abs_sx == abs_sy
      # ランダムでどちらかを 1 増やす
      rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
    end
    # 横の距離のほうが長い場合
    if abs_sx > abs_sy
      # 左右方向を優先し、プレイヤーのいないほうへ移動
      sx > 0 ? move_right : move_left
      if not moving? and sy != 0
        sy > 0 ? move_down : move_up
      end
    # 縦の距離のほうが長い場合
    else
      # 上下方向を優先し、プレイヤーのいないほうへ移動
      sy > 0 ? move_down : move_up
      if not moving? and sx != 0
        sx > 0 ? move_right : move_left
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 一歩前進
  #--------------------------------------------------------------------------
  def move_forward
    case @direction
    when 2
      move_down(false)
    when 4
      move_left(false)
    when 6
      move_right(false)
    when 8
      move_up(false)
    end
  end
  #--------------------------------------------------------------------------
  # ● 一歩後退
  #--------------------------------------------------------------------------
  def move_backward
    # 向き固定の状態を記憶
    last_direction_fix = @direction_fix
    # 強制的に向き固定
    @direction_fix = true
    # 向きで分岐
    case @direction
    when 2  # 下
      move_up(false)
    when 4  # 左
      move_right(false)
    when 6  # 右
      move_left(false)
    when 8  # 上
      move_down(false)
    end
    # 向き固定の状態を元に戻す
    @direction_fix = last_direction_fix
  end
  #--------------------------------------------------------------------------
  # ● ジャンプ
  #     x_plus : X 座標加算値
  #     y_plus : Y 座標加算値
  #--------------------------------------------------------------------------
  def jump(x_plus, y_plus)
    # 加算値が (0,0) ではない場合
    if x_plus != 0 or y_plus != 0
      # 横の距離のほうが長い場合
      if x_plus.abs > y_plus.abs
        # 左右どちらかに向き変更
        x_plus < 0 ? turn_left : turn_right
      # 縦の距離のほうが長いか等しい場合
      else
        # 上下どちらかに向き変更
        y_plus < 0 ? turn_up : turn_down
      end
    end
    # 新しい座標を計算
    new_x = @x + x_plus
    new_y = @y + y_plus
    # 加算値が (0,0) の場合か、ジャンプ先が通行可能な場合
    if (x_plus == 0 and y_plus == 0) or passable?(new_x, new_y, 0)
      # 姿勢を矯正
      straighten
      # 座標を更新
      @x = new_x
      @y = new_y
      # 距離を計算
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      # ジャンプカウントを設定
      @jump_peak = 10 + distance - @move_speed
      @jump_count = @jump_peak * 2
      # 停止カウントをクリア
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 下を向く
  #--------------------------------------------------------------------------
  def turn_down
    unless @direction_fix
      @direction = 2
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 左を向く
  #--------------------------------------------------------------------------
  def turn_left
    unless @direction_fix
      @direction = 4
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 右を向く
  #--------------------------------------------------------------------------
  def turn_right
    unless @direction_fix
      @direction = 6
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 上を向く
  #--------------------------------------------------------------------------
  def turn_up
    unless @direction_fix
      @direction = 8
      @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 右に 90 度回転
  #--------------------------------------------------------------------------
  def turn_right_90
    case @direction
    when 2
      turn_left
    when 4
      turn_up
    when 6
      turn_down
    when 8
      turn_right
    end
  end
  #--------------------------------------------------------------------------
  # ● 左に 90 度回転
  #--------------------------------------------------------------------------
  def turn_left_90
    case @direction
    when 2
      turn_right
    when 4
      turn_down
    when 6
      turn_up
    when 8
      turn_left
    end
  end
  #--------------------------------------------------------------------------
  # ● 180 度回転
  #--------------------------------------------------------------------------
  def turn_180
    case @direction
    when 2
      turn_up
    when 4
      turn_right
    when 6
      turn_left
    when 8
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # ● 右か左に 90 度回転
  #--------------------------------------------------------------------------
  def turn_right_or_left_90
    if rand(2) == 0
      turn_right_90
    else
      turn_left_90
    end
  end
  #--------------------------------------------------------------------------
  # ● ランダムに方向転換
  #--------------------------------------------------------------------------
  def turn_random
    case rand(4)
    when 0
      turn_up
    when 1
      turn_right
    when 2
      turn_left
    when 3
      turn_down
    end
  end
  #--------------------------------------------------------------------------
  # ● プレイヤーの方を向く
  #--------------------------------------------------------------------------
  def turn_toward_player
    # プレイヤーの座標との差を求める
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # 座標が等しい場合
    if sx == 0 and sy == 0
      return
    end
    # 横の距離のほうが長い場合
    if sx.abs > sy.abs
      # 左右方向でプレイヤーのいるほうを向く
      sx > 0 ? turn_left : turn_right
    # 縦の距離のほうが長い場合
    else
      # 上下方向でプレイヤーのいるほうを向く
      sy > 0 ? turn_up : turn_down
    end
  end
  #--------------------------------------------------------------------------
  # ● プレイヤーの逆を向く
  #--------------------------------------------------------------------------
  def turn_away_from_player
    # プレイヤーの座標との差を求める
    sx = @x - $game_player.x
    sy = @y - $game_player.y
    # 座標が等しい場合
    if sx == 0 and sy == 0
      return
    end
    # 横の距離のほうが長い場合
    if sx.abs > sy.abs
      # 左右方向でプレイヤーのいないほうを向く
      sx > 0 ? turn_right : turn_left
    # 縦の距離のほうが長い場合
    else
      # 上下方向でプレイヤーのいないほうを向く
      sy > 0 ? turn_down : turn_up
    end
  end
end

#==============================================================================
# ■ Game_Event
#------------------------------------------------------------------------------
# 　イベントを扱うクラスです。条件判定によるイベントページ切り替えや、並列処理
# イベント実行などの機能を持っており、Game_Map クラスの内部で使用されます。
#==============================================================================

class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :trigger                  # トリガー
  attr_reader   :list                     # 実行内容
  attr_reader   :starting                 # 起動中フラグ
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     map_id : マップ ID
  #     event  : イベント (RPG::Event)
  #--------------------------------------------------------------------------
  def initialize(map_id, event)
    super()
    @map_id = map_id
    @event = event
    @id = @event.id
    @erased = false
    @starting = false
    @through = true
    # 初期位置に移動
    moveto(@event.x, @event.y)
    refresh
  end
  #--------------------------------------------------------------------------
  # ● 起動中フラグのクリア
  #--------------------------------------------------------------------------
  def clear_starting
    @starting = false
  end
  #--------------------------------------------------------------------------
  # ● オーバートリガー判定 (同位置を起動条件とするか否か)
  #--------------------------------------------------------------------------
  def over_trigger?
    # グラフィックがキャラクターで、すり抜け状態ではない場合
    if @character_name != "" and not @through
      # 起動判定は正面
      return false
    end
    # マップ上でこの位置が通行不可能な場合
    unless $game_map.passable?(@x, @y, 0)
      # 起動判定は正面
      return false
    end
    # 起動判定は同位置
    return true
  end
  #--------------------------------------------------------------------------
  # ● イベント起動
  #--------------------------------------------------------------------------
  def start
    # 実行内容が空でない場合
    if @list.size > 1
      @starting = true
    end
  end
  #--------------------------------------------------------------------------
  # ● 一時消去
  #--------------------------------------------------------------------------
  def erase
    @erased = true
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # ローカル変数 new_page を初期化
    new_page = nil
    # 一時消去されていない場合
    unless @erased
      # 番号の大きいイベントページから順に調べる
      for page in @event.pages.reverse
        # イベント条件を c で参照可能に
        c = page.condition
        # スイッチ 1 条件確認
        if c.switch1_valid
          if $game_switches[c.switch1_id] == false
            next
          end
        end
        # スイッチ 2 条件確認
        if c.switch2_valid
          if $game_switches[c.switch2_id] == false
            next
          end
        end
        # 変数 条件確認
        if c.variable_valid
          if $game_variables[c.variable_id] < c.variable_value
            next
          end
        end
        # セルフスイッチ 条件確認
        if c.self_switch_valid
          key = [@map_id, @event.id, c.self_switch_ch]
          if $game_self_switches[key] != true
            next
          end
        end
        # ローカル変数 new_page を設定
        new_page = page
        # ループを抜ける
        break
      end
    end
    # 前回と同じイベントページの場合
    if new_page == @page
      # メソッド終了
      return
    end
    # @page に現在のイベントページを設定
    @page = new_page
    # 起動中フラグをクリア
    clear_starting
    # 条件を満たすページがない場合
    if @page == nil
      # 各インスタンス変数を設定
      @tile_id = 0
      @character_name = ""
      @character_hue = 0
      @move_type = 0
      @through = true
      @trigger = nil
      @list = nil
      @interpreter = nil
      # メソッド終了
      return
    end
    # 各インスタンス変数を設定
    @tile_id = @page.graphic.tile_id
    @character_name = @page.graphic.character_name
    @character_hue = @page.graphic.character_hue
    if @original_direction != @page.graphic.direction
      @direction = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction = 0
    end
    if @original_pattern != @page.graphic.pattern
      @pattern = @page.graphic.pattern
      @original_pattern = @pattern
    end
    @opacity = @page.graphic.opacity
    @blend_type = @page.graphic.blend_type
    @move_type = @page.move_type
    @move_speed = @page.move_speed
    @move_frequency = @page.move_frequency
    @move_route = @page.move_route
    @move_route_index = 0
    @move_route_forcing = false
    @walk_anime = @page.walk_anime
    @step_anime = @page.step_anime
    @direction_fix = @page.direction_fix
    @through = @page.through
    @always_on_top = @page.always_on_top
    @trigger = @page.trigger
    @list = @page.list
    @interpreter = nil
    # トリガーが [並列処理] の場合
    if @trigger == 4
      # 並列処理用インタプリタを作成
      @interpreter = Interpreter.new
    end
    # 自動イベントの起動判定
    check_event_trigger_auto
  end
  #--------------------------------------------------------------------------
  # ● 接触イベントの起動判定
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    # イベント実行中の場合
    if $game_system.map_interpreter.running?
      return
    end
    # トリガーが [イベントから接触] かつプレイヤーの座標と一致した場合
    if @trigger == 2 and x == $game_player.x and y == $game_player.y
      # ジャンプ中以外で、起動判定が正面のイベントなら
      if not jumping? and not over_trigger?
        start
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 自動イベントの起動判定
  #--------------------------------------------------------------------------
  def check_event_trigger_auto
    # トリガーが [イベントから接触] かつプレイヤーの座標と一致した場合
    if @trigger == 2 and @x == $game_player.x and @y == $game_player.y
      # ジャンプ中以外で、起動判定が同位置のイベントなら
      if not jumping? and over_trigger?
        start
      end
    end
    # トリガーが [自動実行] の場合
    if @trigger == 3
      start
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # 自動イベントの起動判定
    check_event_trigger_auto
    # 並列処理が有効の場合
    if @interpreter != nil
      # 実行中でない場合
      unless @interpreter.running?
        # イベントをセットアップ
        @interpreter.setup(@list, @event.id)
      end
      # インタプリタを更新
      @interpreter.update
    end
  end
end

#==============================================================================
# ■ Game_Player
#------------------------------------------------------------------------------
# 　プレイヤーを扱うクラスです。イベントの起動判定や、マップのスクロールなどの
# 機能を持っています。このクラスのインスタンスは $game_player で参照されます。
#==============================================================================

class Game_Player < Game_Character
  #--------------------------------------------------------------------------
  # ● 定数
  #--------------------------------------------------------------------------
  CENTER_X = (320 - 16) * 4   # 画面中央の X 座標 * 4
  CENTER_Y = (240 - 16) * 4   # 画面中央の Y 座標 * 4
  #--------------------------------------------------------------------------
  # ● 通行可能判定
  #     x : X 座標
  #     y : Y 座標
  #     d : 方向 (0,2,4,6,8)  ※ 0 = 全方向通行不可の場合を判定 (ジャンプ用)
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    # 新しい座標を求める
    new_x = x + (d == 6 ? 1 : d == 4 ? -1 : 0)
    new_y = y + (d == 2 ? 1 : d == 8 ? -1 : 0)
    # 座標がマップ外の場合
    unless $game_map.valid?(new_x, new_y)
      # 通行不可
      return false
    end
    # デバッグモードが ON かつ CTRL キーが押されている場合
    if $DEBUG and Input.press?(Input::CTRL)
      # 通行可
      return true
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● 画面中央に来るようにマップの表示位置を設定
  #--------------------------------------------------------------------------
  def center(x, y)
    max_x = ($game_map.width - 20) * 128
    max_y = ($game_map.height - 15) * 128
    $game_map.display_x = [0, [x * 128 - CENTER_X, max_x].min].max
    $game_map.display_y = [0, [y * 128 - CENTER_Y, max_y].min].max
  end
  #--------------------------------------------------------------------------
  # ● 指定位置に移動
  #     x : X 座標
  #     y : Y 座標
  #--------------------------------------------------------------------------
  def moveto(x, y)
    super
    # センタリング
    center(x, y)
    # エンカウント カウントを作成
    make_encounter_count
  end
  #--------------------------------------------------------------------------
  # ● 歩数増加
  #--------------------------------------------------------------------------
  def increase_steps
    super
    # 移動ルート強制中ではない場合
    unless @move_route_forcing
      # 歩数増加
      $game_party.increase_steps
      # 歩数が偶数の場合
      if $game_party.steps % 2 == 0
        # スリップダメージチェック
        $game_party.check_map_slip_damage
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● エンカウント カウント取得
  #--------------------------------------------------------------------------
  def encounter_count
    return @encounter_count
  end
  #--------------------------------------------------------------------------
  # ● エンカウント カウント作成
  #--------------------------------------------------------------------------
  def make_encounter_count
    # サイコロを 2 個振るイメージ
    if $game_map.map_id != 0
      n = $game_map.encounter_step
      @encounter_count = rand(n) + rand(n) + 1
    end
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # パーティ人数が 0 人の場合
    if $game_party.actors.size == 0
      # キャラクターのファイル名と色相をクリア
      @character_name = ""
      @character_hue = 0
      # メソッド終了
      return
    end
    # 先頭のアクターを取得
    actor = $game_party.actors[0]
    # キャラクターのファイル名と色相を設定
    @character_name = actor.character_name
    @character_hue = actor.character_hue
    # 不透明度と合成方法を初期化
    @opacity = 255
    @blend_type = 0
  end
  #--------------------------------------------------------------------------
  # ● 同位置のイベント起動判定
  #--------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    result = false
    # イベント実行中の場合
    if $game_system.map_interpreter.running?
      return result
    end
    # 全イベントのループ
    for event in $game_map.events.values
      # イベントの座標とトリガーが一致した場合
      if event.x == @x and event.y == @y and triggers.include?(event.trigger)
        # ジャンプ中以外で、起動判定が同位置のイベントなら
        if not event.jumping? and event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end
  #--------------------------------------------------------------------------
  # ● 正面のイベント起動判定
  #--------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    result = false
    # イベント実行中の場合
    if $game_system.map_interpreter.running?
      return result
    end
    # 正面の座標を計算
    new_x = @x + (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
    new_y = @y + (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
    # 全イベントのループ
    for event in $game_map.events.values
      # イベントの座標とトリガーが一致した場合
      if event.x == new_x and event.y == new_y and
         triggers.include?(event.trigger)
        # ジャンプ中以外で、起動判定が正面のイベントなら
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    # 該当するイベントが見つからなかった場合
    if result == false
      # 正面のタイルがカウンターなら
      if $game_map.counter?(new_x, new_y)
        # 1 タイル奥の座標を計算
        new_x += (@direction == 6 ? 1 : @direction == 4 ? -1 : 0)
        new_y += (@direction == 2 ? 1 : @direction == 8 ? -1 : 0)
        # 全イベントのループ
        for event in $game_map.events.values
          # イベントの座標とトリガーが一致した場合
          if event.x == new_x and event.y == new_y and
             triggers.include?(event.trigger)
            # ジャンプ中以外で、起動判定が正面のイベントなら
            if not event.jumping? and not event.over_trigger?
              event.start
              result = true
            end
          end
        end
      end
    end
    return result
  end
  #--------------------------------------------------------------------------
  # ● 接触イベントの起動判定
  #--------------------------------------------------------------------------
  def check_event_trigger_touch(x, y)
    result = false
    # イベント実行中の場合
    if $game_system.map_interpreter.running?
      return result
    end
    # 全イベントのループ
    for event in $game_map.events.values
      # イベントの座標とトリガーが一致した場合
      if event.x == x and event.y == y and [1,2].include?(event.trigger)
        # ジャンプ中以外で、起動判定が正面のイベントなら
        if not event.jumping? and not event.over_trigger?
          event.start
          result = true
        end
      end
    end
    return result
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ローカル変数に移動中かどうかを記憶
    last_moving = moving?
    # 移動中、イベント実行中、移動ルート強制中、
    # メッセージウィンドウ表示中のいずれでもない場合
    unless moving? or $game_system.map_interpreter.running? or
           @move_route_forcing or $game_temp.message_window_showing
      # 方向ボタンが押されていれば、その方向へプレイヤーを移動
      case Input.dir4
      when 2
        move_down
      when 4
        move_left
      when 6
        move_right
      when 8
        move_up
      end
    end
    # ローカル変数に座標を記憶
    last_real_x = @real_x
    last_real_y = @real_y
    super
    # キャラクターが下に移動し、かつ画面上の位置が中央より下の場合
    if @real_y > last_real_y and @real_y - $game_map.display_y > CENTER_Y
      # マップを下にスクロール
      $game_map.scroll_down(@real_y - last_real_y)
    end
    # キャラクターが左に移動し、かつ画面上の位置が中央より左の場合
    if @real_x < last_real_x and @real_x - $game_map.display_x < CENTER_X
      # マップを左にスクロール
      $game_map.scroll_left(last_real_x - @real_x)
    end
    # キャラクターが右に移動し、かつ画面上の位置が中央より右の場合
    if @real_x > last_real_x and @real_x - $game_map.display_x > CENTER_X
      # マップを右にスクロール
      $game_map.scroll_right(@real_x - last_real_x)
    end
    # キャラクターが上に移動し、かつ画面上の位置が中央より上の場合
    if @real_y < last_real_y and @real_y - $game_map.display_y < CENTER_Y
      # マップを上にスクロール
      $game_map.scroll_up(last_real_y - @real_y)
    end
    # 移動中ではない場合
    unless moving?
      # 前回プレイヤーが移動中だった場合
      if last_moving
        # 同位置のイベントとの接触によるイベント起動判定
        result = check_event_trigger_here([1,2])
        # 起動したイベントがない場合
        if result == false
          # デバッグモードが ON かつ CTRL キーが押されている場合を除き
          unless $DEBUG and Input.press?(Input::CTRL)
            # エンカウント カウントダウン
            if @encounter_count > 0
              @encounter_count -= 1
            end
          end
        end
      end
      # C ボタンが押された場合
      if Input.trigger?(Input::C)
        # 同位置および正面のイベント起動判定
        check_event_trigger_here([0])
        check_event_trigger_there([0,1,2])
      end
    end
  end
end

#==============================================================================
# ■ Sprite_Character
#------------------------------------------------------------------------------
# 　キャラクター表示用のスプライトです。Game_Character クラスのインスタンスを
# 監視し、スプライトの状態を自動的に変化させます。
#==============================================================================

class Sprite_Character < RPG::Sprite
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :character                # キャラクター
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     viewport  : ビューポート
  #     character : キャラクター (Game_Character)
  #--------------------------------------------------------------------------
  def initialize(viewport, character = nil)
    super(viewport)
    @character = character
    update
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # タイル ID、ファイル名、色相のどれかが現在のものと異なる場合
    if @tile_id != @character.tile_id or
       @character_name != @character.character_name or
       @character_hue != @character.character_hue
      # タイル ID とファイル名、色相を記憶
      @tile_id = @character.tile_id
      @character_name = @character.character_name
      @character_hue = @character.character_hue
      # タイル ID が有効な値の場合
      if @tile_id >= 384
        self.bitmap = RPG::Cache.tile($game_map.tileset_name,
          @tile_id, @character.character_hue)
        self.src_rect.set(0, 0, 32, 32)
        self.ox = 16
        self.oy = 32
      # タイル ID が無効な値の場合
      else
        self.bitmap = RPG::Cache.character(@character.character_name,
          @character.character_hue)
        @cw = bitmap.width / 4
        @ch = bitmap.height / 4
        self.ox = @cw / 2
        self.oy = @ch
      end
    end
    # 可視状態を設定
    self.visible = (not @character.transparent)
    # グラフィックがキャラクターの場合
    if @tile_id == 0
      # 転送元の矩形を設定
      sx = @character.pattern * @cw
      sy = (@character.direction - 2) / 2 * @ch
      self.src_rect.set(sx, sy, @cw, @ch)
    end
    # スプライトの座標を設定
    self.x = @character.screen_x
    self.y = @character.screen_y
    self.z = @character.screen_z(@ch)
    # 不透明度、合成方法、茂み深さを設定
    self.opacity = @character.opacity
    self.blend_type = @character.blend_type
    self.bush_depth = @character.bush_depth
    # アニメーション
    if @character.animation_id != 0
      animation = $data_animations[@character.animation_id]
      animation(animation, true)
      @character.animation_id = 0
    end
  end
end

#==============================================================================
# ■ Sprite_Battler
#------------------------------------------------------------------------------
# 　バトラー表示用のスプライトです。Game_Battler クラスのインスタンスを監視し、
# スプライトの状態を自動的に変化させます。
#==============================================================================

class Sprite_Battler < RPG::Sprite
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :battler                  # バトラー
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     viewport : ビューポート
  #     battler  : バトラー (Game_Battler)
  #--------------------------------------------------------------------------
  def initialize(viewport, battler = nil)
    super(viewport)
    @battler = battler
    @battler_visible = false
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    if self.bitmap != nil
      self.bitmap.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # バトラーが nil の場合
    if @battler == nil
      self.bitmap = nil
      loop_animation(nil)
      return
    end
    # ファイル名か色相が現在のものと異なる場合
    if @battler.battler_name != @battler_name or
       @battler.battler_hue != @battler_hue
      # ビットマップを取得、設定
      @battler_name = @battler.battler_name
      @battler_hue = @battler.battler_hue
      self.bitmap = RPG::Cache.battler(@battler_name, @battler_hue)
      @width = bitmap.width
      @height = bitmap.height
      self.ox = @width / 2
      self.oy = @height
      # 戦闘不能または隠れ状態なら不透明度を 0 にする
      if @battler.dead? or @battler.hidden
        self.opacity = 0
      end
    end
    # アニメーション ID が現在のものと異なる場合
    if @battler.damage == nil and
       @battler.state_animation_id != @state_animation_id
      @state_animation_id = @battler.state_animation_id
      loop_animation($data_animations[@state_animation_id])
    end
    # 表示されるべきアクターの場合
    if @battler.is_a?(Game_Actor) and @battler_visible
      # メインフェーズでないときは不透明度をやや下げる
      if $game_temp.battle_main_phase
        self.opacity += 3 if self.opacity < 255
      else
        self.opacity -= 3 if self.opacity > 207
      end
    end
    # 明滅
    if @battler.blink
      blink_on
    else
      blink_off
    end
    # 不可視の場合
    unless @battler_visible
      # 出現
      if not @battler.hidden and not @battler.dead? and
         (@battler.damage == nil or @battler.damage_pop)
        appear
        @battler_visible = true
      end
    end
    # 可視の場合
    if @battler_visible
      # 逃走
      if @battler.hidden
        $game_system.se_play($data_system.escape_se)
        escape
        @battler_visible = false
      end
      # 白フラッシュ
      if @battler.white_flash
        whiten
        @battler.white_flash = false
      end
      # アニメーション
      if @battler.animation_id != 0
        animation = $data_animations[@battler.animation_id]
        animation(animation, @battler.animation_hit)
        @battler.animation_id = 0
      end
      # ダメージ
      if @battler.damage_pop
        damage(@battler.damage, @battler.critical)
        @battler.damage = nil
        @battler.critical = false
        @battler.damage_pop = false
      end
      # コラプス
      if @battler.damage == nil and @battler.dead?
        if @battler.is_a?(Game_Enemy)
          $game_system.se_play($data_system.enemy_collapse_se)
        else
          $game_system.se_play($data_system.actor_collapse_se)
        end
        collapse
        @battler_visible = false
      end
    end
    # スプライトの座標を設定
    self.x = @battler.screen_x
    self.y = @battler.screen_y
    self.z = @battler.screen_z
  end
end

#==============================================================================
# ■ Sprite_Picture
#------------------------------------------------------------------------------
# 　ピクチャ表示用のスプライトです。Game_Picture クラスのインスタンスを監視し、
# スプライトの状態を自動的に変化させます。
#==============================================================================

class Sprite_Picture < Sprite
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     viewport : ビューポート
  #     picture  : ピクチャ (Game_Picture)
  #--------------------------------------------------------------------------
  def initialize(viewport, picture)
    super(viewport)
    @picture = picture
    update
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    if self.bitmap != nil
      self.bitmap.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # ピクチャのファイル名が現在のものと異なる場合
    if @picture_name != @picture.name
      # ファイル名をインスタンス変数に記憶
      @picture_name = @picture.name
      # ファイル名が空でない場合
      if @picture_name != ""
        # ピクチャグラフィックを取得
        self.bitmap = RPG::Cache.picture(@picture_name)
      end
    end
    # ファイル名が空の場合
    if @picture_name == ""
      # スプライトを不可視に設定
      self.visible = false
      return
    end
    # スプライトを可視に設定
    self.visible = true
    # 転送元原点を設定
    if @picture.origin == 0
      self.ox = 0
      self.oy = 0
    else
      self.ox = self.bitmap.width / 2
      self.oy = self.bitmap.height / 2
    end
    # スプライトの座標を設定
    self.x = @picture.x
    self.y = @picture.y
    self.z = @picture.number
    # 拡大率、不透明度、ブレンド方法を設定
    self.zoom_x = @picture.zoom_x / 100.0
    self.zoom_y = @picture.zoom_y / 100.0
    self.opacity = @picture.opacity
    self.blend_type = @picture.blend_type
    # 回転角度、色調を設定
    self.angle = @picture.angle
    self.tone = @picture.tone
  end
end

#==============================================================================
# ■ Sprite_Timer
#------------------------------------------------------------------------------
# 　タイマー表示用のスプライトです。$game_system を監視し、スプライトの状態を
# 自動的に変化させます。
#==============================================================================

class Sprite_Timer < Sprite
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super
    self.bitmap = Bitmap.new(88, 48)
    self.bitmap.font.name = "Arial"
    self.bitmap.font.size = 32
    self.x = 640 - self.bitmap.width
    self.y = 0
    self.z = 500
    update
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    if self.bitmap != nil
      self.bitmap.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # タイマー作動中なら可視に設定
    self.visible = $game_system.timer_working
    # タイマーを再描画する必要がある場合
    if $game_system.timer / Graphics.frame_rate != @total_sec
      # ウィンドウ内容をクリア
      self.bitmap.clear
      # トータル秒数を計算
      @total_sec = $game_system.timer / Graphics.frame_rate
      # タイマー表示用の文字列を作成
      min = @total_sec / 60
      sec = @total_sec % 60
      text = sprintf("%02d:%02d", min, sec)
      # タイマーを描画
      self.bitmap.font.color.set(255, 255, 255)
      self.bitmap.draw_text(self.bitmap.rect, text, 1)
    end
  end
end

#==============================================================================
# ■ Spriteset_Map
#------------------------------------------------------------------------------
# 　マップ画面のスプライトやタイルマップなどをまとめたクラスです。このクラスは
# Scene_Map クラスの内部で使用されます。
#==============================================================================

class Spriteset_Map
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    # ビューポートを作成
    @viewport1 = Viewport.new(0, 0, 640, 480)
    @viewport2 = Viewport.new(0, 0, 640, 480)
    @viewport3 = Viewport.new(0, 0, 640, 480)
    @viewport2.z = 200
    @viewport3.z = 5000
    # タイルマップを作成
    @tilemap = Tilemap.new(@viewport1)
    @tilemap.tileset = RPG::Cache.tileset($game_map.tileset_name)
    for i in 0..6
      autotile_name = $game_map.autotile_names[i]
      @tilemap.autotiles[i] = RPG::Cache.autotile(autotile_name)
    end
    @tilemap.map_data = $game_map.data
    @tilemap.priorities = $game_map.priorities
    # パノラマプレーンを作成
    @panorama = Plane.new(@viewport1)
    @panorama.z = -1000
    # フォグプレーンを作成
    @fog = Plane.new(@viewport1)
    @fog.z = 3000
    # キャラクタースプライトを作成
    @character_sprites = []
    for i in $game_map.events.keys.sort
      sprite = Sprite_Character.new(@viewport1, $game_map.events[i])
      @character_sprites.push(sprite)
    end
    @character_sprites.push(Sprite_Character.new(@viewport1, $game_player))
    # 天候を作成
    @weather = RPG::Weather.new(@viewport1)
    # ピクチャを作成
    @picture_sprites = []
    for i in 1..50
      @picture_sprites.push(Sprite_Picture.new(@viewport2,
        $game_screen.pictures[i]))
    end
    # タイマースプライトを作成
    @timer_sprite = Sprite_Timer.new
    # フレーム更新
    update
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    # タイルマップを解放
    @tilemap.tileset.dispose
    for i in 0..6
      @tilemap.autotiles[i].dispose
    end
    @tilemap.dispose
    # パノラマプレーンを解放
    @panorama.dispose
    # フォグプレーンを解放
    @fog.dispose
    # キャラクタースプライトを解放
    for sprite in @character_sprites
      sprite.dispose
    end
    # 天候を解放
    @weather.dispose
    # ピクチャを解放
    for sprite in @picture_sprites
      sprite.dispose
    end
    # タイマースプライトを解放
    @timer_sprite.dispose
    # ビューポートを解放
    @viewport1.dispose
    @viewport2.dispose
    @viewport3.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # パノラマが現在のものと異なる場合
    if @panorama_name != $game_map.panorama_name or
       @panorama_hue != $game_map.panorama_hue
      @panorama_name = $game_map.panorama_name
      @panorama_hue = $game_map.panorama_hue
      if @panorama.bitmap != nil
        @panorama.bitmap.dispose
        @panorama.bitmap = nil
      end
      if @panorama_name != ""
        @panorama.bitmap = RPG::Cache.panorama(@panorama_name, @panorama_hue)
      end
      Graphics.frame_reset
    end
    # フォグが現在のものと異なる場合
    if @fog_name != $game_map.fog_name or @fog_hue != $game_map.fog_hue
      @fog_name = $game_map.fog_name
      @fog_hue = $game_map.fog_hue
      if @fog.bitmap != nil
        @fog.bitmap.dispose
        @fog.bitmap = nil
      end
      if @fog_name != ""
        @fog.bitmap = RPG::Cache.fog(@fog_name, @fog_hue)
      end
      Graphics.frame_reset
    end
    # タイルマップを更新
    @tilemap.ox = $game_map.display_x / 4
    @tilemap.oy = $game_map.display_y / 4
    @tilemap.update
    # パノラマプレーンを更新
    @panorama.ox = $game_map.display_x / 8
    @panorama.oy = $game_map.display_y / 8
    # フォグプレーンを更新
    @fog.zoom_x = $game_map.fog_zoom / 100.0
    @fog.zoom_y = $game_map.fog_zoom / 100.0
    @fog.opacity = $game_map.fog_opacity
    @fog.blend_type = $game_map.fog_blend_type
    @fog.ox = $game_map.display_x / 4 + $game_map.fog_ox
    @fog.oy = $game_map.display_y / 4 + $game_map.fog_oy
    @fog.tone = $game_map.fog_tone
    # キャラクタースプライトを更新
    for sprite in @character_sprites
      sprite.update
    end
    # 天候グラフィックを更新
    @weather.type = $game_screen.weather_type
    @weather.max = $game_screen.weather_max
    @weather.ox = $game_map.display_x / 4
    @weather.oy = $game_map.display_y / 4
    @weather.update
    # ピクチャを更新
    for sprite in @picture_sprites
      sprite.update
    end
    # タイマースプライトを更新
    @timer_sprite.update
    # 画面の色調とシェイク位置を設定
    @viewport1.tone = $game_screen.tone
    @viewport1.ox = $game_screen.shake
    # 画面のフラッシュ色を設定
    @viewport3.color = $game_screen.flash_color
    # ビューポートを更新
    @viewport1.update
    @viewport3.update
  end
end

#==============================================================================
# ■ Spriteset_Battle
#------------------------------------------------------------------------------
# 　バトル画面のスプライトをまとめたクラスです。このクラスは Scene_Battle クラ
# スの内部で使用されます。
#==============================================================================

class Spriteset_Battle
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :viewport1                # エネミー側のビューポート
  attr_reader   :viewport2                # アクター側のビューポート
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    # ビューポートを作成
    @viewport1 = Viewport.new(0, 0, 640, 320)
    @viewport2 = Viewport.new(0, 0, 640, 480)
    @viewport3 = Viewport.new(0, 0, 640, 480)
    @viewport4 = Viewport.new(0, 0, 640, 480)
    @viewport2.z = 101
    @viewport3.z = 200
    @viewport4.z = 5000
    # バトルバックスプライトを作成
    @battleback_sprite = Sprite.new(@viewport1)
    # エネミースプライトを作成
    @enemy_sprites = []
    for enemy in $game_troop.enemies.reverse
      @enemy_sprites.push(Sprite_Battler.new(@viewport1, enemy))
    end
    # アクタースプライトを作成
    @actor_sprites = []
    @actor_sprites.push(Sprite_Battler.new(@viewport2))
    @actor_sprites.push(Sprite_Battler.new(@viewport2))
    @actor_sprites.push(Sprite_Battler.new(@viewport2))
    @actor_sprites.push(Sprite_Battler.new(@viewport2))
    # 天候を作成
    @weather = RPG::Weather.new(@viewport1)
    # ピクチャスプライトを作成
    @picture_sprites = []
    for i in 51..100
      @picture_sprites.push(Sprite_Picture.new(@viewport3,
        $game_screen.pictures[i]))
    end
    # タイマースプライトを作成
    @timer_sprite = Sprite_Timer.new
    # フレーム更新
    update
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    # バトルバックビットマップが存在していたら解放
    if @battleback_sprite.bitmap != nil
      @battleback_sprite.bitmap.dispose
    end
    # バトルバックスプライトを解放
    @battleback_sprite.dispose
    # エネミースプライト、アクタースプライトを解放
    for sprite in @enemy_sprites + @actor_sprites
      sprite.dispose
    end
    # 天候を解放
    @weather.dispose
    # ピクチャスプライトを解放
    for sprite in @picture_sprites
      sprite.dispose
    end
    # タイマースプライトを解放
    @timer_sprite.dispose
    # ビューポートを解放
    @viewport1.dispose
    @viewport2.dispose
    @viewport3.dispose
    @viewport4.dispose
  end
  #--------------------------------------------------------------------------
  # ● エフェクト表示中判定
  #--------------------------------------------------------------------------
  def effect?
    # エフェクトが一つでも表示中なら true を返す
    for sprite in @enemy_sprites + @actor_sprites
      return true if sprite.effect?
    end
    return false
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # アクタースプライトの内容を更新 (アクターの入れ替えに対応)
    @actor_sprites[0].battler = $game_party.actors[0]
    @actor_sprites[1].battler = $game_party.actors[1]
    @actor_sprites[2].battler = $game_party.actors[2]
    @actor_sprites[3].battler = $game_party.actors[3]
    # バトルバックのファイル名が現在のものと違う場合
    if @battleback_name != $game_temp.battleback_name
      @battleback_name = $game_temp.battleback_name
      if @battleback_sprite.bitmap != nil
        @battleback_sprite.bitmap.dispose
      end
      @battleback_sprite.bitmap = RPG::Cache.battleback(@battleback_name)
      @battleback_sprite.src_rect.set(0, 0, 640, 320)
    end
    # バトラースプライトを更新
    for sprite in @enemy_sprites + @actor_sprites
      sprite.update
    end
    # 天候グラフィックを更新
    @weather.type = $game_screen.weather_type
    @weather.max = $game_screen.weather_max
    @weather.update
    # ピクチャスプライトを更新
    for sprite in @picture_sprites
      sprite.update
    end
    # タイマースプライトを更新
    @timer_sprite.update
    # 画面の色調とシェイク位置を設定
    @viewport1.tone = $game_screen.tone
    @viewport1.ox = $game_screen.shake
    # 画面のフラッシュ色を設定
    @viewport4.color = $game_screen.flash_color
    # ビューポートを更新
    @viewport1.update
    @viewport2.update
    @viewport4.update
  end
end

#==============================================================================
# ■ Window_Base
#------------------------------------------------------------------------------
# 　ゲーム中のすべてのウィンドウのスーパークラスです。
#==============================================================================

class Window_Base < Window
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     x      : ウィンドウの X 座標
  #     y      : ウィンドウの Y 座標
  #     width  : ウィンドウの幅
  #     height : ウィンドウの高さ
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super()
    @windowskin_name = $game_system.windowskin_name
    self.windowskin = RPG::Cache.windowskin(@windowskin_name)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.z = 100
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    # ウィンドウ内容のビットマップが設定されていれば解放
    if self.contents != nil
      self.contents.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● 文字色取得
  #     n : 文字色番号 (0～7)
  #--------------------------------------------------------------------------
  def text_color(n)
    case n
    when 0
      return Color.new(255, 255, 255, 255)
    when 1
      return Color.new(128, 128, 255, 255)
    when 2
      return Color.new(255, 128, 128, 255)
    when 3
      return Color.new(128, 255, 128, 255)
    when 4
      return Color.new(128, 255, 255, 255)
    when 5
      return Color.new(255, 128, 255, 255)
    when 6
      return Color.new(255, 255, 128, 255)
    when 7
      return Color.new(192, 192, 192, 255)
    else
      normal_color
    end
  end
  #--------------------------------------------------------------------------
  # ● 通常文字色の取得
  #--------------------------------------------------------------------------
  def normal_color
    return Color.new(255, 255, 255, 255)
  end
  #--------------------------------------------------------------------------
  # ● 無効文字色の取得
  #--------------------------------------------------------------------------
  def disabled_color
    return Color.new(255, 255, 255, 128)
  end
  #--------------------------------------------------------------------------
  # ● システム文字色の取得
  #--------------------------------------------------------------------------
  def system_color
    return Color.new(192, 224, 255, 255)
  end
  #--------------------------------------------------------------------------
  # ● ピンチ文字色の取得
  #--------------------------------------------------------------------------
  def crisis_color
    return Color.new(255, 255, 64, 255)
  end
  #--------------------------------------------------------------------------
  # ● 戦闘不能文字色の取得
  #--------------------------------------------------------------------------
  def knockout_color
    return Color.new(255, 64, 0)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # ウィンドウスキンが変更された場合、再設定
    if $game_system.windowskin_name != @windowskin_name
      @windowskin_name = $game_system.windowskin_name
      self.windowskin = RPG::Cache.windowskin(@windowskin_name)
    end
  end
  #--------------------------------------------------------------------------
  # ● グラフィックの描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_actor_graphic(actor, x, y)
    bitmap = RPG::Cache.character(actor.character_name, actor.character_hue)
    cw = bitmap.width / 4
    ch = bitmap.height / 4
    src_rect = Rect.new(0, 0, cw, ch)
    self.contents.blt(x - cw / 2, y - ch, bitmap, src_rect)
  end
  #--------------------------------------------------------------------------
  # ● 名前の描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, x, y)
    self.contents.font.color = normal_color
    self.contents.draw_text(x, y, 120, 32, actor.name)
  end
  #--------------------------------------------------------------------------
  # ● クラスの描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_actor_class(actor, x, y)
    self.contents.font.color = normal_color
    self.contents.draw_text(x, y, 236, 32, actor.class_name)
  end
  #--------------------------------------------------------------------------
  # ● レベルの描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_actor_level(actor, x, y)
    self.contents.font.color = system_color
    self.contents.draw_text(x, y, 32, 32, "Lv")
    self.contents.font.color = normal_color
    self.contents.draw_text(x + 32, y, 24, 32, actor.level.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● 描画用のステート文字列作成
  #     actor       : アクター
  #     width       : 描画先の幅
  #     need_normal : [正常] が必要かどうか (true / false)
  #--------------------------------------------------------------------------
  def make_battler_state_text(battler, width, need_normal)
    # 括弧の幅を取得
    brackets_width = self.contents.text_size("[]").width
    # ステート名の文字列を作成
    text = ""
    for i in battler.states
      if $data_states[i].rating >= 1
        if text == ""
          text = $data_states[i].name
        else
          new_text = text + "/" + $data_states[i].name
          text_width = self.contents.text_size(new_text).width
          if text_width > width - brackets_width
            break
          end
          text = new_text
        end
      end
    end
    # ステート名の文字列が空の場合は "[正常]" にする
    if text == ""
      if need_normal
        text = "[正常]"
      end
    else
      # 括弧をつける
      text = "[" + text + "]"
    end
    # 完成した文字列を返す
    return text
  end
  #--------------------------------------------------------------------------
  # ● ステートの描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #     width : 描画先の幅
  #--------------------------------------------------------------------------
  def draw_actor_state(actor, x, y, width = 120)
    text = make_battler_state_text(actor, width, true)
    self.contents.font.color = actor.hp == 0 ? knockout_color : normal_color
    self.contents.draw_text(x, y, width, 32, text)
  end
  #--------------------------------------------------------------------------
  # ● EXP の描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_actor_exp(actor, x, y)
    self.contents.font.color = system_color
    self.contents.draw_text(x, y, 24, 32, "E")
    self.contents.font.color = normal_color
    self.contents.draw_text(x + 24, y, 84, 32, actor.exp_s, 2)
    self.contents.draw_text(x + 108, y, 12, 32, "/", 1)
    self.contents.draw_text(x + 120, y, 84, 32, actor.next_exp_s)
  end
  #--------------------------------------------------------------------------
  # ● HP の描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #     width : 描画先の幅
  #--------------------------------------------------------------------------
  def draw_actor_hp(actor, x, y, width = 144)
    # 文字列 "HP" を描画
    self.contents.font.color = system_color
    self.contents.draw_text(x, y, 32, 32, $data_system.words.hp)
    # MaxHP を描画するスペースがあるか計算
    if width - 32 >= 108
      hp_x = x + width - 108
      flag = true
    elsif width - 32 >= 48
      hp_x = x + width - 48
      flag = false
    end
    # HP を描画
    self.contents.font.color = actor.hp == 0 ? knockout_color :
      actor.hp <= actor.maxhp / 4 ? crisis_color : normal_color
    self.contents.draw_text(hp_x, y, 48, 32, actor.hp.to_s, 2)
    # MaxHP を描画
    if flag
      self.contents.font.color = normal_color
      self.contents.draw_text(hp_x + 48, y, 12, 32, "/", 1)
      self.contents.draw_text(hp_x + 60, y, 48, 32, actor.maxhp.to_s)
    end
  end
  #--------------------------------------------------------------------------
  # ● SP の描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #     width : 描画先の幅
  #--------------------------------------------------------------------------
  def draw_actor_sp(actor, x, y, width = 144)
    # 文字列 "SP" を描画
    self.contents.font.color = system_color
    self.contents.draw_text(x, y, 32, 32, $data_system.words.sp)
    # MaxSP を描画するスペースがあるか計算
    if width - 32 >= 108
      sp_x = x + width - 108
      flag = true
    elsif width - 32 >= 48
      sp_x = x + width - 48
      flag = false
    end
    # SP を描画
    self.contents.font.color = actor.sp == 0 ? knockout_color :
      actor.sp <= actor.maxsp / 4 ? crisis_color : normal_color
    self.contents.draw_text(sp_x, y, 48, 32, actor.sp.to_s, 2)
    # MaxSP を描画
    if flag
      self.contents.font.color = normal_color
      self.contents.draw_text(sp_x + 48, y, 12, 32, "/", 1)
      self.contents.draw_text(sp_x + 60, y, 48, 32, actor.maxsp.to_s)
    end
  end
  #--------------------------------------------------------------------------
  # ● パラメータの描画
  #     actor : アクター
  #     x     : 描画先 X 座標
  #     y     : 描画先 Y 座標
  #     type  : パラメータの種類 (0～6)
  #--------------------------------------------------------------------------
  def draw_actor_parameter(actor, x, y, type)
    case type
    when 0
      parameter_name = $data_system.words.atk
      parameter_value = actor.atk
    when 1
      parameter_name = $data_system.words.pdef
      parameter_value = actor.pdef
    when 2
      parameter_name = $data_system.words.mdef
      parameter_value = actor.mdef
    when 3
      parameter_name = $data_system.words.str
      parameter_value = actor.str
    when 4
      parameter_name = $data_system.words.dex
      parameter_value = actor.dex
    when 5
      parameter_name = $data_system.words.agi
      parameter_value = actor.agi
    when 6
      parameter_name = $data_system.words.int
      parameter_value = actor.int
    end
    self.contents.font.color = system_color
    self.contents.draw_text(x, y, 120, 32, parameter_name)
    self.contents.font.color = normal_color
    self.contents.draw_text(x + 120, y, 36, 32, parameter_value.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● アイテム名の描画
  #     item : アイテム
  #     x    : 描画先 X 座標
  #     y    : 描画先 Y 座標
  #--------------------------------------------------------------------------
  def draw_item_name(item, x, y)
    if item == nil
      return
    end
    bitmap = RPG::Cache.icon(item.icon_name)
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24))
    self.contents.font.color = normal_color
    self.contents.draw_text(x + 28, y, 212, 32, item.name)
  end
end

#==============================================================================
# ■ Window_Selectable
#------------------------------------------------------------------------------
# 　カーソルの移動やスクロールの機能を持つウィンドウクラスです。
#==============================================================================

class Window_Selectable < Window_Base
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :index                    # カーソル位置
  attr_reader   :help_window              # ヘルプウィンドウ
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     x      : ウィンドウの X 座標
  #     y      : ウィンドウの Y 座標
  #     width  : ウィンドウの幅
  #     height : ウィンドウの高さ
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super(x, y, width, height)
    @item_max = 1
    @column_max = 1
    @index = -1
  end
  #--------------------------------------------------------------------------
  # ● カーソル位置の設定
  #     index : 新しいカーソル位置
  #--------------------------------------------------------------------------
  def index=(index)
    @index = index
    # ヘルプテキストを更新 (update_help は継承先で定義される)
    if self.active and @help_window != nil
      update_help
    end
    # カーソルの矩形を更新
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● 行数の取得
  #--------------------------------------------------------------------------
  def row_max
    # 項目数と列数から行数を算出
    return (@item_max + @column_max - 1) / @column_max
  end
  #--------------------------------------------------------------------------
  # ● 先頭の行の取得
  #--------------------------------------------------------------------------
  def top_row
    # ウィンドウ内容の転送元 Y 座標を、1 行の高さ 32 で割る
    return self.oy / 32
  end
  #--------------------------------------------------------------------------
  # ● 先頭の行の設定
  #     row : 先頭に表示する行
  #--------------------------------------------------------------------------
  def top_row=(row)
    # row が 0 未満の場合は 0 に修正
    if row < 0
      row = 0
    end
    # row が row_max - 1 超の場合は row_max - 1 に修正
    if row > row_max - 1
      row = row_max - 1
    end
    # row に 1 行の高さ 32 を掛け、ウィンドウ内容の転送元 Y 座標とする
    self.oy = row * 32
  end
  #--------------------------------------------------------------------------
  # ● 1 ページに表示できる行数の取得
  #--------------------------------------------------------------------------
  def page_row_max
    # ウィンドウの高さから、フレームの高さ 32 を引き、1 行の高さ 32 で割る
    return (self.height - 32) / 32
  end
  #--------------------------------------------------------------------------
  # ● 1 ページに表示できる項目数の取得
  #--------------------------------------------------------------------------
  def page_item_max
    # 行数 page_row_max に 列数 @column_max を掛ける
    return page_row_max * @column_max
  end
  #--------------------------------------------------------------------------
  # ● ヘルプウィンドウの設定
  #     help_window : 新しいヘルプウィンドウ
  #--------------------------------------------------------------------------
  def help_window=(help_window)
    @help_window = help_window
    # ヘルプテキストを更新 (update_help は継承先で定義される)
    if self.active and @help_window != nil
      update_help
    end
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    # カーソル位置が 0 未満の場合
    if @index < 0
      self.cursor_rect.empty
      return
    end
    # 現在の行を取得
    row = @index / @column_max
    # 現在の行が、表示されている先頭の行より前の場合
    if row < self.top_row
      # 現在の行が先頭になるようにスクロール
      self.top_row = row
    end
    # 現在の行が、表示されている最後尾の行より後ろの場合
    if row > self.top_row + (self.page_row_max - 1)
      # 現在の行が最後尾になるようにスクロール
      self.top_row = row - (self.page_row_max - 1)
    end
    # カーソルの幅を計算
    cursor_width = self.width / @column_max - 32
    # カーソルの座標を計算
    x = @index % @column_max * (cursor_width + 32)
    y = @index / @column_max * 32 - self.oy
    # カーソルの矩形を更新
    self.cursor_rect.set(x, y, cursor_width, 32)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # カーソルの移動が可能な状態の場合
    if self.active and @item_max > 0 and @index >= 0
      # 方向ボタンの下が押された場合
      if Input.repeat?(Input::DOWN)
        # 列数が 1 かつ 方向ボタンの下の押下状態がリピートでない場合か、
        # またはカーソル位置が(項目数 - 列数)より前の場合
        if (@column_max == 1 and Input.trigger?(Input::DOWN)) or
           @index < @item_max - @column_max
          # カーソルを下に移動
          $game_system.se_play($data_system.cursor_se)
          @index = (@index + @column_max) % @item_max
        end
      end
      # 方向ボタンの上が押された場合
      if Input.repeat?(Input::UP)
        # 列数が 1 かつ 方向ボタンの上の押下状態がリピートでない場合か、
        # またはカーソル位置が列数より後ろの場合
        if (@column_max == 1 and Input.trigger?(Input::UP)) or
           @index >= @column_max
          # カーソルを上に移動
          $game_system.se_play($data_system.cursor_se)
          @index = (@index - @column_max + @item_max) % @item_max
        end
      end
      # 方向ボタンの右が押された場合
      if Input.repeat?(Input::RIGHT)
        # 列数が 2 以上で、カーソル位置が(項目数 - 1)より前の場合
        if @column_max >= 2 and @index < @item_max - 1
          # カーソルを右に移動
          $game_system.se_play($data_system.cursor_se)
          @index += 1
        end
      end
      # 方向ボタンの左が押された場合
      if Input.repeat?(Input::LEFT)
        # 列数が 2 以上で、カーソル位置が 0 より後ろの場合
        if @column_max >= 2 and @index > 0
          # カーソルを左に移動
          $game_system.se_play($data_system.cursor_se)
          @index -= 1
        end
      end
      # R ボタンが押された場合
      if Input.repeat?(Input::R)
        # 表示されている最後尾の行が、データ上の最後の行よりも前の場合
        if self.top_row + (self.page_row_max - 1) < (self.row_max - 1)
          # カーソルを 1 ページ後ろに移動
          $game_system.se_play($data_system.cursor_se)
          @index = [@index + self.page_item_max, @item_max - 1].min
          self.top_row += self.page_row_max
        end
      end
      # L ボタンが押された場合
      if Input.repeat?(Input::L)
        # 表示されている先頭の行が 0 より後ろの場合
        if self.top_row > 0
          # カーソルを 1 ページ前に移動
          $game_system.se_play($data_system.cursor_se)
          @index = [@index - self.page_item_max, 0].max
          self.top_row -= self.page_row_max
        end
      end
    end
    # ヘルプテキストを更新 (update_help は継承先で定義される)
    if self.active and @help_window != nil
      update_help
    end
    # カーソルの矩形を更新
    update_cursor_rect
  end
end

#==============================================================================
# ■ Window_Command
#------------------------------------------------------------------------------
# 　一般的なコマンド選択を行うウィンドウです。
#==============================================================================

class Window_Command < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     width    : ウィンドウの幅
  #     commands : コマンド文字列の配列
  #--------------------------------------------------------------------------
  def initialize(width, commands)
    # コマンドの個数からウィンドウの高さを算出
    super(0, 0, width, commands.size * 32 + 32)
    @item_max = commands.size
    @commands = commands
    self.contents = Bitmap.new(width - 32, @item_max * 32)
    refresh
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    for i in 0...@item_max
      draw_item(i, normal_color)
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #     color : 文字色
  #--------------------------------------------------------------------------
  def draw_item(index, color)
    self.contents.font.color = color
    rect = Rect.new(4, 32 * index, self.contents.width - 8, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    self.contents.draw_text(rect, @commands[index])
  end
  #--------------------------------------------------------------------------
  # ● 項目の無効化
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def disable_item(index)
    draw_item(index, disabled_color)
  end
end

#==============================================================================
# ■ Window_Help
#------------------------------------------------------------------------------
# 　スキルやアイテムの説明、アクターのステータスなどを表示するウィンドウです。
#==============================================================================

class Window_Help < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 640, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
  end
  #--------------------------------------------------------------------------
  # ● テキスト設定
  #     text  : ウィンドウに表示する文字列
  #     align : アラインメント (0..左揃え、1..中央揃え、2..右揃え)
  #--------------------------------------------------------------------------
  def set_text(text, align = 0)
    # テキストとアラインメントの少なくとも一方が前回と違っている場合
    if text != @text or align != @align
      # テキストを再描画
      self.contents.clear
      self.contents.font.color = normal_color
      self.contents.draw_text(4, 0, self.width - 40, 32, text, align)
      @text = text
      @align = align
      @actor = nil
    end
    self.visible = true
  end
  #--------------------------------------------------------------------------
  # ● アクター設定
  #     actor : ステータスを表示するアクター
  #--------------------------------------------------------------------------
  def set_actor(actor)
    if actor != @actor
      self.contents.clear
      draw_actor_name(actor, 4, 0)
      draw_actor_state(actor, 140, 0)
      draw_actor_hp(actor, 284, 0)
      draw_actor_sp(actor, 460, 0)
      @actor = actor
      @text = nil
      self.visible = true
    end
  end
  #--------------------------------------------------------------------------
  # ● エネミー設定
  #     enemy : 名前とステートを表示するエネミー
  #--------------------------------------------------------------------------
  def set_enemy(enemy)
    text = enemy.name
    state_text = make_battler_state_text(enemy, 112, false)
    if state_text != ""
      text += "  " + state_text
    end
    set_text(text, 1)
  end
end

#==============================================================================
# ■ Window_Gold
#------------------------------------------------------------------------------
# 　ゴールドを表示するウィンドウです。
#==============================================================================

class Window_Gold < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 160, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    cx = contents.text_size($data_system.words.gold).width
    self.contents.font.color = normal_color
    self.contents.draw_text(4, 0, 120-cx-2, 32, $game_party.gold.to_s, 2)
    self.contents.font.color = system_color
    self.contents.draw_text(124-cx, 0, cx, 32, $data_system.words.gold, 2)
  end
end

#==============================================================================
# ■ Window_PlayTime
#------------------------------------------------------------------------------
# 　メニュー画面でプレイ時間を表示するウィンドウです。
#==============================================================================

class Window_PlayTime < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 160, 96)
    self.contents = Bitmap.new(width - 32, height - 32)
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    self.contents.font.color = system_color
    self.contents.draw_text(4, 0, 120, 32, "プレイ時間")
    @total_sec = Graphics.frame_count / Graphics.frame_rate
    hour = @total_sec / 60 / 60
    min = @total_sec / 60 % 60
    sec = @total_sec % 60
    text = sprintf("%02d:%02d:%02d", hour, min, sec)
    self.contents.font.color = normal_color
    self.contents.draw_text(4, 32, 120, 32, text, 2)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    if Graphics.frame_count / Graphics.frame_rate != @total_sec
      refresh
    end
  end
end

#==============================================================================
# ■ Window_Steps
#------------------------------------------------------------------------------
# 　メニュー画面で歩数を表示するウィンドウです。
#==============================================================================

class Window_Steps < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 160, 96)
    self.contents = Bitmap.new(width - 32, height - 32)
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    self.contents.font.color = system_color
    self.contents.draw_text(4, 0, 120, 32, "歩数")
    self.contents.font.color = normal_color
    self.contents.draw_text(4, 32, 120, 32, $game_party.steps.to_s, 2)
  end
end

#==============================================================================
# ■ Window_MenuStatus
#------------------------------------------------------------------------------
# 　メニュー画面でパーティメンバーのステータスを表示するウィンドウです。
#==============================================================================

class Window_MenuStatus < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 480, 480)
    self.contents = Bitmap.new(width - 32, height - 32)
    refresh
    self.active = false
    self.index = -1
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    @item_max = $game_party.actors.size
    for i in 0...$game_party.actors.size
      x = 64
      y = i * 116
      actor = $game_party.actors[i]
      draw_actor_graphic(actor, x - 40, y + 80)
      draw_actor_name(actor, x, y)
      draw_actor_class(actor, x + 144, y)
      draw_actor_level(actor, x, y + 32)
      draw_actor_state(actor, x + 90, y + 32)
      draw_actor_exp(actor, x, y + 64)
      draw_actor_hp(actor, x + 236, y + 32)
      draw_actor_sp(actor, x + 236, y + 64)
    end
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    if @index < 0
      self.cursor_rect.empty
    else
      self.cursor_rect.set(0, @index * 116, self.width - 32, 96)
    end
  end
end

#==============================================================================
# ■ Window_Item
#------------------------------------------------------------------------------
# 　アイテム画面、バトル画面で、所持アイテムの一覧を表示するウィンドウです。
#==============================================================================

class Window_Item < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 64, 640, 416)
    @column_max = 2
    refresh
    self.index = 0
    # 戦闘中の場合はウィンドウを画面中央へ移動し、半透明にする
    if $game_temp.in_battle
      self.y = 64
      self.height = 256
      self.back_opacity = 160
    end
  end
  #--------------------------------------------------------------------------
  # ● アイテムの取得
  #--------------------------------------------------------------------------
  def item
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @data = []
    # アイテムを追加
    for i in 1...$data_items.size
      if $game_party.item_number(i) > 0
        @data.push($data_items[i])
      end
    end
    # 戦闘中以外なら武器と防具も追加
    unless $game_temp.in_battle
      for i in 1...$data_weapons.size
        if $game_party.weapon_number(i) > 0
          @data.push($data_weapons[i])
        end
      end
      for i in 1...$data_armors.size
        if $game_party.armor_number(i) > 0
          @data.push($data_armors[i])
        end
      end
    end
    # 項目数が 0 でなければビットマップを作成し、全項目を描画
    @item_max = @data.size
    if @item_max > 0
      self.contents = Bitmap.new(width - 32, row_max * 32)
      for i in 0...@item_max
        draw_item(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    case item
    when RPG::Item
      number = $game_party.item_number(item.id)
    when RPG::Weapon
      number = $game_party.weapon_number(item.id)
    when RPG::Armor
      number = $game_party.armor_number(item.id)
    end
    if item.is_a?(RPG::Item) and
       $game_party.item_can_use?(item.id)
      self.contents.font.color = normal_color
    else
      self.contents.font.color = disabled_color
    end
    x = 4 + index % 2 * (288 + 32)
    y = index / 2 * 32
    rect = Rect.new(x, y, self.width / @column_max - 32, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    bitmap = RPG::Cache.icon(item.icon_name)
    opacity = self.contents.font.color == normal_color ? 255 : 128
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24), opacity)
    self.contents.draw_text(x + 28, y, 212, 32, item.name, 0)
    self.contents.draw_text(x + 240, y, 16, 32, ":", 1)
    self.contents.draw_text(x + 256, y, 24, 32, number.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.item == nil ? "" : self.item.description)
  end
end

#==============================================================================
# ■ Window_Skill
#------------------------------------------------------------------------------
# 　スキル画面、バトル画面で、使用できるスキルの一覧を表示するウィンドウです。
#==============================================================================

class Window_Skill < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor : アクター
  #--------------------------------------------------------------------------
  def initialize(actor)
    super(0, 128, 640, 352)
    @actor = actor
    @column_max = 2
    refresh
    self.index = 0
    # 戦闘中の場合はウィンドウを画面中央へ移動し、半透明にする
    if $game_temp.in_battle
      self.y = 64
      self.height = 256
      self.back_opacity = 160
    end
  end
  #--------------------------------------------------------------------------
  # ● スキルの取得
  #--------------------------------------------------------------------------
  def skill
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @data = []
    for i in 0...@actor.skills.size
      skill = $data_skills[@actor.skills[i]]
      if skill != nil
        @data.push(skill)
      end
    end
    # 項目数が 0 でなければビットマップを作成し、全項目を描画
    @item_max = @data.size
    if @item_max > 0
      self.contents = Bitmap.new(width - 32, row_max * 32)
      for i in 0...@item_max
        draw_item(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    skill = @data[index]
    if @actor.skill_can_use?(skill.id)
      self.contents.font.color = normal_color
    else
      self.contents.font.color = disabled_color
    end
    x = 4 + index % 2 * (288 + 32)
    y = index / 2 * 32
    rect = Rect.new(x, y, self.width / @column_max - 32, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    bitmap = RPG::Cache.icon(skill.icon_name)
    opacity = self.contents.font.color == normal_color ? 255 : 128
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24), opacity)
    self.contents.draw_text(x + 28, y, 204, 32, skill.name, 0)
    self.contents.draw_text(x + 232, y, 48, 32, skill.sp_cost.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.skill == nil ? "" : self.skill.description)
  end
end

#==============================================================================
# ■ Window_SkillStatus
#------------------------------------------------------------------------------
# 　スキル画面で、スキル使用者のステータスを表示するウィンドウです。
#==============================================================================

class Window_SkillStatus < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor : アクター
  #--------------------------------------------------------------------------
  def initialize(actor)
    super(0, 64, 640, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    draw_actor_name(@actor, 4, 0)
    draw_actor_state(@actor, 140, 0)
    draw_actor_hp(@actor, 284, 0)
    draw_actor_sp(@actor, 460, 0)
  end
end

#==============================================================================
# ■ Window_Target
#------------------------------------------------------------------------------
# 　アイテム画面とスキル画面で、使用対象のアクターを選択するウィンドウです。
#==============================================================================

class Window_Target < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 336, 480)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.z += 10
    @item_max = $game_party.actors.size
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    for i in 0...$game_party.actors.size
      x = 4
      y = i * 116
      actor = $game_party.actors[i]
      draw_actor_name(actor, x, y)
      draw_actor_class(actor, x + 144, y)
      draw_actor_level(actor, x + 8, y + 32)
      draw_actor_state(actor, x + 8, y + 64)
      draw_actor_hp(actor, x + 152, y + 32)
      draw_actor_sp(actor, x + 152, y + 64)
    end
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    # カーソル位置 -1 は全選択、-2 以下は単独選択 (使用者自身)
    if @index <= -2
      self.cursor_rect.set(0, (@index + 10) * 116, self.width - 32, 96)
    elsif @index == -1
      self.cursor_rect.set(0, 0, self.width - 32, @item_max * 116 - 20)
    else
      self.cursor_rect.set(0, @index * 116, self.width - 32, 96)
    end
  end
end

#==============================================================================
# ■ Window_EquipLeft
#------------------------------------------------------------------------------
# 　装備画面で、アクターのパラメータ変化を表示するウィンドウです。
#==============================================================================

class Window_EquipLeft < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor : アクター
  #--------------------------------------------------------------------------
  def initialize(actor)
    super(0, 64, 272, 192)
    self.contents = Bitmap.new(width - 32, height - 32)
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    draw_actor_name(@actor, 4, 0)
    draw_actor_level(@actor, 4, 32)
    draw_actor_parameter(@actor, 4, 64, 0)
    draw_actor_parameter(@actor, 4, 96, 1)
    draw_actor_parameter(@actor, 4, 128, 2)
    if @new_atk != nil
      self.contents.font.color = system_color
      self.contents.draw_text(160, 64, 40, 32, "→", 1)
      self.contents.font.color = normal_color
      self.contents.draw_text(200, 64, 36, 32, @new_atk.to_s, 2)
    end
    if @new_pdef != nil
      self.contents.font.color = system_color
      self.contents.draw_text(160, 96, 40, 32, "→", 1)
      self.contents.font.color = normal_color
      self.contents.draw_text(200, 96, 36, 32, @new_pdef.to_s, 2)
    end
    if @new_mdef != nil
      self.contents.font.color = system_color
      self.contents.draw_text(160, 128, 40, 32, "→", 1)
      self.contents.font.color = normal_color
      self.contents.draw_text(200, 128, 36, 32, @new_mdef.to_s, 2)
    end
  end
  #--------------------------------------------------------------------------
  # ● 装備変更後のパラメータ設定
  #     new_atk  : 装備変更後の攻撃力
  #     new_pdef : 装備変更後の物理防御
  #     new_mdef : 装備変更後の魔法防御
  #--------------------------------------------------------------------------
  def set_new_parameters(new_atk, new_pdef, new_mdef)
    if @new_atk != new_atk or @new_pdef != new_pdef or @new_mdef != new_mdef
      @new_atk = new_atk
      @new_pdef = new_pdef
      @new_mdef = new_mdef
      refresh
    end
  end
end

#==============================================================================
# ■ Window_EquipRight
#------------------------------------------------------------------------------
# 　装備画面で、アクターが現在装備しているアイテムを表示するウィンドウです。
#==============================================================================

class Window_EquipRight < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor : アクター
  #--------------------------------------------------------------------------
  def initialize(actor)
    super(272, 64, 368, 192)
    self.contents = Bitmap.new(width - 32, height - 32)
    @actor = actor
    refresh
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● アイテムの取得
  #--------------------------------------------------------------------------
  def item
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    @data = []
    @data.push($data_weapons[@actor.weapon_id])
    @data.push($data_armors[@actor.armor1_id])
    @data.push($data_armors[@actor.armor2_id])
    @data.push($data_armors[@actor.armor3_id])
    @data.push($data_armors[@actor.armor4_id])
    @item_max = @data.size
    self.contents.font.color = system_color
    self.contents.draw_text(4, 32 * 0, 92, 32, $data_system.words.weapon)
    self.contents.draw_text(4, 32 * 1, 92, 32, $data_system.words.armor1)
    self.contents.draw_text(4, 32 * 2, 92, 32, $data_system.words.armor2)
    self.contents.draw_text(4, 32 * 3, 92, 32, $data_system.words.armor3)
    self.contents.draw_text(5, 32 * 4, 92, 32, $data_system.words.armor4)
    draw_item_name(@data[0], 92, 32 * 0)
    draw_item_name(@data[1], 92, 32 * 1)
    draw_item_name(@data[2], 92, 32 * 2)
    draw_item_name(@data[3], 92, 32 * 3)
    draw_item_name(@data[4], 92, 32 * 4)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.item == nil ? "" : self.item.description)
  end
end

#==============================================================================
# ■ Window_EquipItem
#------------------------------------------------------------------------------
# 　装備画面で、装備変更の候補となるアイテムの一覧を表示するウィンドウです。
#==============================================================================

class Window_EquipItem < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor      : アクター
  #     equip_type : 装備部位 (0～3)
  #--------------------------------------------------------------------------
  def initialize(actor, equip_type)
    super(0, 256, 640, 224)
    @actor = actor
    @equip_type = equip_type
    @column_max = 2
    refresh
    self.active = false
    self.index = -1
  end
  #--------------------------------------------------------------------------
  # ● アイテムの取得
  #--------------------------------------------------------------------------
  def item
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @data = []
    # 装備可能な武器を追加
    if @equip_type == 0
      weapon_set = $data_classes[@actor.class_id].weapon_set
      for i in 1...$data_weapons.size
        if $game_party.weapon_number(i) > 0 and weapon_set.include?(i)
          @data.push($data_weapons[i])
        end
      end
    end
    # 装備可能な防具を追加
    if @equip_type != 0
      armor_set = $data_classes[@actor.class_id].armor_set
      for i in 1...$data_armors.size
        if $game_party.armor_number(i) > 0 and armor_set.include?(i)
          if $data_armors[i].kind == @equip_type-1
            @data.push($data_armors[i])
          end
        end
      end
    end
    # 空白を追加
    @data.push(nil)
    # ビットマップを作成し、全項目を描画
    @item_max = @data.size
    self.contents = Bitmap.new(width - 32, row_max * 32)
    for i in 0...@item_max-1
      draw_item(i)
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    x = 4 + index % 2 * (288 + 32)
    y = index / 2 * 32
    case item
    when RPG::Weapon
      number = $game_party.weapon_number(item.id)
    when RPG::Armor
      number = $game_party.armor_number(item.id)
    end
    bitmap = RPG::Cache.icon(item.icon_name)
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24))
    self.contents.font.color = normal_color
    self.contents.draw_text(x + 28, y, 212, 32, item.name, 0)
    self.contents.draw_text(x + 240, y, 16, 32, ":", 1)
    self.contents.draw_text(x + 256, y, 24, 32, number.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.item == nil ? "" : self.item.description)
  end
end

#==============================================================================
# ■ Window_Status
#------------------------------------------------------------------------------
# 　ステータス画面で表示する、フル仕様のステータスウィンドウです。
#==============================================================================

class Window_Status < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor : アクター
  #--------------------------------------------------------------------------
  def initialize(actor)
    super(0, 0, 640, 480)
    self.contents = Bitmap.new(width - 32, height - 32)
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    draw_actor_graphic(@actor, 40, 112)
    draw_actor_name(@actor, 4, 0)
    draw_actor_class(@actor, 4 + 144, 0)
    draw_actor_level(@actor, 96, 32)
    draw_actor_state(@actor, 96, 64)
    draw_actor_hp(@actor, 96, 112, 172)
    draw_actor_sp(@actor, 96, 144, 172)
    draw_actor_parameter(@actor, 96, 192, 0)
    draw_actor_parameter(@actor, 96, 224, 1)
    draw_actor_parameter(@actor, 96, 256, 2)
    draw_actor_parameter(@actor, 96, 304, 3)
    draw_actor_parameter(@actor, 96, 336, 4)
    draw_actor_parameter(@actor, 96, 368, 5)
    draw_actor_parameter(@actor, 96, 400, 6)
    self.contents.font.color = system_color
    self.contents.draw_text(320, 48, 80, 32, "EXP")
    self.contents.draw_text(320, 80, 80, 32, "NEXT")
    self.contents.font.color = normal_color
    self.contents.draw_text(320 + 80, 48, 84, 32, @actor.exp_s, 2)
    self.contents.draw_text(320 + 80, 80, 84, 32, @actor.next_rest_exp_s, 2)
    self.contents.font.color = system_color
    self.contents.draw_text(320, 160, 96, 32, "装備")
    draw_item_name($data_weapons[@actor.weapon_id], 320 + 16, 208)
    draw_item_name($data_armors[@actor.armor1_id], 320 + 16, 256)
    draw_item_name($data_armors[@actor.armor2_id], 320 + 16, 304)
    draw_item_name($data_armors[@actor.armor3_id], 320 + 16, 352)
    draw_item_name($data_armors[@actor.armor4_id], 320 + 16, 400)
  end
  def dummy
    self.contents.font.color = system_color
    self.contents.draw_text(320, 112, 96, 32, $data_system.words.weapon)
    self.contents.draw_text(320, 176, 96, 32, $data_system.words.armor1)
    self.contents.draw_text(320, 240, 96, 32, $data_system.words.armor2)
    self.contents.draw_text(320, 304, 96, 32, $data_system.words.armor3)
    self.contents.draw_text(320, 368, 96, 32, $data_system.words.armor4)
    draw_item_name($data_weapons[@actor.weapon_id], 320 + 24, 144)
    draw_item_name($data_armors[@actor.armor1_id], 320 + 24, 208)
    draw_item_name($data_armors[@actor.armor2_id], 320 + 24, 272)
    draw_item_name($data_armors[@actor.armor3_id], 320 + 24, 336)
    draw_item_name($data_armors[@actor.armor4_id], 320 + 24, 400)
  end
end

#==============================================================================
# ■ Window_SaveFile
#------------------------------------------------------------------------------
# 　セーブ画面およびロード画面で表示する、セーブファイルのウィンドウです。
#==============================================================================

class Window_SaveFile < Window_Base
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :filename                 # ファイル名
  attr_reader   :selected                 # 選択状態
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     file_index : セーブファイルのインデックス (0～3)
  #     filename   : ファイル名
  #--------------------------------------------------------------------------
  def initialize(file_index, filename)
    super(0, 64 + file_index % 4 * 104, 640, 104)
    self.contents = Bitmap.new(width - 32, height - 32)
    @file_index = file_index
    @filename = "Save#{@file_index + 1}.rxdata"
    @time_stamp = Time.at(0)
    @file_exist = FileTest.exist?(@filename)
    if @file_exist
      file = File.open(@filename, "r")
      @time_stamp = file.mtime
      @characters = Marshal.load(file)
      @frame_count = Marshal.load(file)
      @game_system = Marshal.load(file)
      @game_switches = Marshal.load(file)
      @game_variables = Marshal.load(file)
      @total_sec = @frame_count / Graphics.frame_rate
      file.close
    end
    refresh
    @selected = false
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    # ファイル番号を描画
    self.contents.font.color = normal_color
    name = "ファイル #{@file_index + 1}"
    self.contents.draw_text(4, 0, 600, 32, name)
    @name_width = contents.text_size(name).width
    # セーブファイルが存在する場合
    if @file_exist
      # キャラクターを描画
      for i in 0...@characters.size
        bitmap = RPG::Cache.character(@characters[i][0], @characters[i][1])
        cw = bitmap.rect.width / 4
        ch = bitmap.rect.height / 4
        src_rect = Rect.new(0, 0, cw, ch)
        x = 300 - @characters.size * 32 + i * 64 - cw / 2
        self.contents.blt(x, 68 - ch, bitmap, src_rect)
      end
      # プレイ時間を描画
      hour = @total_sec / 60 / 60
      min = @total_sec / 60 % 60
      sec = @total_sec % 60
      time_string = sprintf("%02d:%02d:%02d", hour, min, sec)
      self.contents.font.color = normal_color
      self.contents.draw_text(4, 8, 600, 32, time_string, 2)
      # タイムスタンプを描画
      self.contents.font.color = normal_color
      time_string = @time_stamp.strftime("%Y/%m/%d %H:%M")
      self.contents.draw_text(4, 40, 600, 32, time_string, 2)
    end
  end
  #--------------------------------------------------------------------------
  # ● 選択状態の設定
  #     selected : 新しい選択状態 (true=選択 false=非選択)
  #--------------------------------------------------------------------------
  def selected=(selected)
    @selected = selected
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    if @selected
      self.cursor_rect.set(0, 0, @name_width + 8, 32)
    else
      self.cursor_rect.empty
    end
  end
end

#==============================================================================
# ■ Window_ShopCommand
#------------------------------------------------------------------------------
# 　ショップ画面で、用件を選択するウィンドウです。
#==============================================================================

class Window_ShopCommand < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 64, 480, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    @item_max = 3
    @column_max = 3
    @commands = ["購入する", "売却する", "やめる"]
    refresh
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    for i in 0...@item_max
      draw_item(i)
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    x = 4 + index * 160
    self.contents.draw_text(x, 0, 128, 32, @commands[index])
  end
end

#==============================================================================
# ■ Window_ShopBuy
#------------------------------------------------------------------------------
# 　ショップ画面で、購入できる商品の一覧を表示するウィンドウです。
#==============================================================================

class Window_ShopBuy < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     shop_goods : 商品
  #--------------------------------------------------------------------------
  def initialize(shop_goods)
    super(0, 128, 368, 352)
    @shop_goods = shop_goods
    refresh
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● アイテムの取得
  #--------------------------------------------------------------------------
  def item
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @data = []
    for goods_item in @shop_goods
      case goods_item[0]
      when 0
        item = $data_items[goods_item[1]]
      when 1
        item = $data_weapons[goods_item[1]]
      when 2
        item = $data_armors[goods_item[1]]
      end
      if item != nil
        @data.push(item)
      end
    end
    # 項目数が 0 でなければビットマップを作成し、全項目を描画
    @item_max = @data.size
    if @item_max > 0
      self.contents = Bitmap.new(width - 32, row_max * 32)
      for i in 0...@item_max
        draw_item(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    # アイテムの所持数を取得
    case item
    when RPG::Item
      number = $game_party.item_number(item.id)
    when RPG::Weapon
      number = $game_party.weapon_number(item.id)
    when RPG::Armor
      number = $game_party.armor_number(item.id)
    end
    # 価格が所持金以下、かつ所持数が 99 でなければ通常文字色に、
    # そうでなければ無効文字色に設定
    if item.price <= $game_party.gold and number < 99
      self.contents.font.color = normal_color
    else
      self.contents.font.color = disabled_color
    end
    x = 4
    y = index * 32
    rect = Rect.new(x, y, self.width - 32, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    bitmap = RPG::Cache.icon(item.icon_name)
    opacity = self.contents.font.color == normal_color ? 255 : 128
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24), opacity)
    self.contents.draw_text(x + 28, y, 212, 32, item.name, 0)
    self.contents.draw_text(x + 240, y, 88, 32, item.price.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.item == nil ? "" : self.item.description)
  end
end

#==============================================================================
# ■ Window_ShopSell
#------------------------------------------------------------------------------
# 　ショップ画面で、売却のために所持アイテムの一覧を表示するウィンドウです。
#==============================================================================

class Window_ShopSell < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 128, 640, 352)
    @column_max = 2
    refresh
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● アイテムの取得
  #--------------------------------------------------------------------------
  def item
    return @data[self.index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @data = []
    for i in 1...$data_items.size
      if $game_party.item_number(i) > 0
        @data.push($data_items[i])
      end
    end
    for i in 1...$data_weapons.size
      if $game_party.weapon_number(i) > 0
        @data.push($data_weapons[i])
      end
    end
    for i in 1...$data_armors.size
      if $game_party.armor_number(i) > 0
        @data.push($data_armors[i])
      end
    end
    # 項目数が 0 でなければビットマップを作成し、全項目を描画
    @item_max = @data.size
    if @item_max > 0
      self.contents = Bitmap.new(width - 32, row_max * 32)
      for i in 0...@item_max
        draw_item(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    case item
    when RPG::Item
      number = $game_party.item_number(item.id)
    when RPG::Weapon
      number = $game_party.weapon_number(item.id)
    when RPG::Armor
      number = $game_party.armor_number(item.id)
    end
    # 売却可能なら通常文字色に、そうでないなら無効文字色に設定
    if item.price > 0
      self.contents.font.color = normal_color
    else
      self.contents.font.color = disabled_color
    end
    x = 4 + index % 2 * (288 + 32)
    y = index / 2 * 32
    rect = Rect.new(x, y, self.width / @column_max - 32, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    bitmap = RPG::Cache.icon(item.icon_name)
    opacity = self.contents.font.color == normal_color ? 255 : 128
    self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24), opacity)
    self.contents.draw_text(x + 28, y, 212, 32, item.name, 0)
    self.contents.draw_text(x + 240, y, 16, 32, ":", 1)
    self.contents.draw_text(x + 256, y, 24, 32, number.to_s, 2)
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    @help_window.set_text(self.item == nil ? "" : self.item.description)
  end
end

#==============================================================================
# ■ Window_ShopNumber
#------------------------------------------------------------------------------
# 　ショップ画面で、購入または売却するアイテムの個数を入力するウィンドウです。
#==============================================================================

class Window_ShopNumber < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 128, 368, 352)
    self.contents = Bitmap.new(width - 32, height - 32)
    @item = nil
    @max = 1
    @price = 0
    @number = 1
  end
  #--------------------------------------------------------------------------
  # ● アイテム、最大個数、価格の設定
  #--------------------------------------------------------------------------
  def set(item, max, price)
    @item = item
    @max = max
    @price = price
    @number = 1
    refresh
  end
  #--------------------------------------------------------------------------
  # ● 入力された個数の設定
  #--------------------------------------------------------------------------
  def number
    return @number
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    draw_item_name(@item, 4, 96)
    self.contents.font.color = normal_color
    self.contents.draw_text(272, 96, 32, 32, "×")
    self.contents.draw_text(308, 96, 24, 32, @number.to_s, 2)
    self.cursor_rect.set(304, 96, 32, 32)
    # 合計価格と通貨単位を描画
    domination = $data_system.words.gold
    cx = contents.text_size(domination).width
    total_price = @price * @number
    self.contents.font.color = normal_color
    self.contents.draw_text(4, 160, 328-cx-2, 32, total_price.to_s, 2)
    self.contents.font.color = system_color
    self.contents.draw_text(332-cx, 160, cx, 32, domination, 2)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    if self.active
      # カーソル右 (+1)
      if Input.repeat?(Input::RIGHT) and @number < @max
        $game_system.se_play($data_system.cursor_se)
        @number += 1
        refresh
      end
      # カーソル左 (-1)
      if Input.repeat?(Input::LEFT) and @number > 1
        $game_system.se_play($data_system.cursor_se)
        @number -= 1
        refresh
      end
      # カーソル上 (+10)
      if Input.repeat?(Input::UP) and @number < @max
        $game_system.se_play($data_system.cursor_se)
        @number = [@number + 10, @max].min
        refresh
      end
      # カーソル下 (-10)
      if Input.repeat?(Input::DOWN) and @number > 1
        $game_system.se_play($data_system.cursor_se)
        @number = [@number - 10, 1].max
        refresh
      end
    end
  end
end

#==============================================================================
# ■ Window_ShopStatus
#------------------------------------------------------------------------------
# 　ショップ画面で、アイテムの所持数やアクターの装備を表示するウィンドウです。
#==============================================================================

class Window_ShopStatus < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(368, 128, 272, 352)
    self.contents = Bitmap.new(width - 32, height - 32)
    @item = nil
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    if @item == nil
      return
    end
    case @item
    when RPG::Item
      number = $game_party.item_number(@item.id)
    when RPG::Weapon
      number = $game_party.weapon_number(@item.id)
    when RPG::Armor
      number = $game_party.armor_number(@item.id)
    end
    self.contents.font.color = system_color
    self.contents.draw_text(4, 0, 200, 32, "持っている数")
    self.contents.font.color = normal_color
    self.contents.draw_text(204, 0, 32, 32, number.to_s, 2)
    if @item.is_a?(RPG::Item)
      return
    end
    # 装備品追加情報
    for i in 0...$game_party.actors.size
      # アクターを取得
      actor = $game_party.actors[i]
      # 装備可能なら通常文字色に、不可能なら無効文字色に設定
      if actor.equippable?(@item)
        self.contents.font.color = normal_color
      else
        self.contents.font.color = disabled_color
      end
      # アクターの名前を描画
      self.contents.draw_text(4, 64 + 64 * i, 120, 32, actor.name)
      # 現在の装備品を取得
      if @item.is_a?(RPG::Weapon)
        item1 = $data_weapons[actor.weapon_id]
      elsif @item.kind == 0
        item1 = $data_armors[actor.armor1_id]
      elsif @item.kind == 1
        item1 = $data_armors[actor.armor2_id]
      elsif @item.kind == 2
        item1 = $data_armors[actor.armor3_id]
      else
        item1 = $data_armors[actor.armor4_id]
      end
      # 装備可能な場合
      if actor.equippable?(@item)
        # 武器の場合
        if @item.is_a?(RPG::Weapon)
          atk1 = item1 != nil ? item1.atk : 0
          atk2 = @item != nil ? @item.atk : 0
          change = atk2 - atk1
        end
        # 防具の場合
        if @item.is_a?(RPG::Armor)
          pdef1 = item1 != nil ? item1.pdef : 0
          mdef1 = item1 != nil ? item1.mdef : 0
          pdef2 = @item != nil ? @item.pdef : 0
          mdef2 = @item != nil ? @item.mdef : 0
          change = pdef2 - pdef1 + mdef2 - mdef1
        end
        # パラメータの変化値を描画
        self.contents.draw_text(124, 64 + 64 * i, 112, 32,
          sprintf("%+d", change), 2)
      end
      # アイテムを描画
      if item1 != nil
        x = 4
        y = 64 + 64 * i + 32
        bitmap = RPG::Cache.icon(item1.icon_name)
        opacity = self.contents.font.color == normal_color ? 255 : 128
        self.contents.blt(x, y + 4, bitmap, Rect.new(0, 0, 24, 24), opacity)
        self.contents.draw_text(x + 28, y, 212, 32, item1.name)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● アイテムの設定
  #     item : 新しいアイテム
  #--------------------------------------------------------------------------
  def item=(item)
    if @item != item
      @item = item
      refresh
    end
  end
end

#==============================================================================
# ■ Window_NameEdit
#------------------------------------------------------------------------------
# 　名前入力画面で、名前を編集するウィンドウです。
#==============================================================================

class Window_NameEdit < Window_Base
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :name                     # 名前
  attr_reader   :index                    # カーソル位置
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor    : アクター
  #     max_char : 最大文字数
  #--------------------------------------------------------------------------
  def initialize(actor, max_char)
    super(0, 0, 640, 128)
    self.contents = Bitmap.new(width - 32, height - 32)
    @actor = actor
    @name = actor.name
    @max_char = max_char
    # 名前を最大文字数以内に収める
    name_array = @name.split(//)[0...@max_char]
    @name = ""
    for i in 0...name_array.size
      @name += name_array[i]
    end
    @default_name = @name
    @index = name_array.size
    refresh
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● デフォルトの名前に戻す
  #--------------------------------------------------------------------------
  def restore_default
    @name = @default_name
    @index = @name.split(//).size
    refresh
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● 文字の追加
  #     character : 追加する文字
  #--------------------------------------------------------------------------
  def add(character)
    if @index < @max_char and character != ""
      @name += character
      @index += 1
      refresh
      update_cursor_rect
    end
  end
  #--------------------------------------------------------------------------
  # ● 文字の削除
  #--------------------------------------------------------------------------
  def back
    if @index > 0
      # 一字削除
      name_array = @name.split(//)
      @name = ""
      for i in 0...name_array.size-1
        @name += name_array[i]
      end
      @index -= 1
      refresh
      update_cursor_rect
    end
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    # 名前を描画
    name_array = @name.split(//)
    for i in 0...@max_char
      c = name_array[i]
      if c == nil
        c = "＿"
      end
      x = 320 - @max_char * 14 + i * 28
      self.contents.draw_text(x, 32, 28, 32, c, 1)
    end
    # グラフィックを描画
    draw_actor_graphic(@actor, 320 - @max_char * 14 - 40, 80)
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    x = 320 - @max_char * 14 + @index * 28
    self.cursor_rect.set(x, 32, 28, 32)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    update_cursor_rect
  end
end

#==============================================================================
# ■ Window_NameInput
#------------------------------------------------------------------------------
# 　名前入力画面で、文字を選択するウィンドウです。
#==============================================================================

class Window_NameInput < Window_Base
  CHARACTER_TABLE =
  [
    "あ","い","う","え","お",
    "か","き","く","け","こ",
    "さ","し","す","せ","そ",
    "た","ち","つ","て","と",
    "な","に","ぬ","ね","の",
    "は","ひ","ふ","へ","ほ",
    "ま","み","む","め","も",
    "や", "" ,"ゆ", "" ,"よ",
    "ら","り","る","れ","ろ",
    "わ", "" ,"を", "" ,"ん",
    "が","ぎ","ぐ","げ","ご",
    "ざ","じ","ず","ぜ","ぞ",
    "だ","ぢ","づ","で","ど",
    "ば","び","ぶ","べ","ぼ",
    "ぱ","ぴ","ぷ","ぺ","ぽ",
    "ゃ","ゅ","ょ","っ","ゎ",
    "ぁ","ぃ","ぅ","ぇ","ぉ",
    "ー","・", "" , "" , "" ,
    "ア","イ","ウ","エ","オ",
    "カ","キ","ク","ケ","コ",
    "サ","シ","ス","セ","ソ",
    "タ","チ","ツ","テ","ト",
    "ナ","ニ","ヌ","ネ","ノ",
    "ハ","ヒ","フ","ヘ","ホ",
    "マ","ミ","ム","メ","モ",
    "ヤ", "" ,"ユ", "" ,"ヨ",
    "ラ","リ","ル","レ","ロ",
    "ワ", "" ,"ヲ", "" ,"ン",
    "ガ","ギ","グ","ゲ","ゴ",
    "ザ","ジ","ズ","ゼ","ゾ",
    "ダ","ヂ","ヅ","デ","ド",
    "バ","ビ","ブ","ベ","ボ",
    "パ","ピ","プ","ペ","ポ",
    "ャ","ュ","ョ","ッ","ヮ",
    "ァ","ィ","ゥ","ェ","ォ",
    "ー","・","ヴ", "" , "" ,
  ]
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 128, 640, 352)
    self.contents = Bitmap.new(width - 32, height - 32)
    @index = 0
    refresh
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● 文字の取得
  #--------------------------------------------------------------------------
  def character
    return CHARACTER_TABLE[@index]
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    for i in 0..179
      x = 4 + i / 5 / 9 * 152 + i % 5 * 28
      y = i / 5 % 9 * 32
      self.contents.draw_text(x, y, 28, 32, CHARACTER_TABLE[i], 1)
    end
    self.contents.draw_text(544, 9 * 32, 64, 32, "決定", 1)
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    # カーソル位置が [決定] の場合
    if @index >= 180
      self.cursor_rect.set(544, 9 * 32, 64, 32)
    # カーソル位置が [決定] 以外の場合
    else
      x = 4 + @index / 5 / 9 * 152 + @index % 5 * 28
      y = @index / 5 % 9 * 32
      self.cursor_rect.set(x, y, 28, 32)
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # カーソル位置が [決定] の場合
    if @index >= 180
      # カーソル下
      if Input.trigger?(Input::DOWN)
        $game_system.se_play($data_system.cursor_se)
        @index -= 180
      end
      # カーソル上
      if Input.repeat?(Input::UP)
        $game_system.se_play($data_system.cursor_se)
        @index -= 180 - 40
      end
    # カーソル位置が [決定] 以外の場合
    else
      # 方向ボタンの右が押された場合
      if Input.repeat?(Input::RIGHT)
        # 押下状態がリピートでない場合か、
        # カーソル位置が右端ではない場合
        if Input.trigger?(Input::RIGHT) or
           @index / 45 < 3 or @index % 5 < 4
          # カーソルを右に移動
          $game_system.se_play($data_system.cursor_se)
          if @index % 5 < 4
            @index += 1
          else
            @index += 45 - 4
          end
          if @index >= 180
            @index -= 180
          end
        end
      end
      # 方向ボタンの左が押された場合
      if Input.repeat?(Input::LEFT)
        # 押下状態がリピートでない場合か、
        # カーソル位置が左端ではない場合
        if Input.trigger?(Input::LEFT) or
           @index / 45 > 0 or @index % 5 > 0
          # カーソルを左に移動
          $game_system.se_play($data_system.cursor_se)
          if @index % 5 > 0
            @index -= 1
          else
            @index -= 45 - 4
          end
          if @index < 0
            @index += 180
          end
        end
      end
      # 方向ボタンの下が押された場合
      if Input.repeat?(Input::DOWN)
        # カーソルを下に移動
        $game_system.se_play($data_system.cursor_se)
        if @index % 45 < 40
          @index += 5
        else
          @index += 180 - 40
        end
      end
      # 方向ボタンの上が押された場合
      if Input.repeat?(Input::UP)
        # 押下状態がリピートでない場合か、
        # カーソル位置が上端ではない場合
        if Input.trigger?(Input::UP) or @index % 45 >= 5
          # カーソルを上に移動
          $game_system.se_play($data_system.cursor_se)
          if @index % 45 >= 5
            @index -= 5
          else
            @index += 180
          end
        end
      end
      # L ボタンか R ボタンが押された場合
      if Input.repeat?(Input::L) or Input.repeat?(Input::R)
        # ひらがな / カタカナ 移動
        $game_system.se_play($data_system.cursor_se)
        if @index / 45 < 2
          @index += 90
        else
          @index -= 90
        end
      end
    end
    update_cursor_rect
  end
end

#==============================================================================
# ■ Window_InputNumber
#------------------------------------------------------------------------------
# 　メッセージウィンドウの内部で使用する、数値入力用のウィンドウです。
#==============================================================================

class Window_InputNumber < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     digits_max : 桁数
  #--------------------------------------------------------------------------
  def initialize(digits_max)
    @digits_max = digits_max
    @number = 0
    # 数字の幅からカーソルの幅を計算 (0～9 は等幅と仮定)
    dummy_bitmap = Bitmap.new(32, 32)
    @cursor_width = dummy_bitmap.text_size("0").width + 8
    dummy_bitmap.dispose
    super(0, 0, @cursor_width * @digits_max + 32, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.z += 9999
    self.opacity = 0
    @index = 0
    refresh
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● 数値の取得
  #--------------------------------------------------------------------------
  def number
    return @number
  end
  #--------------------------------------------------------------------------
  # ● 数値の設定
  #     number : 新しい数値
  #--------------------------------------------------------------------------
  def number=(number)
    @number = [[number, 0].max, 10 ** @digits_max - 1].min
    refresh
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    self.cursor_rect.set(@index * @cursor_width, 0, @cursor_width, 32)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # 方向ボタンの上か下が押された場合
    if Input.repeat?(Input::UP) or Input.repeat?(Input::DOWN)
      $game_system.se_play($data_system.cursor_se)
      # 現在の位の数字を取得し、いったん 0 にする
      place = 10 ** (@digits_max - 1 - @index)
      n = @number / place % 10
      @number -= n * place
      # 上なら +1、下なら -1
      n = (n + 1) % 10 if Input.repeat?(Input::UP)
      n = (n + 9) % 10 if Input.repeat?(Input::DOWN)
      # 現在の位の数字を再設定
      @number += n * place
      refresh
    end
    # カーソル右
    if Input.repeat?(Input::RIGHT)
      if @digits_max >= 2
        $game_system.se_play($data_system.cursor_se)
        @index = (@index + 1) % @digits_max
      end
    end
    # カーソル左
    if Input.repeat?(Input::LEFT)
      if @digits_max >= 2
        $game_system.se_play($data_system.cursor_se)
        @index = (@index + @digits_max - 1) % @digits_max
      end
    end
    update_cursor_rect
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    self.contents.font.color = normal_color
    s = sprintf("%0*d", @digits_max, @number)
    for i in 0...@digits_max
      self.contents.draw_text(i * @cursor_width + 4, 0, 32, 32, s[i,1])
    end
  end
end

#==============================================================================
# ■ Window_Message
#------------------------------------------------------------------------------
# 　文章表示に使うメッセージウィンドウです。
#==============================================================================

class Window_Message < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(80, 304, 480, 160)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.visible = false
    self.z = 9998
    @fade_in = false
    @fade_out = false
    @contents_showing = false
    @cursor_width = 0
    self.active = false
    self.index = -1
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    terminate_message
    $game_temp.message_window_showing = false
    if @input_number_window != nil
      @input_number_window.dispose
    end
    super
  end
  #--------------------------------------------------------------------------
  # ● メッセージ終了処理
  #--------------------------------------------------------------------------
  def terminate_message
    self.active = false
    self.pause = false
    self.index = -1
    self.contents.clear
    # 表示中フラグをクリア
    @contents_showing = false
    # メッセージ コールバックを呼ぶ
    if $game_temp.message_proc != nil
      $game_temp.message_proc.call
    end
    # 文章、選択肢、数値入力に関する変数をクリア
    $game_temp.message_text = nil
    $game_temp.message_proc = nil
    $game_temp.choice_start = 99
    $game_temp.choice_max = 0
    $game_temp.choice_cancel_type = 0
    $game_temp.choice_proc = nil
    $game_temp.num_input_start = 99
    $game_temp.num_input_variable_id = 0
    $game_temp.num_input_digits_max = 0
    # ゴールドウィンドウを開放
    if @gold_window != nil
      @gold_window.dispose
      @gold_window = nil
    end
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    self.contents.font.color = normal_color
    x = y = 0
    @cursor_width = 0
    # 選択肢なら字下げを行う
    if $game_temp.choice_start == 0
      x = 8
    end
    # 表示待ちのメッセージがある場合
    if $game_temp.message_text != nil
      text = $game_temp.message_text
      # 制御文字処理
      begin
        last_text = text.clone
        text = text.gsub(/\\[Vv]\[([0-9]+)\]/) { $game_variables[$1.to_i] }
      end until text == last_text
      text = text.gsub(/\\[Nn]\[([0-9]+)\]/) do
        $game_actors[$1.to_i] != nil ? $game_actors[$1.to_i].name : ""
      end
      # 便宜上、"\\\\" を "\000" に変換
      text = text.gsub(/\\\\/) { "\000" }
      # "\\C" を "\001" に、"\\G" を "\002" に変換
      text = text.gsub(/\\[Cc]\[([0-9]+)\]/) { "\001[#{$1}]" }
      text = text.gsub(/\\[Gg]/) { "\002" }
      # c に 1 文字を取得 (文字が取得できなくなるまでループ)
      while (true)
        c = text[0]
        text = text[1..-1]
        if c == nil
          break
        end

        # \\ の場合
        if c == "\000"
          # 本来の文字に戻す
          c = "\\"
        end
        # \C[n] の場合
        if c == "\001"
          # 文字色を変更
          text = text.sub(/\[([0-9]+)\]/, "")
          color = $1.to_i
          if color >= 0 and color <= 7
            self.contents.font.color = text_color(color)
          end
          # 次の文字へ
          next
        end
        # \G の場合
        if c == "\002"
          # ゴールドウィンドウを作成
          if @gold_window == nil
            @gold_window = Window_Gold.new
            @gold_window.x = 560 - @gold_window.width
            if $game_temp.in_battle
              @gold_window.y = 192
            else
              @gold_window.y = self.y >= 128 ? 32 : 384
            end
            @gold_window.opacity = self.opacity
            @gold_window.back_opacity = self.back_opacity
          end
          # 次の文字へ
          next
        end
        # 改行文字の場合
        if c == "\n"
          # 選択肢ならカーソルの幅を更新
          if y >= $game_temp.choice_start
            @cursor_width = [@cursor_width, x].max
          end
          # y に 1 を加算
          y += 1
          x = 0
          # 選択肢なら字下げを行う
          if y >= $game_temp.choice_start
            x = 8
          end
          # 次の文字へ
          next
        end
        # 文字を描画
        self.contents.draw_text(4 + x, 32 * y, 40, 32, c)
        # x に描画した文字の幅を加算
        x += self.contents.text_size(c).width
      end
    end
    # 選択肢の場合
    if $game_temp.choice_max > 0
      @item_max = $game_temp.choice_max
      self.active = true
      self.index = 0
    end
    # 数値入力の場合
    if $game_temp.num_input_variable_id > 0
      digits_max = $game_temp.num_input_digits_max
      number = $game_variables[$game_temp.num_input_variable_id]
      @input_number_window = Window_InputNumber.new(digits_max)
      @input_number_window.number = number
      @input_number_window.x = self.x + 8
      @input_number_window.y = self.y + $game_temp.num_input_start * 32
    end
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウの位置と不透明度の設定
  #--------------------------------------------------------------------------
  def reset_window
    if $game_temp.in_battle
      self.y = 16
    else
      case $game_system.message_position
      when 0  # 上
        self.y = 16
      when 1  # 中
        self.y = 160
      when 2  # 下
        self.y = 304
      end
    end
    if $game_system.message_frame == 0
      self.opacity = 255
    else
      self.opacity = 0
    end
    self.back_opacity = 160
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # フェードインの場合
    if @fade_in
      self.contents_opacity += 24
      if @input_number_window != nil
        @input_number_window.contents_opacity += 24
      end
      if self.contents_opacity == 255
        @fade_in = false
      end
      return
    end
    # 数値入力中の場合
    if @input_number_window != nil
      @input_number_window.update
      # 決定
      if Input.trigger?(Input::C)
        $game_system.se_play($data_system.decision_se)
        $game_variables[$game_temp.num_input_variable_id] =
          @input_number_window.number
        $game_map.need_refresh = true
        # 数値入力ウィンドウを解放
        @input_number_window.dispose
        @input_number_window = nil
        terminate_message
      end
      return
    end
    # メッセージ表示中の場合
    if @contents_showing
      # 選択肢の表示中でなければポーズサインを表示
      if $game_temp.choice_max == 0
        self.pause = true
      end
      # キャンセル
      if Input.trigger?(Input::B)
        if $game_temp.choice_max > 0 and $game_temp.choice_cancel_type > 0
          $game_system.se_play($data_system.cancel_se)
          $game_temp.choice_proc.call($game_temp.choice_cancel_type - 1)
          terminate_message
        end
      end
      # 決定
      if Input.trigger?(Input::C)
        if $game_temp.choice_max > 0
          $game_system.se_play($data_system.decision_se)
          $game_temp.choice_proc.call(self.index)
        end
        terminate_message
      end
      return
    end
    # フェードアウト中以外で表示待ちのメッセージか選択肢がある場合
    if @fade_out == false and $game_temp.message_text != nil
      @contents_showing = true
      $game_temp.message_window_showing = true
      reset_window
      refresh
      Graphics.frame_reset
      self.visible = true
      self.contents_opacity = 0
      if @input_number_window != nil
        @input_number_window.contents_opacity = 0
      end
      @fade_in = true
      return
    end
    # 表示すべきメッセージがないが、ウィンドウが可視状態の場合
    if self.visible
      @fade_out = true
      self.opacity -= 48
      if self.opacity == 0
        self.visible = false
        @fade_out = false
        $game_temp.message_window_showing = false
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    if @index >= 0
      n = $game_temp.choice_start + @index
      self.cursor_rect.set(8, n * 32, @cursor_width, 32)
    else
      self.cursor_rect.empty
    end
  end
end

#==============================================================================
# ■ Window_PartyCommand
#------------------------------------------------------------------------------
# 　バトル画面で、戦うか逃げるかを選択するウィンドウです。
#==============================================================================

class Window_PartyCommand < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 640, 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.back_opacity = 160
    @commands = ["戦う", "逃げる"]
    @item_max = 2
    @column_max = 2
    draw_item(0, normal_color)
    draw_item(1, $game_temp.battle_can_escape ? normal_color : disabled_color)
    self.active = false
    self.visible = false
    self.index = 0
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #     index : 項目番号
  #     color : 文字色
  #--------------------------------------------------------------------------
  def draw_item(index, color)
    self.contents.font.color = color
    rect = Rect.new(160 + index * 160 + 4, 0, 128 - 10, 32)
    self.contents.fill_rect(rect, Color.new(0, 0, 0, 0))
    self.contents.draw_text(rect, @commands[index], 1)
  end
  #--------------------------------------------------------------------------
  # ● カーソルの矩形更新
  #--------------------------------------------------------------------------
  def update_cursor_rect
    self.cursor_rect.set(160 + index * 160, 0, 128, 32)
  end
end

#==============================================================================
# ■ Window_BattleStatus
#------------------------------------------------------------------------------
# 　バトル画面でパーティメンバーのステータスを表示するウィンドウです。
#==============================================================================

class Window_BattleStatus < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 320, 640, 160)
    self.contents = Bitmap.new(width - 32, height - 32)
    @level_up_flags = [false, false, false, false]
    refresh
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    super
  end
  #--------------------------------------------------------------------------
  # ● レベルアップフラグの設定
  #     actor_index : アクターインデックス
  #--------------------------------------------------------------------------
  def level_up(actor_index)
    @level_up_flags[actor_index] = true
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    @item_max = $game_party.actors.size
    for i in 0...$game_party.actors.size
      actor = $game_party.actors[i]
      actor_x = i * 160 + 4
      draw_actor_name(actor, actor_x, 0)
      draw_actor_hp(actor, actor_x, 32, 120)
      draw_actor_sp(actor, actor_x, 64, 120)
      if @level_up_flags[i]
        self.contents.font.color = normal_color
        self.contents.draw_text(actor_x, 96, 120, 32, "LEVEL UP!")
      else
        draw_actor_state(actor, actor_x, 96)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # メインフェーズのときは不透明度をやや下げる
    if $game_temp.battle_main_phase
      self.contents_opacity -= 4 if self.contents_opacity > 191
    else
      self.contents_opacity += 4 if self.contents_opacity < 255
    end
  end
end

#==============================================================================
# ■ Window_BattleResult
#------------------------------------------------------------------------------
# 　バトル終了時に、獲得した EXP やゴールドなどを表示するウィンドウです。
#==============================================================================

class Window_BattleResult < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     exp       : EXP
  #     gold      : ゴールド
  #     treasures : トレジャー
  #--------------------------------------------------------------------------
  def initialize(exp, gold, treasures)
    @exp = exp
    @gold = gold
    @treasures = treasures
    super(160, 0, 320, @treasures.size * 32 + 64)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.y = 160 - height / 2
    self.back_opacity = 160
    self.visible = false
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    x = 4
    self.contents.font.color = normal_color
    cx = contents.text_size(@exp.to_s).width
    self.contents.draw_text(x, 0, cx, 32, @exp.to_s)
    x += cx + 4
    self.contents.font.color = system_color
    cx = contents.text_size("EXP").width
    self.contents.draw_text(x, 0, 64, 32, "EXP")
    x += cx + 16
    self.contents.font.color = normal_color
    cx = contents.text_size(@gold.to_s).width
    self.contents.draw_text(x, 0, cx, 32, @gold.to_s)
    x += cx + 4
    self.contents.font.color = system_color
    self.contents.draw_text(x, 0, 128, 32, $data_system.words.gold)
    y = 32
    for item in @treasures
      draw_item_name(item, 4, y)
      y += 32
    end
  end
end

#==============================================================================
# ■ Window_DebugLeft
#------------------------------------------------------------------------------
# 　デバッグ画面で、スイッチや変数のブロックを指定するウィンドウです。
#==============================================================================

class Window_DebugLeft < Window_Selectable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, 192, 480)
    self.index = 0
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    if self.contents != nil
      self.contents.dispose
      self.contents = nil
    end
    @switch_max = ($data_system.switches.size - 1 + 9) / 10
    @variable_max = ($data_system.variables.size - 1 + 9) / 10
    @item_max = @switch_max + @variable_max
    self.contents = Bitmap.new(width - 32, @item_max * 32)
    for i in 0...@switch_max
      text = sprintf("S [%04d-%04d]", i*10+1, i*10+10)
      self.contents.draw_text(4, i * 32, 152, 32, text)
    end
    for i in 0...@variable_max
      text = sprintf("V [%04d-%04d]", i*10+1, i*10+10)
      self.contents.draw_text(4, (@switch_max + i) * 32, 152, 32, text)
    end
  end
  #--------------------------------------------------------------------------
  # ● モードの取得
  #--------------------------------------------------------------------------
  def mode
    if self.index < @switch_max
      return 0
    else
      return 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 先頭に表示する ID の取得
  #--------------------------------------------------------------------------
  def top_id
    if self.index < @switch_max
      return self.index * 10 + 1
    else
      return (self.index - @switch_max) * 10 + 1
    end
  end
end

#==============================================================================
# ■ Window_DebugRight
#------------------------------------------------------------------------------
# 　デバッグ画面で、スイッチや変数を個別に表示するウィンドウです。
#==============================================================================

class Window_DebugRight < Window_Selectable
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :mode                     # モード (0:スイッチ、1:変数)
  attr_reader   :top_id                   # 先頭に表示する ID
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(192, 0, 448, 352)
    self.contents = Bitmap.new(width - 32, height - 32)
    self.index = -1
    self.active = false
    @item_max = 10
    @mode = 0
    @top_id = 1
    refresh
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    self.contents.clear
    for i in 0..9
      if @mode == 0
        name = $data_system.switches[@top_id+i]
        status = $game_switches[@top_id+i] ? "[ON]" : "[OFF]"
      else
        name = $data_system.variables[@top_id+i]
        status = $game_variables[@top_id+i].to_s
      end
      if name == nil
        name = ''
      end
      id_text = sprintf("%04d:", @top_id+i)
      width = self.contents.text_size(id_text).width
      self.contents.draw_text(4, i * 32, width, 32, id_text)
      self.contents.draw_text(12 + width, i * 32, 296 - width, 32, name)
      self.contents.draw_text(312, i * 32, 100, 32, status, 2)
    end
  end
  #--------------------------------------------------------------------------
  # ● モードの設定
  #     id : 新しいモード
  #--------------------------------------------------------------------------
  def mode=(mode)
    if @mode != mode
      @mode = mode
      refresh
    end
  end
  #--------------------------------------------------------------------------
  # ● 先頭に表示する ID の設定
  #     id : 新しい ID
  #--------------------------------------------------------------------------
  def top_id=(id)
    if @top_id != id
      @top_id = id
      refresh
    end
  end
end

#==============================================================================
# ■ Arrow_Base
#------------------------------------------------------------------------------
# 　バトル画面で使用するアローカーソル表示用のスプライトです。このクラスは
# Arrow_Enemy クラスと Arrow_Actor クラスのスーパークラスとして使用されます。
#==============================================================================

class Arrow_Base < Sprite
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_reader   :index                    # カーソル位置
  attr_reader   :help_window              # ヘルプウィンドウ
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     viewport : ビューポート
  #--------------------------------------------------------------------------
  def initialize(viewport)
    super(viewport)
    self.bitmap = RPG::Cache.windowskin($game_system.windowskin_name)
    self.ox = 16
    self.oy = 64
    self.z = 2500
    @blink_count = 0
    @index = 0
    @help_window = nil
    update
  end
  #--------------------------------------------------------------------------
  # ● カーソル位置の設定
  #     index : 新しいカーソル位置
  #--------------------------------------------------------------------------
  def index=(index)
    @index = index
    update
  end
  #--------------------------------------------------------------------------
  # ● ヘルプウィンドウの設定
  #     help_window : 新しいヘルプウィンドウ
  #--------------------------------------------------------------------------
  def help_window=(help_window)
    @help_window = help_window
    # ヘルプテキストを更新 (update_help は継承先で定義される)
    if @help_window != nil
      update_help
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # 点滅カウントを更新
    @blink_count = (@blink_count + 1) % 8
    # 転送元の矩形を設定
    if @blink_count < 4
      self.src_rect.set(128, 96, 32, 32)
    else
      self.src_rect.set(160, 96, 32, 32)
    end
    # ヘルプテキストを更新 (update_help は継承先で定義される)
    if @help_window != nil
      update_help
    end
  end
end

#==============================================================================
# ■ Arrow_Enemy
#------------------------------------------------------------------------------
# 　エネミーを選択させるためのアローカーソルです。このクラスは Arrow_Base クラ
# スを継承します。
#==============================================================================

class Arrow_Enemy < Arrow_Base
  #--------------------------------------------------------------------------
  # ● カーソルが指しているエネミーの取得
  #--------------------------------------------------------------------------
  def enemy
    return $game_troop.enemies[@index]
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # 存在しないエネミーを指していたら飛ばす
    $game_troop.enemies.size.times do
      break if self.enemy.exist?
      @index += 1
      @index %= $game_troop.enemies.size
    end
    # カーソル右
    if Input.repeat?(Input::RIGHT)
      $game_system.se_play($data_system.cursor_se)
      $game_troop.enemies.size.times do
        @index += 1
        @index %= $game_troop.enemies.size
        break if self.enemy.exist?
      end
    end
    # カーソル左
    if Input.repeat?(Input::LEFT)
      $game_system.se_play($data_system.cursor_se)
      $game_troop.enemies.size.times do
        @index += $game_troop.enemies.size - 1
        @index %= $game_troop.enemies.size
        break if self.enemy.exist?
      end
    end
    # スプライトの座標を設定
    if self.enemy != nil
      self.x = self.enemy.screen_x
      self.y = self.enemy.screen_y
    end
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    # ヘルプウィンドウにエネミーの名前とステートを表示
    @help_window.set_enemy(self.enemy)
  end
end

#==============================================================================
# ■ Arrow_Actor
#------------------------------------------------------------------------------
# 　アクターを選択させるためのアローカーソルです。このクラスは Arrow_Base クラ
# スを継承します。
#==============================================================================

class Arrow_Actor < Arrow_Base
  #--------------------------------------------------------------------------
  # ● カーソルが指しているアクターの取得
  #--------------------------------------------------------------------------
  def actor
    return $game_party.actors[@index]
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    # カーソル右
    if Input.repeat?(Input::RIGHT)
      $game_system.se_play($data_system.cursor_se)
      @index += 1
      @index %= $game_party.actors.size
    end
    # カーソル左
    if Input.repeat?(Input::LEFT)
      $game_system.se_play($data_system.cursor_se)
      @index += $game_party.actors.size - 1
      @index %= $game_party.actors.size
    end
    # スプライトの座標を設定
    if self.actor != nil
      self.x = self.actor.screen_x
      self.y = self.actor.screen_y
    end
  end
  #--------------------------------------------------------------------------
  # ● ヘルプテキスト更新
  #--------------------------------------------------------------------------
  def update_help
    # ヘルプウィンドウにアクターのステータスを表示
    @help_window.set_actor(self.actor)
  end
end

#==============================================================================
# ■ Interpreter (分割定義 1)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     depth : ネストの深さ
  #     main  : メインフラグ
  #--------------------------------------------------------------------------
  def initialize(depth = 0, main = false)
    @depth = depth
    @main = main
    # 深さは 100 レベルまで
    if depth > 100
      print("コモンイベントの呼び出しが上限を超えました。")
      exit
    end
    # インタプリタの内部状態をクリア
    clear
  end
  #--------------------------------------------------------------------------
  # ● クリア
  #--------------------------------------------------------------------------
  def clear
    @map_id = 0                       # 起動時のマップ ID
    @event_id = 0                     # イベント ID
    @message_waiting = false          # メッセージ終了待機中
    @move_route_waiting = false       # 移動完了待機中
    @button_input_variable_id = 0     # ボタン入力 変数 ID
    @wait_count = 0                   # ウェイトカウント
    @child_interpreter = nil          # 子インタプリタ
    @branch = {}                      # 分岐データ
  end
  #--------------------------------------------------------------------------
  # ● イベントのセットアップ
  #     list     : 実行内容
  #     event_id : イベント ID
  #--------------------------------------------------------------------------
  def setup(list, event_id)
    # インタプリタの内部状態をクリア
    clear
    # マップ ID を記憶
    @map_id = $game_map.map_id
    # イベント ID を記憶
    @event_id = event_id
    # 実行内容を記憶
    @list = list
    # インデックスを初期化
    @index = 0
    # 分岐データ用のハッシュをクリア
    @branch.clear
  end
  #--------------------------------------------------------------------------
  # ● 実行中判定
  #--------------------------------------------------------------------------
  def running?
    return @list != nil
  end
  #--------------------------------------------------------------------------
  # ● 起動中イベントのセットアップ
  #--------------------------------------------------------------------------
  def setup_starting_event
    # 必要ならマップをリフレッシュ
    if $game_map.need_refresh
      $game_map.refresh
    end
    # コモンイベントの呼び出しが予約されている場合
    if $game_temp.common_event_id > 0
      # イベントをセットアップ
      setup($data_common_events[$game_temp.common_event_id].list, 0)
      # 予約を解除
      $game_temp.common_event_id = 0
      return
    end
    # ループ (マップイベント)
    for event in $game_map.events.values
      # 起動中のイベントが見つかった場合
      if event.starting
        # 自動実行でなければ
        if event.trigger < 3
          # 起動中フラグをクリア
          event.clear_starting
          # ロック
          event.lock
        end
        # イベントをセットアップ
        setup(event.list, event.id)
        return
      end
    end
    # ループ (コモンイベント)
    for common_event in $data_common_events.compact
      # トリガーが自動実行かつ条件スイッチが ON の場合
      if common_event.trigger == 1 and
         $game_switches[common_event.switch_id] == true
        # イベントをセットアップ
        setup(common_event.list, 0)
        return
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ループカウントを初期化
    @loop_count = 0
    # ループ
    loop do
      # ループカウントに 1 加算
      @loop_count += 1
      # イベントコマンド 100 個を実行した場合
      if @loop_count > 100
        # フリーズ防止のため、Graphics.update を呼ぶ
        Graphics.update
        @loop_count = 0
      end
      # マップがイベント起動時と異なる場合
      if $game_map.map_id != @map_id
        # イベント ID を 0 にする
        @event_id = 0
      end
      # 子インタプリタが存在する場合
      if @child_interpreter != nil
        # 子インタプリタを更新
        @child_interpreter.update
        # 子インタプリタの実行が終わった場合
        unless @child_interpreter.running?
          # 子インタプリタを消去
          @child_interpreter = nil
        end
        # 子インタプリタがまだ存在する場合
        if @child_interpreter != nil
          return
        end
      end
      # メッセージ終了待機中の場合
      if @message_waiting
        return
      end
      # 移動完了待機中の場合
      if @move_route_waiting
        # プレイヤーが移動ルート強制中の場合
        if $game_player.move_route_forcing
          return
        end
        # ループ (マップイベント)
        for event in $game_map.events.values
          # このイベントが移動ルート強制中の場合
          if event.move_route_forcing
            return
          end
        end
        # 移動完了待機中フラグをクリア
        @move_route_waiting = false
      end
      # ボタン入力待機中の場合
      if @button_input_variable_id > 0
        # ボタン入力の処理を実行
        input_button
        return
      end
      # ウェイト中の場合
      if @wait_count > 0
        # ウェイトカウントを減らす
        @wait_count -= 1
        return
      end
      # アクションを強制されているバトラーが存在する場合
      if $game_temp.forcing_battler != nil
        return
      end
      # 各種画面の呼び出しフラグがセットされている場合
      if $game_temp.battle_calling or
         $game_temp.shop_calling or
         $game_temp.name_calling or
         $game_temp.menu_calling or
         $game_temp.save_calling or
         $game_temp.gameover
        return
      end
      # 実行内容リストが空の場合
      if @list == nil
        # メインのマップイベントの場合
        if @main
          # 起動中のイベントをセットアップ
          setup_starting_event
        end
        # 何もセットアップされなかった場合
        if @list == nil
          return
        end
      end
      # イベントコマンドの実行を試み、戻り値が false の場合
      if execute_command == false
        return
      end
      # インデックスを進める
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● ボタン入力
  #--------------------------------------------------------------------------
  def input_button
    # 押されたボタンを判定
    n = 0
    for i in 1..18
      if Input.trigger?(i)
        n = i
      end
    end
    # ボタンが押された場合
    if n > 0
      # 変数の値を変更
      $game_variables[@button_input_variable_id] = n
      $game_map.need_refresh = true
      # ボタン入力を終了
      @button_input_variable_id = 0
    end
  end
  #--------------------------------------------------------------------------
  # ● 選択肢のセットアップ
  #--------------------------------------------------------------------------
  def setup_choices(parameters)
    # choice_max に選択肢の項目数を設定
    $game_temp.choice_max = parameters[0].size
    # message_text に選択肢を設定
    for text in parameters[0]
      $game_temp.message_text += text + "\n"
    end
    # キャンセルの場合の処理を設定
    $game_temp.choice_cancel_type = parameters[1]
    # コールバックを設定
    current_indent = @list[@index].indent
    $game_temp.choice_proc = Proc.new { |n| @branch[current_indent] = n }
  end
  #--------------------------------------------------------------------------
  # ● アクター用イテレータ (パーティ全体を考慮)
  #     parameter : 1 以上なら ID、0 なら全体
  #--------------------------------------------------------------------------
  def iterate_actor(parameter)
    # パーティ全体の場合
    if parameter == 0
      # パーティ全体分ループ
      for actor in $game_party.actors
        # ブロックを評価
        yield actor
      end
    # アクター単体の場合
    else
      # アクターを取得
      actor = $game_actors[parameter]
      # ブロックを評価
      yield actor if actor != nil
    end
  end
  #--------------------------------------------------------------------------
  # ● エネミー用イテレータ (トループ全体を考慮)
  #     parameter : 0 以上ならインデックス、-1 なら全体
  #--------------------------------------------------------------------------
  def iterate_enemy(parameter)
    # トループ全体の場合
    if parameter == -1
      # トループ全体分ループ
      for enemy in $game_troop.enemies
        # ブロックを評価
        yield enemy
      end
    # エネミー単体の場合
    else
      # エネミーを取得
      enemy = $game_troop.enemies[parameter]
      # ブロックを評価
      yield enemy if enemy != nil
    end
  end
  #--------------------------------------------------------------------------
  # ● バトラー用イテレータ (トループ全体、パーティ全体を考慮)
  #     parameter1 : 0 ならエネミー、1 ならアクター
  #     parameter2 : 0 以上ならインデックス、-1 なら全体
  #--------------------------------------------------------------------------
  def iterate_battler(parameter1, parameter2)
    # エネミーの場合
    if parameter1 == 0
      # エネミーのイテレータを呼び出す
      iterate_enemy(parameter2) do |enemy|
        yield enemy
      end
    # アクターの場合
    else
      # パーティ全体の場合
      if parameter2 == -1
        # パーティ全体分ループ
        for actor in $game_party.actors
          # ブロックを評価
          yield actor
        end
      # アクター単体 (N 人目) の場合
      else
        # アクターを取得
        actor = $game_party.actors[parameter2]
        # ブロックを評価
        yield actor if actor != nil
      end
    end
  end
end

#==============================================================================
# ■ Interpreter (分割定義 2)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● イベントコマンドの実行
  #--------------------------------------------------------------------------
  def execute_command
    # 実行内容リストの最後に到達した場合
    if @index >= @list.size - 1
      # イベントの終了
      command_end
      # 継続
      return true
    end
    # イベントコマンドのパラメータを @parameters で参照可能に
    @parameters = @list[@index].parameters
    # コマンドコードで分岐
    case @list[@index].code
    when 101  # 文章の表示
      return command_101
    when 102  # 選択肢の表示
      return command_102
    when 402  # [**] の場合
      return command_402
    when 403  # キャンセルの場合
      return command_403
    when 103  # 数値入力の処理
      return command_103
    when 104  # 文章オプション変更
      return command_104
    when 105  # ボタン入力の処理
      return command_105
    when 106  # ウェイト
      return command_106
    when 111  # 条件分岐
      return command_111
    when 411  # それ以外の場合
      return command_411
    when 112  # ループ
      return command_112
    when 413  # 以上繰り返し
      return command_413
    when 113  # ループの中断
      return command_113
    when 115  # イベント処理の中断
      return command_115
    when 116  # イベントの一時消去
      return command_116
    when 117  # コモンイベント
      return command_117
    when 118  # ラベル
      return command_118
    when 119  # ラベルジャンプ
      return command_119
    when 121  # スイッチの操作
      return command_121
    when 122  # 変数の操作
      return command_122
    when 123  # セルフスイッチの操作
      return command_123
    when 124  # タイマーの操作
      return command_124
    when 125  # ゴールドの増減
      return command_125
    when 126  # アイテムの増減
      return command_126
    when 127  # 武器の増減
      return command_127
    when 128  # 防具の増減
      return command_128
    when 129  # アクターの入れ替え
      return command_129
    when 131  # ウィンドウスキンの変更
      return command_131
    when 132  # バトル BGM の変更
      return command_132
    when 133  # バトル終了 ME の変更
      return command_133
    when 134  # セーブ禁止の変更
      return command_134
    when 135  # メニュー禁止の変更
      return command_135
    when 136  # エンカウント禁止の変更
      return command_136
    when 201  # 場所移動
      return command_201
    when 202  # イベントの位置設定
      return command_202
    when 203  # マップのスクロール
      return command_203
    when 204  # マップの設定変更
      return command_204
    when 205  # フォグの色調変更
      return command_205
    when 206  # フォグの不透明度変更
      return command_206
    when 207  # アニメーションの表示
      return command_207
    when 208  # 透明状態の変更
      return command_208
    when 209  # 移動ルートの設定
      return command_209
    when 210  # 移動完了までウェイト
      return command_210
    when 221  # トランジション準備
      return command_221
    when 222  # トランジション実行
      return command_222
    when 223  # 画面の色調変更
      return command_223
    when 224  # 画面のフラッシュ
      return command_224
    when 225  # 画面のシェイク
      return command_225
    when 231  # ピクチャの表示
      return command_231
    when 232  # ピクチャの移動
      return command_232
    when 233  # ピクチャの回転
      return command_233
    when 234  # ピクチャの色調変更
      return command_234
    when 235  # ピクチャの消去
      return command_235
    when 236  # 天候の設定
      return command_236
    when 241  # BGM の演奏
      return command_241
    when 242  # BGM のフェードアウト
      return command_242
    when 245  # BGS の演奏
      return command_245
    when 246  # BGS のフェードアウト
      return command_246
    when 247  # BGM / BGS の記憶
      return command_247
    when 248  # BGM / BGS の復帰
      return command_248
    when 249  # ME の演奏
      return command_249
    when 250  # SE の演奏
      return command_250
    when 251  # SE の停止
      return command_251
    when 301  # バトルの処理
      return command_301
    when 601  # 勝った場合
      return command_601
    when 602  # 逃げた場合
      return command_602
    when 603  # 負けた場合
      return command_603
    when 302  # ショップの処理
      return command_302
    when 303  # 名前入力の処理
      return command_303
    when 311  # HP の増減
      return command_311
    when 312  # SP の増減
      return command_312
    when 313  # ステートの変更
      return command_313
    when 314  # 全回復
      return command_314
    when 315  # EXP の増減
      return command_315
    when 316  # レベルの増減
      return command_316
    when 317  # パラメータの増減
      return command_317
    when 318  # スキルの増減
      return command_318
    when 319  # 装備の変更
      return command_319
    when 320  # アクターの名前変更
      return command_320
    when 321  # アクターのクラス変更
      return command_321
    when 322  # アクターのグラフィック変更
      return command_322
    when 331  # エネミーの HP 増減
      return command_331
    when 332  # エネミーの SP 増減
      return command_332
    when 333  # エネミーのステート変更
      return command_333
    when 334  # エネミーの出現
      return command_334
    when 335  # エネミーの変身
      return command_335
    when 336  # エネミーの全回復
      return command_336
    when 337  # アニメーションの表示
      return command_337
    when 338  # ダメージの処理
      return command_338
    when 339  # アクションの強制
      return command_339
    when 340  # バトルの中断
      return command_340
    when 351  # メニュー画面の呼び出し
      return command_351
    when 352  # セーブ画面の呼び出し
      return command_352
    when 353  # ゲームオーバー
      return command_353
    when 354  # タイトル画面に戻す
      return command_354
    when 355  # スクリプト
      return command_355
    else      # その他
      return true
    end
  end
  #--------------------------------------------------------------------------
  # ● イベントの終了
  #--------------------------------------------------------------------------
  def command_end
    # 実行内容リストをクリア
    @list = nil
    # メインのマップイベント かつ イベント ID が有効の場合
    if @main and @event_id > 0
      # イベントのロックを解除
      $game_map.events[@event_id].unlock
    end
  end
  #--------------------------------------------------------------------------
  # ● コマンドスキップ
  #--------------------------------------------------------------------------
  def command_skip
    # インデントを取得
    indent = @list[@index].indent
    # ループ
    loop do
      # 次のイベントコマンドが同レベルのインデントの場合
      if @list[@index+1].indent == indent
        # 継続
        return true
      end
      # インデックスを進める
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● キャラクターの取得
  #     parameter : パラメータ
  #--------------------------------------------------------------------------
  def get_character(parameter)
    # パラメータで分岐
    case parameter
    when -1  # プレイヤー
      return $game_player
    when 0  # このイベント
      events = $game_map.events
      return events == nil ? nil : events[@event_id]
    else  # 特定のイベント
      events = $game_map.events
      return events == nil ? nil : events[parameter]
    end
  end
  #--------------------------------------------------------------------------
  # ● 操作する値の計算
  #     operation    : 操作
  #     operand_type : オペランドタイプ (0:定数 1:変数)
  #     operand      : オペランド (数値または変数 ID)
  #--------------------------------------------------------------------------
  def operate_value(operation, operand_type, operand)
    # オペランドを取得
    if operand_type == 0
      value = operand
    else
      value = $game_variables[operand]
    end
    # 操作が [減らす] の場合は符号を反転
    if operation == 1
      value = -value
    end
    # value を返す
    return value
  end
end

#==============================================================================
# ■ Interpreter (分割定義 3)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● 文章の表示
  #--------------------------------------------------------------------------
  def command_101
    # ほかの文章が message_text に設定済みの場合
    if $game_temp.message_text != nil
      # 終了
      return false
    end
    # メッセージ終了待機中フラグおよびコールバックを設定
    @message_waiting = true
    $game_temp.message_proc = Proc.new { @message_waiting = false }
    # message_text に 1 行目を設定
    $game_temp.message_text = @list[@index].parameters[0] + "\n"
    line_count = 1
    # ループ
    loop do
      # 次のイベントコマンドが文章 2 行目以降の場合
      if @list[@index+1].code == 401
        # message_text に 2 行目以降を追加
        $game_temp.message_text += @list[@index+1].parameters[0] + "\n"
        line_count += 1
      # イベントコマンドが文章 2 行目以降ではない場合
      else
        # 次のイベントコマンドが選択肢の表示の場合
        if @list[@index+1].code == 102
          # 選択肢が画面に収まる場合
          if @list[@index+1].parameters[0].size <= 4 - line_count
            # インデックスを進める
            @index += 1
            # 選択肢のセットアップ
            $game_temp.choice_start = line_count
            setup_choices(@list[@index].parameters)
          end
        # 次のイベントコマンドが数値入力の処理の場合
        elsif @list[@index+1].code == 103
          # 数値入力ウィンドウが画面に収まる場合
          if line_count < 4
            # インデックスを進める
            @index += 1
            # 数値入力のセットアップ
            $game_temp.num_input_start = line_count
            $game_temp.num_input_variable_id = @list[@index].parameters[0]
            $game_temp.num_input_digits_max = @list[@index].parameters[1]
          end
        end
        # 継続
        return true
      end
      # インデックスを進める
      @index += 1
    end
  end
  #--------------------------------------------------------------------------
  # ● 選択肢の表示
  #--------------------------------------------------------------------------
  def command_102
    # 文章が message_text に設定済みの場合
    if $game_temp.message_text != nil
      # 終了
      return false
    end
    # メッセージ終了待機中フラグおよびコールバックを設定
    @message_waiting = true
    $game_temp.message_proc = Proc.new { @message_waiting = false }
    # 選択肢のセットアップ
    $game_temp.message_text = ""
    $game_temp.choice_start = 0
    setup_choices(@parameters)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● [**] の場合
  #--------------------------------------------------------------------------
  def command_402
    # 該当する選択肢が選択されている場合
    if @branch[@list[@index].indent] == @parameters[0]
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● キャンセルの場合
  #--------------------------------------------------------------------------
  def command_403
    # 選択肢がキャンセルされている場合
    if @branch[@list[@index].indent] == 4
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● 数値入力の処理
  #--------------------------------------------------------------------------
  def command_103
    # 文章が message_text に設定済みの場合
    if $game_temp.message_text != nil
      # 終了
      return false
    end
    # メッセージ終了待機中フラグおよびコールバックを設定
    @message_waiting = true
    $game_temp.message_proc = Proc.new { @message_waiting = false }
    # 数値入力のセットアップ
    $game_temp.message_text = ""
    $game_temp.num_input_start = 0
    $game_temp.num_input_variable_id = @parameters[0]
    $game_temp.num_input_digits_max = @parameters[1]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 文章オプション変更
  #--------------------------------------------------------------------------
  def command_104
    # メッセージ表示中の場合
    if $game_temp.message_window_showing
      # 終了
      return false
    end
    # 各オプションを変更
    $game_system.message_position = @parameters[0]
    $game_system.message_frame = @parameters[1]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ボタン入力の処理
  #--------------------------------------------------------------------------
  def command_105
    # ボタン入力用の変数 ID を設定
    @button_input_variable_id = @parameters[0]
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● ウェイト
  #--------------------------------------------------------------------------
  def command_106
    # ウェイトカウントを設定
    @wait_count = @parameters[0] * 2
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 条件分岐
  #--------------------------------------------------------------------------
  def command_111
    # ローカル変数 result を初期化
    result = false
    # 条件判定
    case @parameters[0]
    when 0  # スイッチ
      result = ($game_switches[@parameters[1]] == (@parameters[2] == 0))
    when 1  # 変数
      value1 = $game_variables[@parameters[1]]
      if @parameters[2] == 0
        value2 = @parameters[3]
      else
        value2 = $game_variables[@parameters[3]]
      end
      case @parameters[4]
      when 0  # と同値
        result = (value1 == value2)
      when 1  # 以上
        result = (value1 >= value2)
      when 2  # 以下
        result = (value1 <= value2)
      when 3  # 超
        result = (value1 > value2)
      when 4  # 未満
        result = (value1 < value2)
      when 5  # 以外
        result = (value1 != value2)
      end
    when 2  # セルフスイッチ
      if @event_id > 0
        key = [$game_map.map_id, @event_id, @parameters[1]]
        if @parameters[2] == 0
          result = ($game_self_switches[key] == true)
        else
          result = ($game_self_switches[key] != true)
        end
      end
    when 3  # タイマー
      if $game_system.timer_working
        sec = $game_system.timer / Graphics.frame_rate
        if @parameters[2] == 0
          result = (sec >= @parameters[1])
        else
          result = (sec <= @parameters[1])
        end
      end
    when 4  # アクター
      actor = $game_actors[@parameters[1]]
      if actor != nil
        case @parameters[2]
        when 0  # パーティにいる
          result = ($game_party.actors.include?(actor))
        when 1  # 名前
          result = (actor.name == @parameters[3])
        when 2  # スキル
          result = (actor.skill_learn?(@parameters[3]))
        when 3  # 武器
          result = (actor.weapon_id == @parameters[3])
        when 4  # 防具
          result = (actor.armor1_id == @parameters[3] or
                    actor.armor2_id == @parameters[3] or
                    actor.armor3_id == @parameters[3])
        when 5  # ステート
          result = (actor.state?(@parameters[3]))
        end
      end
    when 5  # エネミー
      enemy = $game_troop.enemies[@parameters[1]]
      if enemy != nil
        case @parameters[2]
        when 0  # 出現している
          result = (enemy.exist?)
        when 1  # ステート
          result = (enemy.state?(@parameters[3]))
        end
      end
    when 6  # キャラクター
      character = get_character(@parameters[1])
      if character != nil
        result = (character.direction == @parameters[2])
      end
    when 7  # ゴールド
      if @parameters[2] == 0
        result = ($game_party.gold >= @parameters[1])
      else
        result = ($game_party.gold <= @parameters[1])
      end
    when 8  # アイテム
      result = ($game_party.item_number(@parameters[1]) > 0)
    when 9  # 武器
      result = ($game_party.weapon_number(@parameters[1]) > 0)
    when 10  # 防具
      result = ($game_party.armor_number(@parameters[1]) > 0)
    when 11  # ボタン
      result = (Input.press?(@parameters[1]))
    when 12  # スクリプト
      result = eval(@parameters[1])
    end
    # 判定結果をハッシュに格納
    @branch[@list[@index].indent] = result
    # 判定結果が真だった場合
    if @branch[@list[@index].indent] == true
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● それ以外の場合
  #--------------------------------------------------------------------------
  def command_411
    # 判定結果が偽だった場合
    if @branch[@list[@index].indent] == false
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● ループ
  #--------------------------------------------------------------------------
  def command_112
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 以上繰り返し
  #--------------------------------------------------------------------------
  def command_413
    # インデントを取得
    indent = @list[@index].indent
    # ループ
    loop do
      # インデックスを戻す
      @index -= 1
      # このイベントコマンドが同レベルのインデントの場合
      if @list[@index].indent == indent
        # 継続
        return true
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● ループの中断
  #--------------------------------------------------------------------------
  def command_113
    # インデントを取得
    indent = @list[@index].indent
    # インデックスを一時変数にコピー
    temp_index = @index
    # ループ
    loop do
      # インデックスを進める
      temp_index += 1
      # 該当するループが見つからなかった場合
      if temp_index >= @list.size-1
        # 継続
        return true
      end
      # このイベントコマンドが [以上繰り返し] かつインデントが浅い場合
      if @list[temp_index].code == 413 and @list[temp_index].indent < indent
        # インデックスを更新する
        @index = temp_index
        # 継続
        return true
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● イベント処理の中断
  #--------------------------------------------------------------------------
  def command_115
    # イベントの終了
    command_end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● イベントの一時消去
  #--------------------------------------------------------------------------
  def command_116
    # イベント ID が有効の場合
    if @event_id > 0
      # イベントを消去
      $game_map.events[@event_id].erase
    end
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● コモンイベント
  #--------------------------------------------------------------------------
  def command_117
    # コモンイベントを取得
    common_event = $data_common_events[@parameters[0]]
    # コモンイベントが有効の場合
    if common_event != nil
      # 子インタプリタを作成
      @child_interpreter = Interpreter.new(@depth + 1)
      @child_interpreter.setup(common_event.list, @event_id)
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ラベル
  #--------------------------------------------------------------------------
  def command_118
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ラベルジャンプ
  #--------------------------------------------------------------------------
  def command_119
    # ラベル名を取得
    label_name = @parameters[0]
    # 一時変数を初期化
    temp_index = 0
    # ループ
    loop do
      # 該当するラベルが見つからなかった場合
      if temp_index >= @list.size-1
        # 継続
        return true
      end
      # このイベントコマンドが指定された名前のラベルの場合
      if @list[temp_index].code == 118 and
         @list[temp_index].parameters[0] == label_name
        # インデックスを更新する
        @index = temp_index
        # 継続
        return true
      end
      # インデックスを進める
      temp_index += 1
    end
  end
end

#==============================================================================
# ■ Interpreter (分割定義 4)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● スイッチの操作
  #--------------------------------------------------------------------------
  def command_121
    # 一括操作のためにループ
    for i in @parameters[0] .. @parameters[1]
      # スイッチを変更
      $game_switches[i] = (@parameters[2] == 0)
    end
    # マップをリフレッシュ
    $game_map.need_refresh = true
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 変数の操作
  #--------------------------------------------------------------------------
  def command_122
    # 値を初期化
    value = 0
    # オペランドで分岐
    case @parameters[3]
    when 0  # 定数
      value = @parameters[4]
    when 1  # 変数
      value = $game_variables[@parameters[4]]
    when 2  # 乱数
      value = @parameters[4] + rand(@parameters[5] - @parameters[4] + 1)
    when 3  # アイテム
      value = $game_party.item_number(@parameters[4])
    when 4  # アクター
      actor = $game_actors[@parameters[4]]
      if actor != nil
        case @parameters[5]
        when 0  # レベル
          value = actor.level
        when 1  # EXP
          value = actor.exp
        when 2  # HP
          value = actor.hp
        when 3  # SP
          value = actor.sp
        when 4  # MaxHP
          value = actor.maxhp
        when 5  # MaxSP
          value = actor.maxsp
        when 6  # 腕力
          value = actor.str
        when 7  # 器用さ
          value = actor.dex
        when 8  # 素早さ
          value = actor.agi
        when 9  # 魔力
          value = actor.int
        when 10  # 攻撃力
          value = actor.atk
        when 11  # 物理防御
          value = actor.pdef
        when 12  # 魔法防御
          value = actor.mdef
        when 13  # 回避修正
          value = actor.eva
        end
      end
    when 5  # エネミー
      enemy = $game_troop.enemies[@parameters[4]]
      if enemy != nil
        case @parameters[5]
        when 0  # HP
          value = enemy.hp
        when 1  # SP
          value = enemy.sp
        when 2  # MaxHP
          value = enemy.maxhp
        when 3  # MaxSP
          value = enemy.maxsp
        when 4  # 腕力
          value = enemy.str
        when 5  # 器用さ
          value = enemy.dex
        when 6  # 素早さ
          value = enemy.agi
        when 7  # 魔力
          value = enemy.int
        when 8  # 攻撃力
          value = enemy.atk
        when 9  # 物理防御
          value = enemy.pdef
        when 10  # 魔法防御
          value = enemy.mdef
        when 11  # 回避修正
          value = enemy.eva
        end
      end
    when 6  # キャラクター
      character = get_character(@parameters[4])
      if character != nil
        case @parameters[5]
        when 0  # X 座標
          value = character.x
        when 1  # Y 座標
          value = character.y
        when 2  # 向き
          value = character.direction
        when 3  # 画面 X 座標
          value = character.screen_x
        when 4  # 画面 Y 座標
          value = character.screen_y
        when 5  # 地形タグ
          value = character.terrain_tag
        end
      end
    when 7  # その他
      case @parameters[4]
      when 0  # マップ ID
        value = $game_map.map_id
      when 1  # パーティ人数
        value = $game_party.actors.size
      when 2  # ゴールド
        value = $game_party.gold
      when 3  # 歩数
        value = $game_party.steps
      when 4  # プレイ時間
        value = Graphics.frame_count / Graphics.frame_rate
      when 5  # タイマー
        value = $game_system.timer / Graphics.frame_rate
      when 6  # セーブ回数
        value = $game_system.save_count
      end
    end
    # 一括操作のためにループ
    for i in @parameters[0] .. @parameters[1]
      # 操作で分岐
      case @parameters[2]
      when 0  # 代入
        $game_variables[i] = value
      when 1  # 加算
        $game_variables[i] += value
      when 2  # 減算
        $game_variables[i] -= value
      when 3  # 乗算
        $game_variables[i] *= value
      when 4  # 除算
        if value != 0
          $game_variables[i] /= value
        end
      when 5  # 剰余
        if value != 0
          $game_variables[i] %= value
        end
      end
      # 上限チェック
      if $game_variables[i] > 99999999
        $game_variables[i] = 99999999
      end
      # 下限チェック
      if $game_variables[i] < -99999999
        $game_variables[i] = -99999999
      end
    end
    # マップをリフレッシュ
    $game_map.need_refresh = true
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● セルフスイッチの操作
  #--------------------------------------------------------------------------
  def command_123
    # イベント ID が有効の場合
    if @event_id > 0
      # セルフスイッチのキーを作成
      key = [$game_map.map_id, @event_id, @parameters[0]]
      # セルフスイッチを変更
      $game_self_switches[key] = (@parameters[1] == 0)
    end
    # マップをリフレッシュ
    $game_map.need_refresh = true
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● タイマーの操作
  #--------------------------------------------------------------------------
  def command_124
    # 始動の場合
    if @parameters[0] == 0
      $game_system.timer = @parameters[1] * Graphics.frame_rate
      $game_system.timer_working = true
    end
    # 停止の場合
    if @parameters[0] == 1
      $game_system.timer_working = false
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ゴールドの増減
  #--------------------------------------------------------------------------
  def command_125
    # 操作する値を取得
    value = operate_value(@parameters[0], @parameters[1], @parameters[2])
    # ゴールドの増減
    $game_party.gain_gold(value)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アイテムの増減
  #--------------------------------------------------------------------------
  def command_126
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # アイテムの増減
    $game_party.gain_item(@parameters[0], value)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 武器の増減
  #--------------------------------------------------------------------------
  def command_127
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # 武器の増減
    $game_party.gain_weapon(@parameters[0], value)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 防具の増減
  #--------------------------------------------------------------------------
  def command_128
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # 防具の増減
    $game_party.gain_armor(@parameters[0], value)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アクターの入れ替え
  #--------------------------------------------------------------------------
  def command_129
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # アクターが有効の場合
    if actor != nil
      # 操作で分岐
      if @parameters[1] == 0
        if @parameters[2] == 1
          $game_actors[@parameters[0]].setup(@parameters[0])
        end
        $game_party.add_actor(@parameters[0])
      else
        $game_party.remove_actor(@parameters[0])
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウスキンの変更
  #--------------------------------------------------------------------------
  def command_131
    # ウィンドウスキン ファイル名を設定
    $game_system.windowskin_name = @parameters[0]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● バトル BGM の変更
  #--------------------------------------------------------------------------
  def command_132
    # バトル BGM を設定
    $game_system.battle_bgm = @parameters[0]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● バトル終了 ME の変更
  #--------------------------------------------------------------------------
  def command_133
    # バトル終了 ME を設定
    $game_system.battle_end_me = @parameters[0]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● セーブ禁止の変更
  #--------------------------------------------------------------------------
  def command_134
    # セーブ禁止フラグを変更
    $game_system.save_disabled = (@parameters[0] == 0)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● メニュー禁止の変更
  #--------------------------------------------------------------------------
  def command_135
    # メニュー禁止フラグを変更
    $game_system.menu_disabled = (@parameters[0] == 0)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エンカウント禁止の変更
  #--------------------------------------------------------------------------
  def command_136
    # エンカウント禁止フラグを変更
    $game_system.encounter_disabled = (@parameters[0] == 0)
    # エンカウント カウントを作成
    $game_player.make_encounter_count
    # 継続
    return true
  end
end

#==============================================================================
# ■ Interpreter (分割定義 5)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● 場所移動
  #--------------------------------------------------------------------------
  def command_201
    # 戦闘中の場合
    if $game_temp.in_battle
      # 継続
      return true
    end
    # 場所移動中、メッセージ表示中、トランジション処理中の場合
    if $game_temp.player_transferring or
       $game_temp.message_window_showing or
       $game_temp.transition_processing
      # 終了
      return false
    end
    # 場所移動フラグをセット
    $game_temp.player_transferring = true
    # 指定方法が [直接指定] の場合
    if @parameters[0] == 0
      # プレイヤーの移動先を設定
      $game_temp.player_new_map_id = @parameters[1]
      $game_temp.player_new_x = @parameters[2]
      $game_temp.player_new_y = @parameters[3]
      $game_temp.player_new_direction = @parameters[4]
    # 指定方法が [変数で指定] の場合
    else
      # プレイヤーの移動先を設定
      $game_temp.player_new_map_id = $game_variables[@parameters[1]]
      $game_temp.player_new_x = $game_variables[@parameters[2]]
      $game_temp.player_new_y = $game_variables[@parameters[3]]
      $game_temp.player_new_direction = @parameters[4]
    end
    # インデックスを進める
    @index += 1
    # フェードありの場合
    if @parameters[5] == 0
      # トランジション準備
      Graphics.freeze
      # トランジション処理中フラグをセット
      $game_temp.transition_processing = true
      $game_temp.transition_name = ""
    end
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● イベントの位置設定
  #--------------------------------------------------------------------------
  def command_202
    # 戦闘中の場合
    if $game_temp.in_battle
      # 継続
      return true
    end
    # キャラクターを取得
    character = get_character(@parameters[0])
    # キャラクターが存在しない場合
    if character == nil
      # 継続
      return true
    end
    # 指定方法が [直接指定] の場合
    if @parameters[1] == 0
      # キャラクターの位置を設定
      character.moveto(@parameters[2], @parameters[3])
    # 指定方法が [変数で指定] の場合
    elsif @parameters[1] == 1
      # キャラクターの位置を設定
      character.moveto($game_variables[@parameters[2]],
        $game_variables[@parameters[3]])
    # 指定方法が [他のイベントと交換] の場合
    else
      old_x = character.x
      old_y = character.y
      character2 = get_character(@parameters[2])
      if character2 != nil
        character.moveto(character2.x, character2.y)
        character2.moveto(old_x, old_y)
      end
    end
    # キャラクターの向きを設定
    case @parameters[4]
    when 8  # 上
      character.turn_up
    when 6  # 右
      character.turn_right
    when 2  # 下
      character.turn_down
    when 4  # 左
      character.turn_left
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● マップのスクロール
  #--------------------------------------------------------------------------
  def command_203
    # 戦闘中の場合
    if $game_temp.in_battle
      # 継続
      return true
    end
    # すでにスクロール中の場合
    if $game_map.scrolling?
      # 終了
      return false
    end
    # スクロールを開始
    $game_map.start_scroll(@parameters[0], @parameters[1], @parameters[2])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● マップの設定変更
  #--------------------------------------------------------------------------
  def command_204
    case @parameters[0]
    when 0  # パノラマ
      $game_map.panorama_name = @parameters[1]
      $game_map.panorama_hue = @parameters[2]
    when 1  # フォグ
      $game_map.fog_name = @parameters[1]
      $game_map.fog_hue = @parameters[2]
      $game_map.fog_opacity = @parameters[3]
      $game_map.fog_blend_type = @parameters[4]
      $game_map.fog_zoom = @parameters[5]
      $game_map.fog_sx = @parameters[6]
      $game_map.fog_sy = @parameters[7]
    when 2  # バトルバック
      $game_map.battleback_name = @parameters[1]
      $game_temp.battleback_name = @parameters[1]
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● フォグの色調変更
  #--------------------------------------------------------------------------
  def command_205
    # 色調変更を開始
    $game_map.start_fog_tone_change(@parameters[0], @parameters[1] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● フォグの不透明度変更
  #--------------------------------------------------------------------------
  def command_206
    # 不透明度変更を開始
    $game_map.start_fog_opacity_change(@parameters[0], @parameters[1] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アニメーションの表示
  #--------------------------------------------------------------------------
  def command_207
    # キャラクターを取得
    character = get_character(@parameters[0])
    # キャラクターが存在しない場合
    if character == nil
      # 継続
      return true
    end
    # アニメーション ID を設定
    character.animation_id = @parameters[1]
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 透明状態の変更
  #--------------------------------------------------------------------------
  def command_208
    # プレイヤーの透明状態を設定
    $game_player.transparent = (@parameters[0] == 0)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 移動ルートの設定
  #--------------------------------------------------------------------------
  def command_209
    # キャラクターを取得
    character = get_character(@parameters[0])
    # キャラクターが存在しない場合
    if character == nil
      # 継続
      return true
    end
    # 移動ルートを強制
    character.force_move_route(@parameters[1])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 移動完了までウェイト
  #--------------------------------------------------------------------------
  def command_210
    # 戦闘中でなければ
    unless $game_temp.in_battle
      # 移動完了待機中フラグをセット
      @move_route_waiting = true
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● トランジション準備
  #--------------------------------------------------------------------------
  def command_221
    # メッセージウィンドウ表示中の場合
    if $game_temp.message_window_showing
      # 終了
      return false
    end
    # トランジション準備
    Graphics.freeze
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● トランジション実行
  #--------------------------------------------------------------------------
  def command_222
    # トランジション処理中フラグがすでにセットされている場合
    if $game_temp.transition_processing
      # 終了
      return false
    end
    # トランジション処理中フラグをセット
    $game_temp.transition_processing = true
    $game_temp.transition_name = @parameters[0]
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● 画面の色調変更
  #--------------------------------------------------------------------------
  def command_223
    # 色調変更を開始
    $game_screen.start_tone_change(@parameters[0], @parameters[1] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 画面のフラッシュ
  #--------------------------------------------------------------------------
  def command_224
    # フラッシュを開始
    $game_screen.start_flash(@parameters[0], @parameters[1] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 画面のシェイク
  #--------------------------------------------------------------------------
  def command_225
    # シェイクを開始
    $game_screen.start_shake(@parameters[0], @parameters[1],
      @parameters[2] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの表示
  #--------------------------------------------------------------------------
  def command_231
    # ピクチャ番号を取得
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # 指定方法が [直接指定] の場合
    if @parameters[3] == 0
      x = @parameters[4]
      y = @parameters[5]
    # 指定方法が [変数で指定] の場合
    else
      x = $game_variables[@parameters[4]]
      y = $game_variables[@parameters[5]]
    end
    # ピクチャを表示
    $game_screen.pictures[number].show(@parameters[1], @parameters[2],
      x, y, @parameters[6], @parameters[7], @parameters[8], @parameters[9])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの移動
  #--------------------------------------------------------------------------
  def command_232
    # ピクチャ番号を取得
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # 指定方法が [直接指定] の場合
    if @parameters[3] == 0
      x = @parameters[4]
      y = @parameters[5]
    # 指定方法が [変数で指定] の場合
    else
      x = $game_variables[@parameters[4]]
      y = $game_variables[@parameters[5]]
    end
    # ピクチャを移動
    $game_screen.pictures[number].move(@parameters[1] * 2, @parameters[2],
      x, y, @parameters[6], @parameters[7], @parameters[8], @parameters[9])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの回転
  #--------------------------------------------------------------------------
  def command_233
    # ピクチャ番号を取得
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # 回転速度を設定
    $game_screen.pictures[number].rotate(@parameters[1])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの色調変更
  #--------------------------------------------------------------------------
  def command_234
    # ピクチャ番号を取得
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # 色調変更を開始
    $game_screen.pictures[number].start_tone_change(@parameters[1],
      @parameters[2] * 2)
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ピクチャの消去
  #--------------------------------------------------------------------------
  def command_235
    # ピクチャ番号を取得
    number = @parameters[0] + ($game_temp.in_battle ? 50 : 0)
    # ピクチャを消去
    $game_screen.pictures[number].erase
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 天候の設定
  #--------------------------------------------------------------------------
  def command_236
    # 天候を設定
    $game_screen.weather(@parameters[0], @parameters[1], @parameters[2])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGM の演奏
  #--------------------------------------------------------------------------
  def command_241
    # BGM を演奏
    $game_system.bgm_play(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGM のフェードアウト
  #--------------------------------------------------------------------------
  def command_242
    # BGM をフェードアウト
    $game_system.bgm_fade(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGS の演奏
  #--------------------------------------------------------------------------
  def command_245
    # BGS を演奏
    $game_system.bgs_play(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGS のフェードアウト
  #--------------------------------------------------------------------------
  def command_246
    # BGS をフェードアウト
    $game_system.bgs_fade(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGM / BGS の記憶
  #--------------------------------------------------------------------------
  def command_247
    # BGM / BGS を記憶
    $game_system.bgm_memorize
    $game_system.bgs_memorize
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● BGM / BGS の復帰
  #--------------------------------------------------------------------------
  def command_248
    # BGM / BGS を復帰
    $game_system.bgm_restore
    $game_system.bgs_restore
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ME の演奏
  #--------------------------------------------------------------------------
  def command_249
    # ME を演奏
    $game_system.me_play(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● SE の演奏
  #--------------------------------------------------------------------------
  def command_250
    # SE を演奏
    $game_system.se_play(@parameters[0])
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● SE の停止
  #--------------------------------------------------------------------------
  def command_251
    # SE を停止
    Audio.se_stop
    # 継続
    return true
  end
end

#==============================================================================
# ■ Interpreter (分割定義 6)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● バトルの処理
  #--------------------------------------------------------------------------
  def command_301
    # 無効なトループでなければ
    if $data_troops[@parameters[0]] != nil
      # バトル中断フラグをセット
      $game_temp.battle_abort = true
      # バトル呼び出しフラグをセット
      $game_temp.battle_calling = true
      $game_temp.battle_troop_id = @parameters[0]
      $game_temp.battle_can_escape = @parameters[1]
      $game_temp.battle_can_lose = @parameters[2]
      # コールバックを設定
      current_indent = @list[@index].indent
      $game_temp.battle_proc = Proc.new { |n| @branch[current_indent] = n }
    end
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● 勝った場合
  #--------------------------------------------------------------------------
  def command_601
    # バトル結果が勝ちの場合
    if @branch[@list[@index].indent] == 0
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● 逃げた場合
  #--------------------------------------------------------------------------
  def command_602
    # バトル結果が逃げの場合
    if @branch[@list[@index].indent] == 1
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● 負けた場合
  #--------------------------------------------------------------------------
  def command_603
    # バトル結果が負けの場合
    if @branch[@list[@index].indent] == 2
      # 分岐データを削除
      @branch.delete(@list[@index].indent)
      # 継続
      return true
    end
    # 条件に該当しない場合 : コマンドスキップ
    return command_skip
  end
  #--------------------------------------------------------------------------
  # ● ショップの処理
  #--------------------------------------------------------------------------
  def command_302
    # バトル中断フラグをセット
    $game_temp.battle_abort = true
    # ショップ呼び出しフラグをセット
    $game_temp.shop_calling = true
    # 商品リストに新しい項目を設定
    $game_temp.shop_goods = [@parameters]
    # ループ
    loop do
      # インデックスを進める
      @index += 1
      # 次のイベントコマンドがショップ 2 行目以降の場合
      if @list[@index].code == 605
        # 商品リストに新しい項目を追加
        $game_temp.shop_goods.push(@list[@index].parameters)
      # イベントコマンドがショップ 2 行目以降ではない場合
      else
        # 終了
        return false
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● 名前入力の処理
  #--------------------------------------------------------------------------
  def command_303
    # 無効なアクターでなければ
    if $data_actors[@parameters[0]] != nil
      # バトル中断フラグをセット
      $game_temp.battle_abort = true
      # 名前入力呼び出しフラグをセット
      $game_temp.name_calling = true
      $game_temp.name_actor_id = @parameters[0]
      $game_temp.name_max_char = @parameters[1]
    end
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● HP の増減
  #--------------------------------------------------------------------------
  def command_311
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # HP が 0 でない場合
      if actor.hp > 0
        # HP を変更 (戦闘不能が許可されていなければ 1 にする)
        if @parameters[4] == false and actor.hp + value <= 0
          actor.hp = 1
        else
          actor.hp += value
        end
      end
    end
    # ゲームオーバー判定
    $game_temp.gameover = $game_party.all_dead?
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● SP の増減
  #--------------------------------------------------------------------------
  def command_312
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # アクターの SP を変更
      actor.sp += value
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ステートの変更
  #--------------------------------------------------------------------------
  def command_313
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # ステートを変更
      if @parameters[1] == 0
        actor.add_state(@parameters[2])
      else
        actor.remove_state(@parameters[2])
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 全回復
  #--------------------------------------------------------------------------
  def command_314
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # アクターを全回復
      actor.recover_all
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● EXP の増減
  #--------------------------------------------------------------------------
  def command_315
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # アクターの EXP を変更
      actor.exp += value
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● レベルの増減
  #--------------------------------------------------------------------------
  def command_316
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_actor(@parameters[0]) do |actor|
      # アクターのレベルを変更
      actor.level += value
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● パラメータの増減
  #--------------------------------------------------------------------------
  def command_317
    # 操作する値を取得
    value = operate_value(@parameters[2], @parameters[3], @parameters[4])
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # パラメータを変更
    if actor != nil
      case @parameters[1]
      when 0  # MaxHP
        actor.maxhp += value
      when 1  # MaxSP
        actor.maxsp += value
      when 2  # 腕力
        actor.str += value
      when 3  # 器用さ
        actor.dex += value
      when 4  # 素早さ
        actor.agi += value
      when 5  # 魔力
        actor.int += value
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● スキルの増減
  #--------------------------------------------------------------------------
  def command_318
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # スキルを増減
    if actor != nil
      if @parameters[1] == 0
        actor.learn_skill(@parameters[2])
      else
        actor.forget_skill(@parameters[2])
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● 装備の変更
  #--------------------------------------------------------------------------
  def command_319
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # 装備を変更
    if actor != nil
      actor.equip(@parameters[1], @parameters[2])
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アクターの名前変更
  #--------------------------------------------------------------------------
  def command_320
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # 名前を変更
    if actor != nil
      actor.name = @parameters[1]
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アクターのクラス変更
  #--------------------------------------------------------------------------
  def command_321
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # クラスを変更
    if actor != nil
      actor.class_id = @parameters[1]
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アクターのグラフィック変更
  #--------------------------------------------------------------------------
  def command_322
    # アクターを取得
    actor = $game_actors[@parameters[0]]
    # グラフィックを変更
    if actor != nil
      actor.set_graphic(@parameters[1], @parameters[2],
        @parameters[3], @parameters[4])
    end
    # プレイヤーをリフレッシュ
    $game_player.refresh
    # 継続
    return true
  end
end

#==============================================================================
# ■ Interpreter (分割定義 7)
#------------------------------------------------------------------------------
# 　イベントコマンドを実行するインタプリタです。このクラスは Game_System クラ
# スや Game_Event クラスの内部で使用されます。
#==============================================================================

class Interpreter
  #--------------------------------------------------------------------------
  # ● エネミーの HP 増減
  #--------------------------------------------------------------------------
  def command_331
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_enemy(@parameters[0]) do |enemy|
      # HP が 0 でない場合
      if enemy.hp > 0
        # HP を変更 (戦闘不能が許可されていなければ 1 にする)
        if @parameters[4] == false and enemy.hp + value <= 0
          enemy.hp = 1
        else
          enemy.hp += value
        end
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エネミーの SP 増減
  #--------------------------------------------------------------------------
  def command_332
    # 操作する値を取得
    value = operate_value(@parameters[1], @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_enemy(@parameters[0]) do |enemy|
      # SP を変更
      enemy.sp += value
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エネミーのステート変更
  #--------------------------------------------------------------------------
  def command_333
    # イテレータで処理
    iterate_enemy(@parameters[0]) do |enemy|
      # ステートのオプション [HP 0 の状態とみなす] が有効の場合
      if $data_states[@parameters[2]].zero_hp
        # 不死身フラグをクリア
        enemy.immortal = false
      end
      # ステートを変更
      if @parameters[1] == 0
        enemy.add_state(@parameters[2])
      else
        enemy.remove_state(@parameters[2])
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エネミーの全回復
  #--------------------------------------------------------------------------
  def command_334
    # イテレータで処理
    iterate_enemy(@parameters[0]) do |enemy|
      # 全回復
      enemy.recover_all
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エネミーの出現
  #--------------------------------------------------------------------------
  def command_335
    # エネミーを取得
    enemy = $game_troop.enemies[@parameters[0]]
    # 隠れフラグをクリア
    if enemy != nil
      enemy.hidden = false
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● エネミーの変身
  #--------------------------------------------------------------------------
  def command_336
    # エネミーを取得
    enemy = $game_troop.enemies[@parameters[0]]
    # 変身処理
    if enemy != nil
      enemy.transform(@parameters[1])
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アニメーションの表示
  #--------------------------------------------------------------------------
  def command_337
    # イテレータで処理
    iterate_battler(@parameters[0], @parameters[1]) do |battler|
      # バトラーが存在する場合
      if battler.exist?
        # アニメーション ID を設定
        battler.animation_id = @parameters[2]
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● ダメージの処理
  #--------------------------------------------------------------------------
  def command_338
    # 操作する値を取得
    value = operate_value(0, @parameters[2], @parameters[3])
    # イテレータで処理
    iterate_battler(@parameters[0], @parameters[1]) do |battler|
      # バトラーが存在する場合
      if battler.exist?
        # HP を変更
        battler.hp -= value
        # 戦闘中なら
        if $game_temp.in_battle
          # ダメージを設定
          battler.damage = value
          battler.damage_pop = true
        end
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● アクションの強制
  #--------------------------------------------------------------------------
  def command_339
    # 戦闘中でなければ無視
    unless $game_temp.in_battle
      return true
    end
    # ターン数が 0 なら無視
    if $game_temp.battle_turn == 0
      return true
    end
    # イテレータで処理 (便宜的なもので、複数になることはない)
    iterate_battler(@parameters[0], @parameters[1]) do |battler|
      # バトラーが存在する場合
      if battler.exist?
        # アクションを設定
        battler.current_action.kind = @parameters[2]
        if battler.current_action.kind == 0
          battler.current_action.basic = @parameters[3]
        else
          battler.current_action.skill_id = @parameters[3]
        end
        # 行動対象を設定
        if @parameters[4] == -2
          if battler.is_a?(Game_Enemy)
            battler.current_action.decide_last_target_for_enemy
          else
            battler.current_action.decide_last_target_for_actor
          end
        elsif @parameters[4] == -1
          if battler.is_a?(Game_Enemy)
            battler.current_action.decide_random_target_for_enemy
          else
            battler.current_action.decide_random_target_for_actor
          end
        elsif @parameters[4] >= 0
          battler.current_action.target_index = @parameters[4]
        end
        # 強制フラグを設定
        battler.current_action.forcing = true
        # アクションが有効かつ [すぐに実行] の場合
        if battler.current_action.valid? and @parameters[5] == 1
          # 強制対象のバトラーを設定
          $game_temp.forcing_battler = battler
          # インデックスを進める
          @index += 1
          # 終了
          return false
        end
      end
    end
    # 継続
    return true
  end
  #--------------------------------------------------------------------------
  # ● バトルの中断
  #--------------------------------------------------------------------------
  def command_340
    # バトル中断フラグをセット
    $game_temp.battle_abort = true
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● メニュー画面の呼び出し
  #--------------------------------------------------------------------------
  def command_351
    # バトル中断フラグをセット
    $game_temp.battle_abort = true
    # メニュー呼び出しフラグをセット
    $game_temp.menu_calling = true
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● セーブ画面の呼び出し
  #--------------------------------------------------------------------------
  def command_352
    # バトル中断フラグをセット
    $game_temp.battle_abort = true
    # セーブ呼び出しフラグをセット
    $game_temp.save_calling = true
    # インデックスを進める
    @index += 1
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● ゲームオーバー
  #--------------------------------------------------------------------------
  def command_353
    # ゲームオーバーフラグをセット
    $game_temp.gameover = true
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● タイトル画面に戻す
  #--------------------------------------------------------------------------
  def command_354
    # タイトル画面に戻すフラグをセット
    $game_temp.to_title = true
    # 終了
    return false
  end
  #--------------------------------------------------------------------------
  # ● スクリプト
  #--------------------------------------------------------------------------
  def command_355
    # script に 1 行目を設定
    script = @list[@index].parameters[0] + "\n"
    # ループ
    loop do
      # 次のイベントコマンドがスクリプト 2 行目以降の場合
      if @list[@index+1].code == 655
        # script に 2 行目以降を追加
        script += @list[@index+1].parameters[0] + "\n"
      # イベントコマンドがスクリプト 2 行目以降ではない場合
      else
        # ループ中断
        break
      end
      # インデックスを進める
      @index += 1
    end
    # 評価
    result = eval(script)
    # 戻り値が false の場合
    if result == false
      # 終了
      return false
    end
    # 継続
    return true
  end
end

#==============================================================================
# ■ Scene_Title
#------------------------------------------------------------------------------
# 　タイトル画面の処理を行うクラスです。
#==============================================================================

class Scene_Title
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # 戦闘テストの場合
    if $BTEST
      battle_test
      return
    end
    # データベースをロード
    if RUBY_ENGINE == "opal"
      $data_actors        = load_data("rgss/converted/Actors.json")
      $data_classes       = load_data("rgss/converted/Classes.json")
      $data_skills        = load_data("rgss/converted/Skills.json")
      $data_items         = load_data("rgss/converted/Items.json")
      $data_weapons       = load_data("rgss/converted/Weapons.json")
      $data_armors        = load_data("rgss/converted/Armors.json")
      $data_enemies       = load_data("rgss/converted/Enemies.json")
      $data_troops        = load_data("rgss/converted/Troops.json")
      $data_states        = load_data("rgss/converted/States.json")
      $data_animations    = load_data("rgss/converted/Animations.json")
      $data_tilesets      = load_data("rgss/converted/Tilesets.json")
      $data_common_events = load_data("rgss/converted/CommonEvents.json")
      $data_system        = load_data("rgss/converted/System.json")
    else
      if RGSS_ENABLE_MARSHAL
        $data_actors        = load_data("Data/Actors.rxdata")
        $data_classes       = load_data("Data/Classes.rxdata")
        $data_skills        = load_data("Data/Skills.rxdata")
        $data_items         = load_data("Data/Items.rxdata")
        $data_weapons       = load_data("Data/Weapons.rxdata")
        $data_armors        = load_data("Data/Armors.rxdata")
        $data_enemies       = load_data("Data/Enemies.rxdata")
        $data_troops        = load_data("Data/Troops.rxdata")
        $data_states        = load_data("Data/States.rxdata")
        $data_animations    = load_data("Data/Animations.rxdata")
        $data_tilesets      = load_data("Data/Tilesets.rxdata")
        $data_common_events = load_data("Data/CommonEvents.rxdata")
        $data_system        = load_data("Data/System.rxdata")
      else
        $data_actors        = load_data("rgss/converted/Actors.json")
        $data_classes       = load_data("rgss/converted/Classes.json")
        $data_skills        = load_data("rgss/converted/Skills.json")
        $data_items         = load_data("rgss/converted/Items.json")
        $data_weapons       = load_data("rgss/converted/Weapons.json")
        $data_armors        = load_data("rgss/converted/Armors.json")
        $data_enemies       = load_data("rgss/converted/Enemies.json")
        $data_troops        = load_data("rgss/converted/Troops.json")
        $data_states        = load_data("rgss/converted/States.json")
        $data_animations    = load_data("rgss/converted/Animations.json")
        $data_tilesets      = load_data("rgss/converted/Tilesets.json")
        $data_common_events = load_data("rgss/converted/CommonEvents.json")
        $data_system        = load_data("rgss/converted/System.json")
      end
    end
    # システムオブジェクトを作成
    $game_system = Game_System.new
    # タイトルグラフィックを作成
    @sprite = Sprite.new
    @sprite.bitmap = RPG::Cache.title($data_system.title_name)
    # コマンドウィンドウを作成
    s1 = "ニューゲーム"
    s2 = "コンティニュー"
    s3 = "シャットダウン"
    @command_window = Window_Command.new(192, [s1, s2, s3])
    @command_window.back_opacity = 160
    @command_window.x = 320 - @command_window.width / 2
    @command_window.y = 288
    # # コンティニュー有効判定
    # # セーブファイルがひとつでも存在するかどうかを調べる
    # # 有効なら @continue_enabled を true、無効なら false にする
    # @continue_enabled = false
    # for i in 0..3
    #   if FileTest.exist?("Save#{i+1}.rxdata")
    #     @continue_enabled = true
    #   end
    # end
    # コンティニューが有効な場合、カーソルをコンティニューに合わせる
    # 無効な場合、コンティニューの文字をグレー表示にする
    if @continue_enabled
      @command_window.index = 1
    else
      @command_window.disable_item(1)
    end
    # タイトル BGM を演奏
    $game_system.bgm_play($data_system.title_bgm)
    # ME、BGS の演奏を停止
    Audio.me_stop
    Audio.bgs_stop
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # コマンドウィンドウを解放
    @command_window.dispose
    # タイトルグラフィックを解放
    @sprite.bitmap.dispose
    @sprite.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # コマンドウィンドウを更新
    @command_window.update
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # ニューゲーム
        command_new_game
      when 1  # コンティニュー
        command_continue
      when 2  # シャットダウン
        command_shutdown
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● コマンド : ニューゲーム
  #--------------------------------------------------------------------------
  def command_new_game
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # BGM を停止
    Audio.bgm_stop
    # プレイ時間計測用のフレームカウントをリセット
    Graphics.frame_count = 0
    # 各種ゲームオブジェクトを作成
    $game_temp          = Game_Temp.new
    $game_system        = Game_System.new
    $game_switches      = Game_Switches.new
    $game_variables     = Game_Variables.new
    $game_self_switches = Game_SelfSwitches.new
    $game_screen        = Game_Screen.new
    $game_actors        = Game_Actors.new
    $game_party         = Game_Party.new
    $game_troop         = Game_Troop.new
    $game_map           = Game_Map.new
    $game_player        = Game_Player.new
    # 初期パーティをセットアップ
    $game_party.setup_starting_members
    # 初期位置のマップをセットアップ
    $game_map.setup($data_system.start_map_id)
    # プレイヤーを初期位置に移動
    $game_player.moveto($data_system.start_x, $data_system.start_y)
    # プレイヤーをリフレッシュ
    $game_player.refresh
    # マップに設定されている BGM と BGS の自動切り替えを実行
    $game_map.autoplay
    # マップを更新 (並列イベント実行)
    $game_map.update
    # マップ画面に切り替え
    $scene = Scene_Map.new
  end
  #--------------------------------------------------------------------------
  # ● コマンド : コンティニュー
  #--------------------------------------------------------------------------
  def command_continue
    # コンティニューが無効の場合
    unless @continue_enabled
      # ブザー SE を演奏
      $game_system.se_play($data_system.buzzer_se)
      return
    end
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # ロード画面に切り替え
    $scene = Scene_Load.new
  end
  #--------------------------------------------------------------------------
  # ● コマンド : シャットダウン
  #--------------------------------------------------------------------------
  def command_shutdown
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # BGM、BGS、ME をフェードアウト
    Audio.bgm_fade(800)
    Audio.bgs_fade(800)
    Audio.me_fade(800)
    # シャットダウン
    $scene = nil
  end
  #--------------------------------------------------------------------------
  # ● 戦闘テスト
  #--------------------------------------------------------------------------
  def battle_test
    # データベース (戦闘テスト用) をロード
    $data_actors        = load_data("Data/BT_Actors.rxdata")
    $data_classes       = load_data("Data/BT_Classes.rxdata")
    $data_skills        = load_data("Data/BT_Skills.rxdata")
    $data_items         = load_data("Data/BT_Items.rxdata")
    $data_weapons       = load_data("Data/BT_Weapons.rxdata")
    $data_armors        = load_data("Data/BT_Armors.rxdata")
    $data_enemies       = load_data("Data/BT_Enemies.rxdata")
    $data_troops        = load_data("Data/BT_Troops.rxdata")
    $data_states        = load_data("Data/BT_States.rxdata")
    $data_animations    = load_data("Data/BT_Animations.rxdata")
    $data_tilesets      = load_data("Data/BT_Tilesets.rxdata")
    $data_common_events = load_data("Data/BT_CommonEvents.rxdata")
    $data_system        = load_data("Data/BT_System.rxdata")
    # プレイ時間計測用のフレームカウントをリセット
    Graphics.frame_count = 0
    # 各種ゲームオブジェクトを作成
    $game_temp          = Game_Temp.new
    $game_system        = Game_System.new
    $game_switches      = Game_Switches.new
    $game_variables     = Game_Variables.new
    $game_self_switches = Game_SelfSwitches.new
    $game_screen        = Game_Screen.new
    $game_actors        = Game_Actors.new
    $game_party         = Game_Party.new
    $game_troop         = Game_Troop.new
    $game_map           = Game_Map.new
    $game_player        = Game_Player.new
    # 戦闘テスト用のパーティをセットアップ
    $game_party.setup_battle_test_members
    # トループ ID、逃走可能フラグ、バトルバックを設定
    $game_temp.battle_troop_id = $data_system.test_troop_id
    $game_temp.battle_can_escape = true
    $game_map.battleback_name = $data_system.battleback_name
    # バトル開始 SE を演奏
    $game_system.se_play($data_system.battle_start_se)
    # バトル BGM を演奏
    $game_system.bgm_play($game_system.battle_bgm)
    # バトル画面に切り替え
    $scene = Scene_Battle.new
  end
end

#==============================================================================
# ■ Scene_Map
#------------------------------------------------------------------------------
# 　マップ画面の処理を行うクラスです。
#==============================================================================

class Scene_Map
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # スプライトセットを作成
    @spriteset = Spriteset_Map.new
    # メッセージウィンドウを作成
    @message_window = Window_Message.new
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # スプライトセットを解放
    @spriteset.dispose
    # メッセージウィンドウを解放
    @message_window.dispose
    # タイトル画面に切り替え中の場合
    if $scene.is_a?(Scene_Title)
      # 画面をフェードアウト
      Graphics.transition
      Graphics.freeze
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ループ
    loop do
      # マップ、インタプリタ、プレイヤーの順に更新
      # (この更新順序は、イベントを実行する条件が満たされているときに
      #  プレイヤーに一瞬移動する機会を与えないなどの理由で重要)
      $game_map.update
      $game_system.map_interpreter.update
      $game_player.update
      # システム (タイマー)、画面を更新
      $game_system.update
      $game_screen.update
      # プレイヤーの場所移動中でなければループを中断
      unless $game_temp.player_transferring
        break
      end
      # 場所移動を実行
      transfer_player
      # トランジション処理中の場合、ループを中断
      if $game_temp.transition_processing
        break
      end
    end
    # スプライトセットを更新
    @spriteset.update
    # メッセージウィンドウを更新
    @message_window.update
    # ゲームオーバーの場合
    if $game_temp.gameover
      # ゲームオーバー画面に切り替え
      $scene = Scene_Gameover.new
      return
    end
    # タイトル画面に戻す場合
    if $game_temp.to_title
      # タイトル画面に切り替え
      $scene = Scene_Title.new
      return
    end
    # トランジション処理中の場合
    if $game_temp.transition_processing
      # トランジション処理中フラグをクリア
      $game_temp.transition_processing = false
      # トランジション実行
      if $game_temp.transition_name == ""
        Graphics.transition(20)
      else
        Graphics.transition(40, "Graphics/Transitions/" +
          $game_temp.transition_name)
      end
    end
    # メッセージウィンドウ表示中の場合
    if $game_temp.message_window_showing
      return
    end
    # エンカウント カウントが 0 で、エンカウントリストが空ではない場合
    if $game_player.encounter_count == 0 and $game_map.encounter_list != []
      # イベント実行中かエンカウント禁止中でなければ
      unless $game_system.map_interpreter.running? or
             $game_system.encounter_disabled
        # トループを決定
        n = rand($game_map.encounter_list.size)
        troop_id = $game_map.encounter_list[n]
        # トループが有効なら
        if $data_troops[troop_id] != nil
          # バトル呼び出しフラグをセット
          $game_temp.battle_calling = true
          $game_temp.battle_troop_id = troop_id
          $game_temp.battle_can_escape = true
          $game_temp.battle_can_lose = false
          $game_temp.battle_proc = nil
        end
      end
    end
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # イベント実行中かメニュー禁止中でなければ
      unless $game_system.map_interpreter.running? or
             $game_system.menu_disabled
        # メニュー呼び出しフラグと SE 演奏フラグをセット
        $game_temp.menu_calling = true
        $game_temp.menu_beep = true
      end
    end
    # デバッグモードが ON かつ F9 キーが押されている場合
    if $DEBUG and Input.press?(Input::F9)
      # デバッグ呼び出しフラグをセット
      $game_temp.debug_calling = true
    end
    # プレイヤーの移動中ではない場合
    unless $game_player.moving?
      # 各種画面の呼び出しを実行
      if $game_temp.battle_calling
        call_battle
      elsif $game_temp.shop_calling
        call_shop
      elsif $game_temp.name_calling
        call_name
      elsif $game_temp.menu_calling
        call_menu
      elsif $game_temp.save_calling
        call_save
      elsif $game_temp.debug_calling
        call_debug
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● バトルの呼び出し
  #--------------------------------------------------------------------------
  def call_battle
    # バトル呼び出しフラグをクリア
    $game_temp.battle_calling = false
    # メニュー呼び出しフラグをクリア
    $game_temp.menu_calling = false
    $game_temp.menu_beep = false
    # エンカウント カウントを作成
    $game_player.make_encounter_count
    # マップ BGM を記憶し、BGM を停止
    $game_temp.map_bgm = $game_system.playing_bgm
    $game_system.bgm_stop
    # バトル開始 SE を演奏
    $game_system.se_play($data_system.battle_start_se)
    # バトル BGM を演奏
    $game_system.bgm_play($game_system.battle_bgm)
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # バトル画面に切り替え
    $scene = Scene_Battle.new
  end
  #--------------------------------------------------------------------------
  # ● ショップの呼び出し
  #--------------------------------------------------------------------------
  def call_shop
    # ショップ呼び出しフラグをクリア
    $game_temp.shop_calling = false
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # ショップ画面に切り替え
    $scene = Scene_Shop.new
  end
  #--------------------------------------------------------------------------
  # ● 名前入力の呼び出し
  #--------------------------------------------------------------------------
  def call_name
    # 名前入力呼び出しフラグをクリア
    $game_temp.name_calling = false
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # 名前入力画面に切り替え
    $scene = Scene_Name.new
  end
  #--------------------------------------------------------------------------
  # ● メニューの呼び出し
  #--------------------------------------------------------------------------
  def call_menu
    # メニュー呼び出しフラグをクリア
    $game_temp.menu_calling = false
    # メニュー SE 演奏フラグがセットされている場合
    if $game_temp.menu_beep
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # メニュー SE 演奏フラグをクリア
      $game_temp.menu_beep = false
    end
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # メニュー画面に切り替え
    $scene = Scene_Menu.new
  end
  #--------------------------------------------------------------------------
  # ● セーブの呼び出し
  #--------------------------------------------------------------------------
  def call_save
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # セーブ画面に切り替え
    $scene = Scene_Save.new
  end
  #--------------------------------------------------------------------------
  # ● デバッグの呼び出し
  #--------------------------------------------------------------------------
  def call_debug
    # デバッグ呼び出しフラグをクリア
    $game_temp.debug_calling = false
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # デバッグ画面に切り替え
    $scene = Scene_Debug.new
  end
  #--------------------------------------------------------------------------
  # ● プレイヤーの場所移動
  #--------------------------------------------------------------------------
  def transfer_player
    # プレイヤー場所移動フラグをクリア
    $game_temp.player_transferring = false
    # 移動先が現在のマップと異なる場合
    if $game_map.map_id != $game_temp.player_new_map_id
      # 新しいマップをセットアップ
      $game_map.setup($game_temp.player_new_map_id)
    end
    # プレイヤーの位置を設定
    $game_player.moveto($game_temp.player_new_x, $game_temp.player_new_y)
    # プレイヤーの向きを設定
    case $game_temp.player_new_direction
    when 2  # 下
      $game_player.turn_down
    when 4  # 左
      $game_player.turn_left
    when 6  # 右
      $game_player.turn_right
    when 8  # 上
      $game_player.turn_up
    end
    # プレイヤーの姿勢を矯正
    $game_player.straighten
    # マップを更新 (並列イベント実行)
    $game_map.update
    # スプライトセットを再作成
    @spriteset.dispose
    @spriteset = Spriteset_Map.new
    # トランジション処理中の場合
    if $game_temp.transition_processing
      # トランジション処理中フラグをクリア
      $game_temp.transition_processing = false
      # トランジション実行
      Graphics.transition(20)
    end
    # マップに設定されている BGM と BGS の自動切り替えを実行
    $game_map.autoplay
    # フレームリセット
    Graphics.frame_reset
    # 入力情報を更新
    Input.update
  end
end

#==============================================================================
# ■ Scene_Menu
#------------------------------------------------------------------------------
# 　メニュー画面の処理を行うクラスです。
#==============================================================================

class Scene_Menu
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     menu_index : コマンドのカーソル初期位置
  #--------------------------------------------------------------------------
  def initialize(menu_index = 0)
    @menu_index = menu_index
  end
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # コマンドウィンドウを作成
    s1 = $data_system.words.item
    s2 = $data_system.words.skill
    s3 = $data_system.words.equip
    s4 = "ステータス"
    s5 = "セーブ"
    s6 = "ゲーム終了"
    @command_window = Window_Command.new(160, [s1, s2, s3, s4, s5, s6])
    @command_window.index = @menu_index
    # パーティ人数が 0 人の場合
    if $game_party.actors.size == 0
      # アイテム、スキル、装備、ステータスを無効化
      @command_window.disable_item(0)
      @command_window.disable_item(1)
      @command_window.disable_item(2)
      @command_window.disable_item(3)
    end
    # セーブ禁止の場合
    if $game_system.save_disabled
      # セーブを無効にする
      @command_window.disable_item(4)
    end
    # プレイ時間ウィンドウを作成
    @playtime_window = Window_PlayTime.new
    @playtime_window.x = 0
    @playtime_window.y = 224
    # 歩数ウィンドウを作成
    @steps_window = Window_Steps.new
    @steps_window.x = 0
    @steps_window.y = 320
    # ゴールドウィンドウを作成
    @gold_window = Window_Gold.new
    @gold_window.x = 0
    @gold_window.y = 416
    # ステータスウィンドウを作成
    @status_window = Window_MenuStatus.new
    @status_window.x = 160
    @status_window.y = 0
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @command_window.dispose
    @playtime_window.dispose
    @steps_window.dispose
    @gold_window.dispose
    @status_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @command_window.update
    @playtime_window.update
    @steps_window.update
    @gold_window.update
    @status_window.update
    # コマンドウィンドウがアクティブの場合: update_command を呼ぶ
    if @command_window.active
      update_command
      return
    end
    # ステータスウィンドウがアクティブの場合: update_status を呼ぶ
    if @status_window.active
      update_status
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (コマンドウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_command
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # マップ画面に切り替え
      $scene = Scene_Map.new
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # パーティ人数が 0 人で、セーブ、ゲーム終了以外のコマンドの場合
      if $game_party.actors.size == 0 and @command_window.index < 4
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # アイテム
        # 決定  SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アイテム画面に切り替え
        $scene = Scene_Item.new
      when 1  # スキル
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ステータスウィンドウをアクティブにする
        @command_window.active = false
        @status_window.active = true
        @status_window.index = 0
      when 2  # 装備
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ステータスウィンドウをアクティブにする
        @command_window.active = false
        @status_window.active = true
        @status_window.index = 0
      when 3  # ステータス
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ステータスウィンドウをアクティブにする
        @command_window.active = false
        @status_window.active = true
        @status_window.index = 0
      when 4  # セーブ
        # セーブ禁止の場合
        if $game_system.save_disabled
          # ブザー SE を演奏
          $game_system.se_play($data_system.buzzer_se)
          return
        end
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # セーブ画面に切り替え
        $scene = Scene_Save.new
      when 5  # ゲーム終了
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ゲーム終了画面に切り替え
        $scene = Scene_End.new
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ステータスウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_status
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # コマンドウィンドウをアクティブにする
      @command_window.active = true
      @status_window.active = false
      @status_window.index = -1
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 1  # スキル
        # このアクターの行動制限が 2 以上の場合
        if $game_party.actors[@status_window.index].restriction >= 2
          # ブザー SE を演奏
          $game_system.se_play($data_system.buzzer_se)
          return
        end
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # スキル画面に切り替え
        $scene = Scene_Skill.new(@status_window.index)
      when 2  # 装備
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # 装備画面に切り替え
        $scene = Scene_Equip.new(@status_window.index)
      when 3  # ステータス
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ステータス画面に切り替え
        $scene = Scene_Status.new(@status_window.index)
      end
      return
    end
  end
end

#==============================================================================
# ■ Scene_Item
#------------------------------------------------------------------------------
# 　アイテム画面の処理を行うクラスです。
#==============================================================================

class Scene_Item
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # ヘルプウィンドウ、アイテムウィンドウを作成
    @help_window = Window_Help.new
    @item_window = Window_Item.new
    # ヘルプウィンドウを関連付け
    @item_window.help_window = @help_window
    # ターゲットウィンドウを作成 (不可視・非アクティブに設定)
    @target_window = Window_Target.new
    @target_window.visible = false
    @target_window.active = false
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @help_window.dispose
    @item_window.dispose
    @target_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @help_window.update
    @item_window.update
    @target_window.update
    # アイテムウィンドウがアクティブの場合: update_item を呼ぶ
    if @item_window.active
      update_item
      return
    end
    # ターゲットウィンドウがアクティブの場合: update_target を呼ぶ
    if @target_window.active
      update_target
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アイテムウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_item
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # メニュー画面に切り替え
      $scene = Scene_Menu.new(0)
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アイテムウィンドウで現在選択されているデータを取得
      @item = @item_window.item
      # 使用アイテムではない場合
      unless @item.is_a?(RPG::Item)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 使用できない場合
      unless $game_party.item_can_use?(@item.id)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # 効果範囲が味方の場合
      if @item.scope >= 3
        # ターゲットウィンドウをアクティブ化
        @item_window.active = false
        @target_window.x = (@item_window.index + 1) % 2 * 304
        @target_window.visible = true
        @target_window.active = true
        # 効果範囲 (単体/全体) に応じてカーソル位置を設定
        if @item.scope == 4 || @item.scope == 6
          @target_window.index = -1
        else
          @target_window.index = 0
        end
      # 効果範囲が味方以外の場合
      else
        # コモンイベント ID が有効の場合
        if @item.common_event_id > 0
          # コモンイベント呼び出し予約
          $game_temp.common_event_id = @item.common_event_id
          # アイテムの使用時 SE を演奏
          $game_system.se_play(@item.menu_se)
          # 消耗品の場合
          if @item.consumable
            # 使用したアイテムを 1 減らす
            $game_party.lose_item(@item.id, 1)
            # アイテムウィンドウの項目を再描画
            @item_window.draw_item(@item_window.index)
          end
          # マップ画面に切り替え
          $scene = Scene_Map.new
          return
        end
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ターゲットウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_target
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # アイテム切れなどで使用できなくなった場合
      unless $game_party.item_can_use?(@item.id)
        # アイテムウィンドウの内容を再作成
        @item_window.refresh
      end
      # ターゲットウィンドウを消去
      @item_window.active = true
      @target_window.visible = false
      @target_window.active = false
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アイテムを使い切った場合
      if $game_party.item_number(@item.id) == 0
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # ターゲットが全体の場合
      if @target_window.index == -1
        # パーティ全体にアイテムの使用効果を適用
        used = false
        for i in $game_party.actors
          used |= i.item_effect(@item)
        end
      end
      # ターゲットが単体の場合
      if @target_window.index >= 0
        # ターゲットのアクターにアイテムの使用効果を適用
        target = $game_party.actors[@target_window.index]
        used = target.item_effect(@item)
      end
      # アイテムを使った場合
      if used
        # アイテムの使用時 SE を演奏
        $game_system.se_play(@item.menu_se)
        # 消耗品の場合
        if @item.consumable
          # 使用したアイテムを 1 減らす
          $game_party.lose_item(@item.id, 1)
          # アイテムウィンドウの項目を再描画
          @item_window.draw_item(@item_window.index)
        end
        # ターゲットウィンドウの内容を再作成
        @target_window.refresh
        # 全滅の場合
        if $game_party.all_dead?
          # ゲームオーバー画面に切り替え
          $scene = Scene_Gameover.new
          return
        end
        # コモンイベント ID が有効の場合
        if @item.common_event_id > 0
          # コモンイベント呼び出し予約
          $game_temp.common_event_id = @item.common_event_id
          # マップ画面に切り替え
          $scene = Scene_Map.new
          return
        end
      end
      # アイテムを使わなかった場合
      unless used
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
      end
      return
    end
  end
end

#==============================================================================
# ■ Scene_Skill
#------------------------------------------------------------------------------
# 　スキル画面の処理を行うクラスです。
#==============================================================================

class Scene_Skill
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor_index : アクターインデックス
  #--------------------------------------------------------------------------
  def initialize(actor_index = 0, equip_index = 0)
    @actor_index = actor_index
  end
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # アクターを取得
    @actor = $game_party.actors[@actor_index]
    # ヘルプウィンドウ、ステータスウィンドウ、スキルウィンドウを作成
    @help_window = Window_Help.new
    @status_window = Window_SkillStatus.new(@actor)
    @skill_window = Window_Skill.new(@actor)
    # ヘルプウィンドウを関連付け
    @skill_window.help_window = @help_window
    # ターゲットウィンドウを作成 (不可視・非アクティブに設定)
    @target_window = Window_Target.new
    @target_window.visible = false
    @target_window.active = false
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @help_window.dispose
    @status_window.dispose
    @skill_window.dispose
    @target_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @help_window.update
    @status_window.update
    @skill_window.update
    @target_window.update
    # スキルウィンドウがアクティブの場合: update_skill を呼ぶ
    if @skill_window.active
      update_skill
      return
    end
    # ターゲットウィンドウがアクティブの場合: update_target を呼ぶ
    if @target_window.active
      update_target
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (スキルウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_skill
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # メニュー画面に切り替え
      $scene = Scene_Menu.new(1)
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # スキルウィンドウで現在選択されているデータを取得
      @skill = @skill_window.skill
      # 使用できない場合
      if @skill == nil or not @actor.skill_can_use?(@skill.id)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # 効果範囲が味方の場合
      if @skill.scope >= 3
        # ターゲットウィンドウをアクティブ化
        @skill_window.active = false
        @target_window.x = (@skill_window.index + 1) % 2 * 304
        @target_window.visible = true
        @target_window.active = true
        # 効果範囲 (単体/全体) に応じてカーソル位置を設定
        if @skill.scope == 4 || @skill.scope == 6
          @target_window.index = -1
        elsif @skill.scope == 7
          @target_window.index = @actor_index - 10
        else
          @target_window.index = 0
        end
      # 効果範囲が味方以外の場合
      else
        # コモンイベント ID が有効の場合
        if @skill.common_event_id > 0
          # コモンイベント呼び出し予約
          $game_temp.common_event_id = @skill.common_event_id
          # スキルの使用時 SE を演奏
          $game_system.se_play(@skill.menu_se)
          # SP 消費
          @actor.sp -= @skill.sp_cost
          # 各ウィンドウの内容を再作成
          @status_window.refresh
          @skill_window.refresh
          @target_window.refresh
          # マップ画面に切り替え
          $scene = Scene_Map.new
          return
        end
      end
      return
    end
    # R ボタンが押された場合
    if Input.trigger?(Input::R)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 次のアクターへ
      @actor_index += 1
      @actor_index %= $game_party.actors.size
      # 別のスキル画面に切り替え
      $scene = Scene_Skill.new(@actor_index)
      return
    end
    # L ボタンが押された場合
    if Input.trigger?(Input::L)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 前のアクターへ
      @actor_index += $game_party.actors.size - 1
      @actor_index %= $game_party.actors.size
      # 別のスキル画面に切り替え
      $scene = Scene_Skill.new(@actor_index)
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ターゲットウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_target
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # ターゲットウィンドウを消去
      @skill_window.active = true
      @target_window.visible = false
      @target_window.active = false
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # SP 切れなどで使用できなくなった場合
      unless @actor.skill_can_use?(@skill.id)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # ターゲットが全体の場合
      if @target_window.index == -1
        # パーティ全体にスキルの使用効果を適用
        used = false
        for i in $game_party.actors
          used |= i.skill_effect(@actor, @skill)
        end
      end
      # ターゲットが使用者の場合
      if @target_window.index <= -2
        # ターゲットのアクターにスキルの使用効果を適用
        target = $game_party.actors[@target_window.index + 10]
        used = target.skill_effect(@actor, @skill)
      end
      # ターゲットが単体の場合
      if @target_window.index >= 0
        # ターゲットのアクターにスキルの使用効果を適用
        target = $game_party.actors[@target_window.index]
        used = target.skill_effect(@actor, @skill)
      end
      # スキルを使った場合
      if used
        # スキルの使用時 SE を演奏
        $game_system.se_play(@skill.menu_se)
        # SP 消費
        @actor.sp -= @skill.sp_cost
        # 各ウィンドウの内容を再作成
        @status_window.refresh
        @skill_window.refresh
        @target_window.refresh
        # 全滅の場合
        if $game_party.all_dead?
          # ゲームオーバー画面に切り替え
          $scene = Scene_Gameover.new
          return
        end
        # コモンイベント ID が有効の場合
        if @skill.common_event_id > 0
          # コモンイベント呼び出し予約
          $game_temp.common_event_id = @skill.common_event_id
          # マップ画面に切り替え
          $scene = Scene_Map.new
          return
        end
      end
      # スキルを使わなかった場合
      unless used
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
      end
      return
    end
  end
end

#==============================================================================
# ■ Scene_Equip
#------------------------------------------------------------------------------
# 　装備画面の処理を行うクラスです。
#==============================================================================

class Scene_Equip
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor_index : アクターインデックス
  #     equip_index : 装備インデックス
  #--------------------------------------------------------------------------
  def initialize(actor_index = 0, equip_index = 0)
    @actor_index = actor_index
    @equip_index = equip_index
  end
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # アクターを取得
    @actor = $game_party.actors[@actor_index]
    # ウィンドウを作成
    @help_window = Window_Help.new
    @left_window = Window_EquipLeft.new(@actor)
    @right_window = Window_EquipRight.new(@actor)
    @item_window1 = Window_EquipItem.new(@actor, 0)
    @item_window2 = Window_EquipItem.new(@actor, 1)
    @item_window3 = Window_EquipItem.new(@actor, 2)
    @item_window4 = Window_EquipItem.new(@actor, 3)
    @item_window5 = Window_EquipItem.new(@actor, 4)
    # ヘルプウィンドウを関連付け
    @right_window.help_window = @help_window
    @item_window1.help_window = @help_window
    @item_window2.help_window = @help_window
    @item_window3.help_window = @help_window
    @item_window4.help_window = @help_window
    @item_window5.help_window = @help_window
    # カーソル位置を設定
    @right_window.index = @equip_index
    refresh
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @help_window.dispose
    @left_window.dispose
    @right_window.dispose
    @item_window1.dispose
    @item_window2.dispose
    @item_window3.dispose
    @item_window4.dispose
    @item_window5.dispose
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    # アイテムウィンドウの可視状態設定
    @item_window1.visible = (@right_window.index == 0)
    @item_window2.visible = (@right_window.index == 1)
    @item_window3.visible = (@right_window.index == 2)
    @item_window4.visible = (@right_window.index == 3)
    @item_window5.visible = (@right_window.index == 4)
    # 現在装備中のアイテムを取得
    item1 = @right_window.item
    # 現在のアイテムウィンドウを @item_window に設定
    case @right_window.index
    when 0
      @item_window = @item_window1
    when 1
      @item_window = @item_window2
    when 2
      @item_window = @item_window3
    when 3
      @item_window = @item_window4
    when 4
      @item_window = @item_window5
    end
    # ライトウィンドウがアクティブの場合
    if @right_window.active
      # 装備変更後のパラメータを消去
      @left_window.set_new_parameters(nil, nil, nil)
    end
    # アイテムウィンドウがアクティブの場合
    if @item_window.active
      # 現在選択中のアイテムを取得
      item2 = @item_window.item
      # 装備を変更
      last_hp = @actor.hp
      last_sp = @actor.sp
      @actor.equip(@right_window.index, item2 == nil ? 0 : item2.id)
      # 装備変更後のパラメータを取得
      new_atk = @actor.atk
      new_pdef = @actor.pdef
      new_mdef = @actor.mdef
      # 装備を戻す
      @actor.equip(@right_window.index, item1 == nil ? 0 : item1.id)
      @actor.hp = last_hp
      @actor.sp = last_sp
      # レフトウィンドウに描画
      @left_window.set_new_parameters(new_atk, new_pdef, new_mdef)
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @left_window.update
    @right_window.update
    @item_window.update
    refresh
    # ライトウィンドウがアクティブの場合: update_right を呼ぶ
    if @right_window.active
      update_right
      return
    end
    # アイテムウィンドウがアクティブの場合: update_item を呼ぶ
    if @item_window.active
      update_item
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ライトウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_right
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # メニュー画面に切り替え
      $scene = Scene_Menu.new(2)
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # 装備固定の場合
      if @actor.equip_fix?(@right_window.index)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アイテムウィンドウをアクティブ化
      @right_window.active = false
      @item_window.active = true
      @item_window.index = 0
      return
    end
    # R ボタンが押された場合
    if Input.trigger?(Input::R)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 次のアクターへ
      @actor_index += 1
      @actor_index %= $game_party.actors.size
      # 別の装備画面に切り替え
      $scene = Scene_Equip.new(@actor_index, @right_window.index)
      return
    end
    # L ボタンが押された場合
    if Input.trigger?(Input::L)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 前のアクターへ
      @actor_index += $game_party.actors.size - 1
      @actor_index %= $game_party.actors.size
      # 別の装備画面に切り替え
      $scene = Scene_Equip.new(@actor_index, @right_window.index)
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アイテムウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_item
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # ライトウィンドウをアクティブ化
      @right_window.active = true
      @item_window.active = false
      @item_window.index = -1
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # 装備 SE を演奏
      $game_system.se_play($data_system.equip_se)
      # アイテムウィンドウで現在選択されているデータを取得
      item = @item_window.item
      # 装備を変更
      @actor.equip(@right_window.index, item == nil ? 0 : item.id)
      # ライトウィンドウをアクティブ化
      @right_window.active = true
      @item_window.active = false
      @item_window.index = -1
      # ライトウィンドウ、アイテムウィンドウの内容を再作成
      @right_window.refresh
      @item_window.refresh
      return
    end
  end
end

#==============================================================================
# ■ Scene_Status
#------------------------------------------------------------------------------
# 　ステータス画面の処理を行うクラスです。
#==============================================================================

class Scene_Status
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     actor_index : アクターインデックス
  #--------------------------------------------------------------------------
  def initialize(actor_index = 0, equip_index = 0)
    @actor_index = actor_index
  end
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # アクターを取得
    @actor = $game_party.actors[@actor_index]
    # ステータスウィンドウを作成
    @status_window = Window_Status.new(@actor)
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @status_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # メニュー画面に切り替え
      $scene = Scene_Menu.new(3)
      return
    end
    # R ボタンが押された場合
    if Input.trigger?(Input::R)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 次のアクターへ
      @actor_index += 1
      @actor_index %= $game_party.actors.size
      # 別のステータス画面に切り替え
      $scene = Scene_Status.new(@actor_index)
      return
    end
    # L ボタンが押された場合
    if Input.trigger?(Input::L)
      # カーソル SE を演奏
      $game_system.se_play($data_system.cursor_se)
      # 前のアクターへ
      @actor_index += $game_party.actors.size - 1
      @actor_index %= $game_party.actors.size
      # 別のステータス画面に切り替え
      $scene = Scene_Status.new(@actor_index)
      return
    end
  end
end

#==============================================================================
# ■ Scene_File
#------------------------------------------------------------------------------
# 　セーブ画面およびロード画面のスーパークラスです。
#==============================================================================

class Scene_File
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #     help_text : ヘルプウィンドウに表示する文字列
  #--------------------------------------------------------------------------
  def initialize(help_text)
    @help_text = help_text
  end
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # ヘルプウィンドウを作成
    @help_window = Window_Help.new
    @help_window.set_text(@help_text)
    # セーブファイルウィンドウを作成
    @savefile_windows = []
    for i in 0..3
      @savefile_windows.push(Window_SaveFile.new(i, make_filename(i)))
    end
    # 最後に操作したファイルを選択
    @file_index = $game_temp.last_file_index
    @savefile_windows[@file_index].selected = true
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @help_window.dispose
    for i in @savefile_windows
      i.dispose
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @help_window.update
    for i in @savefile_windows
      i.update
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # メソッド on_decision (継承先で定義) を呼ぶ
      on_decision(make_filename(@file_index))
      $game_temp.last_file_index = @file_index
      return
    end
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # メソッド on_cancel (継承先で定義) を呼ぶ
      on_cancel
      return
    end
    # 方向ボタンの下が押された場合
    if Input.repeat?(Input::DOWN)
      # 方向ボタンの下の押下状態がリピートでない場合か、
      # またはカーソル位置が 3 より前の場合
      if Input.trigger?(Input::DOWN) or @file_index < 3
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # カーソルを下に移動
        @savefile_windows[@file_index].selected = false
        @file_index = (@file_index + 1) % 4
        @savefile_windows[@file_index].selected = true
        return
      end
    end
    # 方向ボタンの上が押された場合
    if Input.repeat?(Input::UP)
      # 方向ボタンの上の押下状態がリピートでない場合か、
      # またはカーソル位置が 0 より後ろの場合
      if Input.trigger?(Input::UP) or @file_index > 0
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # カーソルを上に移動
        @savefile_windows[@file_index].selected = false
        @file_index = (@file_index + 3) % 4
        @savefile_windows[@file_index].selected = true
        return
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● ファイル名の作成
  #     file_index : セーブファイルのインデックス (0～3)
  #--------------------------------------------------------------------------
  def make_filename(file_index)
    return "Save#{file_index + 1}.rxdata"
  end
end

#==============================================================================
# ■ Scene_Save
#------------------------------------------------------------------------------
# 　セーブ画面の処理を行うクラスです。
#==============================================================================

class Scene_Save < Scene_File
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super("どのファイルにセーブしますか？")
  end
  #--------------------------------------------------------------------------
  # ● 決定時の処理
  #--------------------------------------------------------------------------
  def on_decision(filename)
    # セーブ SE を演奏
    $game_system.se_play($data_system.save_se)
    # セーブデータの書き込み
    # file = File.open(filename, "wb")
    # write_save_data(file)
    write_save_data(nil)
    # file.close
    # イベントから呼び出されている場合
    if $game_temp.save_calling
      # セーブ呼び出しフラグをクリア
      $game_temp.save_calling = false
      # マップ画面に切り替え
      $scene = Scene_Map.new
      return
    end
    # メニュー画面に切り替え
    $scene = Scene_Menu.new(4)
  end
  #--------------------------------------------------------------------------
  # ● キャンセル時の処理
  #--------------------------------------------------------------------------
  def on_cancel
    # キャンセル SE を演奏
    $game_system.se_play($data_system.cancel_se)
    # イベントから呼び出されている場合
    if $game_temp.save_calling
      # セーブ呼び出しフラグをクリア
      $game_temp.save_calling = false
      # マップ画面に切り替え
      $scene = Scene_Map.new
      return
    end
    # メニュー画面に切り替え
    $scene = Scene_Menu.new(4)
  end
  #--------------------------------------------------------------------------
  # ● セーブデータの書き込み
  #     file : 書き込み用ファイルオブジェクト (オープン済み)
  #--------------------------------------------------------------------------
  def write_save_data(file)
    # セーブファイル描画用のキャラクターデータを作成
    characters = []
    for i in 0...$game_party.actors.size
      actor = $game_party.actors[i]
      characters.push([actor.character_name, actor.character_hue])
    end
    # セーブファイル描画用のキャラクターデータを書き込む
    Marshal.dump(characters)
    # プレイ時間計測用のフレームカウントを書き込む
    Marshal.dump(Graphics.frame_count)
    # セーブ回数を 1 増やす
    $game_system.save_count += 1
    # マジックナンバーを保存する
    # (エディタで保存するたびにランダムな値に書き換えられる)
    $game_system.magic_number = $data_system.magic_number
    # 各種ゲームオブジェクトを書き込む
    Marshal.dump($game_system)
    Marshal.dump($game_switches)
    Marshal.dump($game_variables)
    Marshal.dump($game_self_switches)
    Marshal.dump($game_screen)
    Marshal.dump($game_actors)
    Marshal.dump($game_party)
    Marshal.dump($game_troop)
    Marshal.dump($game_map)
    Marshal.dump($game_player)
  end
end

#==============================================================================
# ■ Scene_Load
#------------------------------------------------------------------------------
# 　ロード画面の処理を行うクラスです。
#==============================================================================

class Scene_Load < Scene_File
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    # テンポラリオブジェクトを再作成
    $game_temp = Game_Temp.new
    # タイムスタンプが最新のファイルを選択
    $game_temp.last_file_index = 0
    latest_time = Time.at(0)
    for i in 0..3
      filename = make_filename(i)
      if FileTest.exist?(filename)
        file = File.open(filename, "r")
        if file.mtime > latest_time
          latest_time = file.mtime
          $game_temp.last_file_index = i
        end
        file.close
      end
    end
    super("どのファイルをロードしますか？")
  end
  #--------------------------------------------------------------------------
  # ● 決定時の処理
  #--------------------------------------------------------------------------
  def on_decision(filename)
    # ファイルが存在しない場合
    unless FileTest.exist?(filename)
      # ブザー SE を演奏
      $game_system.se_play($data_system.buzzer_se)
      return
    end
    # ロード SE を演奏
    $game_system.se_play($data_system.load_se)
    # セーブデータの書き込み
    file = File.open(filename, "rb")
    read_save_data(file)
    file.close
    # BGM、BGS を復帰
    $game_system.bgm_play($game_system.playing_bgm)
    $game_system.bgs_play($game_system.playing_bgs)
    # マップを更新 (並列イベント実行)
    $game_map.update
    # マップ画面に切り替え
    $scene = Scene_Map.new
  end
  #--------------------------------------------------------------------------
  # ● キャンセル時の処理
  #--------------------------------------------------------------------------
  def on_cancel
    # キャンセル SE を演奏
    $game_system.se_play($data_system.cancel_se)
    # タイトル画面に切り替え
    $scene = Scene_Title.new
  end
  #--------------------------------------------------------------------------
  # ● セーブデータの読み込み
  #     file : 読み込み用ファイルオブジェクト (オープン済み)
  #--------------------------------------------------------------------------
  def read_save_data(file)
    # セーブファイル描画用のキャラクターデータを読み込む
    characters = Marshal.load(file)
    # プレイ時間計測用のフレームカウントを読み込む
    Graphics.frame_count = Marshal.load(file)
    # 各種ゲームオブジェクトを読み込む
    $game_system        = Marshal.load(file)
    $game_switches      = Marshal.load(file)
    $game_variables     = Marshal.load(file)
    $game_self_switches = Marshal.load(file)
    $game_screen        = Marshal.load(file)
    $game_actors        = Marshal.load(file)
    $game_party         = Marshal.load(file)
    $game_troop         = Marshal.load(file)
    $game_map           = Marshal.load(file)
    $game_player        = Marshal.load(file)
    # マジックナンバーがセーブ時と異なる場合
    # (エディタで編集が加えられている場合)
    if $game_system.magic_number != $data_system.magic_number
      # マップをリロード
      $game_map.setup($game_map.map_id)
      $game_player.center($game_player.x, $game_player.y)
    end
    # パーティメンバーをリフレッシュ
    $game_party.refresh
  end
end

#==============================================================================
# ■ Scene_End
#------------------------------------------------------------------------------
# 　ゲーム終了画面の処理を行うクラスです。
#==============================================================================

class Scene_End
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # コマンドウィンドウを作成
    s1 = "タイトルへ"
    s2 = "シャットダウン"
    s3 = "やめる"
    @command_window = Window_Command.new(192, [s1, s2, s3])
    @command_window.x = 320 - @command_window.width / 2
    @command_window.y = 240 - @command_window.height / 2
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @command_window.dispose
    # タイトル画面に切り替え中の場合
    if $scene.is_a?(Scene_Title)
      # 画面をフェードアウト
      Graphics.transition
      Graphics.freeze
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # コマンドウィンドウを更新
    @command_window.update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # メニュー画面に切り替え
      $scene = Scene_Menu.new(5)
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # タイトルへ
        command_to_title
      when 1  # シャットダウン
        command_shutdown
      when 2  # やめる
        command_cancel
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● コマンド [タイトルへ] 選択時の処理
  #--------------------------------------------------------------------------
  def command_to_title
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # BGM、BGS、ME をフェードアウト
    Audio.bgm_fade(800)
    Audio.bgs_fade(800)
    Audio.me_fade(800)
    # タイトル画面に切り替え
    $scene = Scene_Title.new
  end
  #--------------------------------------------------------------------------
  # ● コマンド [シャットダウン] 選択時の処理
  #--------------------------------------------------------------------------
  def command_shutdown
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # BGM、BGS、ME をフェードアウト
    Audio.bgm_fade(800)
    Audio.bgs_fade(800)
    Audio.me_fade(800)
    # シャットダウン
    $scene = nil
  end
  #--------------------------------------------------------------------------
  # ● コマンド [やめる] 選択時の処理
  #--------------------------------------------------------------------------
  def command_cancel
    # 決定 SE を演奏
    $game_system.se_play($data_system.decision_se)
    # メニュー画面に切り替え
    $scene = Scene_Menu.new(5)
  end
end

#==============================================================================
# ■ Scene_Battle (分割定義 1)
#------------------------------------------------------------------------------
# 　バトル画面の処理を行うクラスです。
#==============================================================================

class Scene_Battle
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # 戦闘用の各種一時データを初期化
    $game_temp.in_battle = true
    $game_temp.battle_turn = 0
    $game_temp.battle_event_flags.clear
    $game_temp.battle_abort = false
    $game_temp.battle_main_phase = false
    $game_temp.battleback_name = $game_map.battleback_name
    $game_temp.forcing_battler = nil
    # バトルイベント用インタプリタを初期化
    $game_system.battle_interpreter.setup(nil, 0)
    # トループを準備
    @troop_id = $game_temp.battle_troop_id
    $game_troop.setup(@troop_id)
    # アクターコマンドウィンドウを作成
    s1 = $data_system.words.attack
    s2 = $data_system.words.skill
    s3 = $data_system.words.guard
    s4 = $data_system.words.item
    @actor_command_window = Window_Command.new(160, [s1, s2, s3, s4])
    @actor_command_window.y = 160
    @actor_command_window.back_opacity = 160
    @actor_command_window.active = false
    @actor_command_window.visible = false
    # その他のウィンドウを作成
    @party_command_window = Window_PartyCommand.new
    @help_window = Window_Help.new
    @help_window.back_opacity = 160
    @help_window.visible = false
    @status_window = Window_BattleStatus.new
    @message_window = Window_Message.new
    # スプライトセットを作成
    @spriteset = Spriteset_Battle.new
    # ウェイトカウントを初期化
    @wait_count = 0
    # トランジション実行
    if $data_system.battle_transition == ""
      Graphics.transition(20)
    else
      Graphics.transition(40, "Graphics/Transitions/" +
        $data_system.battle_transition)
    end
    # プレバトルフェーズ開始
    start_phase1
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # マップをリフレッシュ
    $game_map.refresh
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @actor_command_window.dispose
    @party_command_window.dispose
    @help_window.dispose
    @status_window.dispose
    @message_window.dispose
    if @skill_window != nil
      @skill_window.dispose
    end
    if @item_window != nil
      @item_window.dispose
    end
    if @result_window != nil
      @result_window.dispose
    end
    # スプライトセットを解放
    @spriteset.dispose
    # タイトル画面に切り替え中の場合
    if $scene.is_a?(Scene_Title)
      # 画面をフェードアウト
      Graphics.transition
      Graphics.freeze
    end
    # 戦闘テストからゲームオーバー画面以外に切り替え中の場合
    if $BTEST and not $scene.is_a?(Scene_Gameover)
      $scene = nil
    end
  end
  #--------------------------------------------------------------------------
  # ● 勝敗判定
  #--------------------------------------------------------------------------
  def judge
    # 全滅判定が真、またはパーティ人数が 0 人の場合
    if $game_party.all_dead? or $game_party.actors.size == 0
      # 敗北可能の場合
      if $game_temp.battle_can_lose
        # バトル開始前の BGM に戻す
        $game_system.bgm_play($game_temp.map_bgm)
        # バトル終了
        battle_end(2)
        # true を返す
        return true
      end
      # ゲームオーバーフラグをセット
      $game_temp.gameover = true
      # true を返す
      return true
    end
    # エネミーが 1 体でも存在すれば false を返す
    for enemy in $game_troop.enemies
      if enemy.exist?
        return false
      end
    end
    # アフターバトルフェーズ開始 (勝利)
    start_phase5
    # true を返す
    return true
  end
  #--------------------------------------------------------------------------
  # ● バトル終了
  #     result : 結果 (0:勝利 1:敗北 2:逃走)
  #--------------------------------------------------------------------------
  def battle_end(result)
    # 戦闘中フラグをクリア
    $game_temp.in_battle = false
    # パーティ全員のアクションをクリア
    $game_party.clear_actions
    # バトル用ステートを解除
    for actor in $game_party.actors
      actor.remove_states_battle
    end
    # エネミーをクリア
    $game_troop.enemies.clear
    # バトル コールバックを呼ぶ
    if $game_temp.battle_proc != nil
      $game_temp.battle_proc.call(result)
      $game_temp.battle_proc = nil
    end
    # マップ画面に切り替え
    $scene = Scene_Map.new
  end
  #--------------------------------------------------------------------------
  # ● バトルイベントのセットアップ
  #--------------------------------------------------------------------------
  def setup_battle_event
    # バトルイベント実行中の場合
    if $game_system.battle_interpreter.running?
      return
    end
    # バトルイベントの全ページを検索
    for index in 0...$data_troops[@troop_id].pages.size
      # イベントページを取得
      page = $data_troops[@troop_id].pages[index]
      # イベント条件を c で参照可能に
      c = page.condition
      # 何も条件が指定されていない場合は次のページへ
      unless c.turn_valid or c.enemy_valid or
             c.actor_valid or c.switch_valid
        next
      end
      # 実行済みの場合は次のページへ
      if $game_temp.battle_event_flags[index]
        next
      end
      # ターン 条件確認
      if c.turn_valid
        n = $game_temp.battle_turn
        a = c.turn_a
        b = c.turn_b
        if (b == 0 and n != a) or
           (b > 0 and (n < 1 or n < a or n % b != a % b))
          next
        end
      end
      # エネミー 条件確認
      if c.enemy_valid
        enemy = $game_troop.enemies[c.enemy_index]
        if enemy == nil or enemy.hp * 100.0 / enemy.maxhp > c.enemy_hp
          next
        end
      end
      # アクター 条件確認
      if c.actor_valid
        actor = $game_actors[c.actor_id]
        if actor == nil or actor.hp * 100.0 / actor.maxhp > c.actor_hp
          next
        end
      end
      # スイッチ 条件確認
      if c.switch_valid
        if $game_switches[c.switch_id] == false
          next
        end
      end
      # イベントをセットアップ
      $game_system.battle_interpreter.setup(page.list, 0)
      # このページのスパンが [バトル] か [ターン] の場合
      if page.span <= 1
        # 実行済みフラグをセット
        $game_temp.battle_event_flags[index] = true
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # バトルイベント実行中の場合
    if $game_system.battle_interpreter.running?
      # インタプリタを更新
      $game_system.battle_interpreter.update
      # アクションを強制されているバトラーが存在しない場合
      if $game_temp.forcing_battler == nil
        # バトルイベントの実行が終わった場合
        unless $game_system.battle_interpreter.running?
          # 戦闘継続の場合、バトルイベントのセットアップを再実行
          unless judge
            setup_battle_event
          end
        end
        # アフターバトルフェーズでなければ
        if @phase != 5
          # ステータスウィンドウをリフレッシュ
          @status_window.refresh
        end
      end
    end
    # システム (タイマー)、画面を更新
    $game_system.update
    $game_screen.update
    # タイマーが 0 になった場合
    if $game_system.timer_working and $game_system.timer == 0
      # バトル中断
      $game_temp.battle_abort = true
    end
    # ウィンドウを更新
    @help_window.update
    @party_command_window.update
    @actor_command_window.update
    @status_window.update
    @message_window.update
    # スプライトセットを更新
    @spriteset.update
    # トランジション処理中の場合
    if $game_temp.transition_processing
      # トランジション処理中フラグをクリア
      $game_temp.transition_processing = false
      # トランジション実行
      if $game_temp.transition_name == ""
        Graphics.transition(20)
      else
        Graphics.transition(40, "Graphics/Transitions/" +
          $game_temp.transition_name)
      end
    end
    # メッセージウィンドウ表示中の場合
    if $game_temp.message_window_showing
      return
    end
    # エフェクト表示中の場合
    if @spriteset.effect?
      return
    end
    # ゲームオーバーの場合
    if $game_temp.gameover
      # ゲームオーバー画面に切り替え
      $scene = Scene_Gameover.new
      return
    end
    # タイトル画面に戻す場合
    if $game_temp.to_title
      # タイトル画面に切り替え
      $scene = Scene_Title.new
      return
    end
    # バトル中断の場合
    if $game_temp.battle_abort
      # バトル開始前の BGM に戻す
      $game_system.bgm_play($game_temp.map_bgm)
      # バトル終了
      battle_end(1)
      return
    end
    # ウェイト中の場合
    if @wait_count > 0
      # ウェイトカウントを減らす
      @wait_count -= 1
      return
    end
    # アクションを強制されているバトラーが存在せず、
    # かつバトルイベントが実行中の場合
    if $game_temp.forcing_battler == nil and
       $game_system.battle_interpreter.running?
      return
    end
    # フェーズによって分岐
    case @phase
    when 1  # プレバトルフェーズ
      update_phase1
    when 2  # パーティコマンドフェーズ
      update_phase2
    when 3  # アクターコマンドフェーズ
      update_phase3
    when 4  # メインフェーズ
      update_phase4
    when 5  # アフターバトルフェーズ
      update_phase5
    end
  end
end

#==============================================================================
# ■ Scene_Battle (分割定義 2)
#------------------------------------------------------------------------------
# 　バトル画面の処理を行うクラスです。
#==============================================================================

class Scene_Battle
  #--------------------------------------------------------------------------
  # ● プレバトルフェーズ開始
  #--------------------------------------------------------------------------
  def start_phase1
    # フェーズ 1 に移行
    @phase = 1
    # パーティ全員のアクションをクリア
    $game_party.clear_actions
    # バトルイベントをセットアップ
    setup_battle_event
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (プレバトルフェーズ)
  #--------------------------------------------------------------------------
  def update_phase1
    # 勝敗判定
    if judge
      # 勝利または敗北の場合 : メソッド終了
      return
    end
    # パーティコマンドフェーズ開始
    start_phase2
  end
  #--------------------------------------------------------------------------
  # ● パーティコマンドフェーズ開始
  #--------------------------------------------------------------------------
  def start_phase2
    # フェーズ 2 に移行
    @phase = 2
    # アクターを非選択状態に設定
    @actor_index = -1
    @active_battler = nil
    # パーティコマンドウィンドウを有効化
    @party_command_window.active = true
    @party_command_window.visible = true
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
    # メインフェーズフラグをクリア
    $game_temp.battle_main_phase = false
    # パーティ全員のアクションをクリア
    $game_party.clear_actions
    # コマンド入力不可能な場合
    unless $game_party.inputable?
      # メインフェーズ開始
      start_phase4
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (パーティコマンドフェーズ)
  #--------------------------------------------------------------------------
  def update_phase2
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # パーティコマンドウィンドウのカーソル位置で分岐
      case @party_command_window.index
      when 0  # 戦う
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アクターコマンドフェーズ開始
        start_phase3
      when 1  # 逃げる
        # 逃走可能ではない場合
        if $game_temp.battle_can_escape == false
          # ブザー SE を演奏
          $game_system.se_play($data_system.buzzer_se)
          return
        end
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # 逃走処理
        update_phase2_escape
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (パーティコマンドフェーズ : 逃げる)
  #--------------------------------------------------------------------------
  def update_phase2_escape
    # エネミーの素早さ平均値を計算
    enemies_agi = 0
    enemies_number = 0
    for enemy in $game_troop.enemies
      if enemy.exist?
        enemies_agi += enemy.agi
        enemies_number += 1
      end
    end
    if enemies_number > 0
      enemies_agi /= enemies_number
    end
    # アクターの素早さ平均値を計算
    actors_agi = 0
    actors_number = 0
    for actor in $game_party.actors
      if actor.exist?
        actors_agi += actor.agi
        actors_number += 1
      end
    end
    if actors_number > 0
      actors_agi /= actors_number
    end
    # 逃走成功判定
    success = rand(100) < 50 * actors_agi / enemies_agi
    # 逃走成功の場合
    if success
      # 逃走 SE を演奏
      $game_system.se_play($data_system.escape_se)
      # バトル開始前の BGM に戻す
      $game_system.bgm_play($game_temp.map_bgm)
      # バトル終了
      battle_end(1)
    # 逃走失敗の場合
    else
      # パーティ全員のアクションをクリア
      $game_party.clear_actions
      # メインフェーズ開始
      start_phase4
    end
  end
  #--------------------------------------------------------------------------
  # ● アフターバトルフェーズ開始
  #--------------------------------------------------------------------------
  def start_phase5
    # フェーズ 5 に移行
    @phase = 5
    # バトル終了 ME を演奏
    $game_system.me_play($game_system.battle_end_me)
    # バトル開始前の BGM に戻す
    $game_system.bgm_play($game_temp.map_bgm)
    # EXP、ゴールド、トレジャーを初期化
    exp = 0
    gold = 0
    treasures = []
    # ループ
    for enemy in $game_troop.enemies
      # エネミーが隠れ状態でない場合
      unless enemy.hidden
        # 獲得 EXP、ゴールドを追加
        exp += enemy.exp
        gold += enemy.gold
        # トレジャー出現判定
        if rand(100) < enemy.treasure_prob
          if enemy.item_id > 0
            treasures.push($data_items[enemy.item_id])
          end
          if enemy.weapon_id > 0
            treasures.push($data_weapons[enemy.weapon_id])
          end
          if enemy.armor_id > 0
            treasures.push($data_armors[enemy.armor_id])
          end
        end
      end
    end
    # トレジャーの数を 6 個までに限定
    treasures = treasures[0..5]
    # EXP 獲得
    for i in 0...$game_party.actors.size
      actor = $game_party.actors[i]
      if actor.cant_get_exp? == false
        last_level = actor.level
        actor.exp += exp
        if actor.level > last_level
          @status_window.level_up(i)
        end
      end
    end
    # ゴールド獲得
    $game_party.gain_gold(gold)
    # トレジャー獲得
    for item in treasures
      case item
      when RPG::Item
        $game_party.gain_item(item.id, 1)
      when RPG::Weapon
        $game_party.gain_weapon(item.id, 1)
      when RPG::Armor
        $game_party.gain_armor(item.id, 1)
      end
    end
    # バトルリザルトウィンドウを作成
    @result_window = Window_BattleResult.new(exp, gold, treasures)
    # ウェイトカウントを設定
    @phase5_wait_count = 100
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アフターバトルフェーズ)
  #--------------------------------------------------------------------------
  def update_phase5
    # ウェイトカウントが 0 より大きい場合
    if @phase5_wait_count > 0
      # ウェイトカウントを減らす
      @phase5_wait_count -= 1
      # ウェイトカウントが 0 になった場合
      if @phase5_wait_count == 0
        # リザルトウィンドウを表示
        @result_window.visible = true
        # メインフェーズフラグをクリア
        $game_temp.battle_main_phase = false
        # ステータスウィンドウをリフレッシュ
        @status_window.refresh
      end
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # バトル終了
      battle_end(0)
    end
  end
end

#==============================================================================
# ■ Scene_Battle (分割定義 3)
#------------------------------------------------------------------------------
# 　バトル画面の処理を行うクラスです。
#==============================================================================

class Scene_Battle
  #--------------------------------------------------------------------------
  # ● アクターコマンドフェーズ開始
  #--------------------------------------------------------------------------
  def start_phase3
    # フェーズ 3 に移行
    @phase = 3
    # アクターを非選択状態に設定
    @actor_index = -1
    @active_battler = nil
    # 次のアクターのコマンド入力へ
    phase3_next_actor
  end
  #--------------------------------------------------------------------------
  # ● 次のアクターのコマンド入力へ
  #--------------------------------------------------------------------------
  def phase3_next_actor
    # ループ
    # begin
    #   # アクターの明滅エフェクト OFF
    #   if @active_battler != nil
    #     @active_battler.blink = false
    #   end
    #   # 最後のアクターの場合
    #   if @actor_index == $game_party.actors.size-1
    #     # メインフェーズ開始
    #     start_phase4
    #     return
    #   end
    #   # アクターのインデックスを進める
    #   @actor_index += 1
    #   @active_battler = $game_party.actors[@actor_index]
    #   @active_battler.blink = true
    # # アクターがコマンド入力を受け付けない状態ならもう一度
    # end until @active_battler.inputable?

    while true
      # アクターの明滅エフェクト OFF
      if @active_battler != nil
        @active_battler.blink = false
      end
      # 最後のアクターの場合
      if @actor_index == $game_party.actors.size-1
        # メインフェーズ開始
        start_phase4
        return
      end
      # アクターのインデックスを進める
      @actor_index += 1
      @active_battler = $game_party.actors[@actor_index]
      @active_battler.blink = true
      # アクターがコマンド入力を受け付けない状態ならもう一度
      break if @active_battler.inputable?
    end

    # アクターコマンドウィンドウをセットアップ
    phase3_setup_command_window
  end
  #--------------------------------------------------------------------------
  # ● 前のアクターのコマンド入力へ
  #--------------------------------------------------------------------------
  def phase3_prior_actor
    # ループ
    while true
      # アクターの明滅エフェクト OFF
      if @active_battler != nil
        @active_battler.blink = false
      end
      # 最初のアクターの場合
      if @actor_index == 0
        # パーティコマンドフェーズ開始
        start_phase2
        return
      end
      # アクターのインデックスを戻す
      @actor_index -= 1
      @active_battler = $game_party.actors[@actor_index]
      @active_battler.blink = true
      # アクターがコマンド入力を受け付けない状態ならもう一度
      break if @active_battler.inputable?
    end
    # アクターコマンドウィンドウをセットアップ
    phase3_setup_command_window
  end
  #--------------------------------------------------------------------------
  # ● アクターコマンドウィンドウのセットアップ
  #--------------------------------------------------------------------------
  def phase3_setup_command_window
    # パーティコマンドウィンドウを無効化
    @party_command_window.active = false
    @party_command_window.visible = false
    # アクターコマンドウィンドウを有効化
    @actor_command_window.active = true
    @actor_command_window.visible = true
    # アクターコマンドウィンドウの位置を設定
    @actor_command_window.x = @actor_index * 160
    # インデックスを 0 に設定
    @actor_command_window.index = 0
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ)
  #--------------------------------------------------------------------------
  def update_phase3
    # エネミーアローが有効の場合
    if @enemy_arrow != nil
      update_phase3_enemy_select
    # アクターアローが有効の場合
    elsif @actor_arrow != nil
      update_phase3_actor_select
    # スキルウィンドウが有効の場合
    elsif @skill_window != nil
      update_phase3_skill_select
    # アイテムウィンドウが有効の場合
    elsif @item_window != nil
      update_phase3_item_select
    # アクターコマンドウィンドウが有効の場合
    elsif @actor_command_window.active
      update_phase3_basic_command
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ : 基本コマンド)
  #--------------------------------------------------------------------------
  def update_phase3_basic_command
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # 前のアクターのコマンド入力へ
      phase3_prior_actor
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アクターコマンドウィンドウのカーソル位置で分岐
      case @actor_command_window.index
      when 0  # 攻撃
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アクションを設定
        @active_battler.current_action.kind = 0
        @active_battler.current_action.basic = 0
        # エネミーの選択を開始
        start_enemy_select
      when 1  # スキル
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アクションを設定
        @active_battler.current_action.kind = 1
        # スキルの選択を開始
        start_skill_select
      when 2  # 防御
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アクションを設定
        @active_battler.current_action.kind = 0
        @active_battler.current_action.basic = 1
        # 次のアクターのコマンド入力へ
        phase3_next_actor
      when 3  # アイテム
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # アクションを設定
        @active_battler.current_action.kind = 2
        # アイテムの選択を開始
        start_item_select
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ : スキル選択)
  #--------------------------------------------------------------------------
  def update_phase3_skill_select
    # スキルウィンドウを可視状態にする
    @skill_window.visible = true
    # スキルウィンドウを更新
    @skill_window.update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # スキルの選択を終了
      end_skill_select
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # スキルウィンドウで現在選択されているデータを取得
      @skill = @skill_window.skill
      # 使用できない場合
      if @skill == nil or not @active_battler.skill_can_use?(@skill.id)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アクションを設定
      @active_battler.current_action.skill_id = @skill.id
      # スキルウィンドウを不可視状態にする
      @skill_window.visible = false
      # 効果範囲が敵単体の場合
      if @skill.scope == 1
        # エネミーの選択を開始
        start_enemy_select
      # 効果範囲が味方単体の場合
      elsif @skill.scope == 3 or @skill.scope == 5
        # アクターの選択を開始
        start_actor_select
      # 効果範囲が単体ではない場合
      else
        # スキルの選択を終了
        end_skill_select
        # 次のアクターのコマンド入力へ
        phase3_next_actor
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ : アイテム選択)
  #--------------------------------------------------------------------------
  def update_phase3_item_select
    # アイテムウィンドウを可視状態にする
    @item_window.visible = true
    # アイテムウィンドウを更新
    @item_window.update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # アイテムの選択を終了
      end_item_select
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アイテムウィンドウで現在選択されているデータを取得
      @item = @item_window.item
      # 使用できない場合
      unless $game_party.item_can_use?(@item.id)
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アクションを設定
      @active_battler.current_action.item_id = @item.id
      # アイテムウィンドウを不可視状態にする
      @item_window.visible = false
      # 効果範囲が敵単体の場合
      if @item.scope == 1
        # エネミーの選択を開始
        start_enemy_select
      # 効果範囲が味方単体の場合
      elsif @item.scope == 3 or @item.scope == 5
        # アクターの選択を開始
        start_actor_select
      # 効果範囲が単体ではない場合
      else
        # アイテムの選択を終了
        end_item_select
        # 次のアクターのコマンド入力へ
        phase3_next_actor
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ : エネミー選択)
  #--------------------------------------------------------------------------
  def update_phase3_enemy_select
    # エネミーアローを更新
    @enemy_arrow.update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # エネミーの選択を終了
      end_enemy_select
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アクションを設定
      @active_battler.current_action.target_index = @enemy_arrow.index
      # エネミーの選択を終了
      end_enemy_select
      # スキルウィンドウ表示中の場合
      if @skill_window != nil
        # スキルの選択を終了
        end_skill_select
      end
      # アイテムウィンドウ表示中の場合
      if @item_window != nil
        # アイテムの選択を終了
        end_item_select
      end
      # 次のアクターのコマンド入力へ
      phase3_next_actor
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (アクターコマンドフェーズ : アクター選択)
  #--------------------------------------------------------------------------
  def update_phase3_actor_select
    # アクターアローを更新
    @actor_arrow.update
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # アクターの選択を終了
      end_actor_select
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アクションを設定
      @active_battler.current_action.target_index = @actor_arrow.index
      # アクターの選択を終了
      end_actor_select
      # スキルウィンドウ表示中の場合
      if @skill_window != nil
        # スキルの選択を終了
        end_skill_select
      end
      # アイテムウィンドウ表示中の場合
      if @item_window != nil
        # アイテムの選択を終了
        end_item_select
      end
      # 次のアクターのコマンド入力へ
      phase3_next_actor
    end
  end
  #--------------------------------------------------------------------------
  # ● エネミー選択開始
  #--------------------------------------------------------------------------
  def start_enemy_select
    # エネミーアローを作成
    @enemy_arrow = Arrow_Enemy.new(@spriteset.viewport1)
    # ヘルプウィンドウを関連付け
    @enemy_arrow.help_window = @help_window
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
  end
  #--------------------------------------------------------------------------
  # ● エネミー選択終了
  #--------------------------------------------------------------------------
  def end_enemy_select
    # エネミーアローを解放
    @enemy_arrow.dispose
    @enemy_arrow = nil
    # コマンドが [戦う] の場合
    if @actor_command_window.index == 0
      # アクターコマンドウィンドウを有効化
      @actor_command_window.active = true
      @actor_command_window.visible = true
      # ヘルプウィンドウを隠す
      @help_window.visible = false
    end
  end
  #--------------------------------------------------------------------------
  # ● アクター選択開始
  #--------------------------------------------------------------------------
  def start_actor_select
    # アクターアローを作成
    @actor_arrow = Arrow_Actor.new(@spriteset.viewport2)
    @actor_arrow.index = @actor_index
    # ヘルプウィンドウを関連付け
    @actor_arrow.help_window = @help_window
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
  end
  #--------------------------------------------------------------------------
  # ● アクター選択終了
  #--------------------------------------------------------------------------
  def end_actor_select
    # アクターアローを解放
    @actor_arrow.dispose
    @actor_arrow = nil
  end
  #--------------------------------------------------------------------------
  # ● スキル選択開始
  #--------------------------------------------------------------------------
  def start_skill_select
    # スキルウィンドウを作成
    @skill_window = Window_Skill.new(@active_battler)
    # ヘルプウィンドウを関連付け
    @skill_window.help_window = @help_window
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
  end
  #--------------------------------------------------------------------------
  # ● スキル選択終了
  #--------------------------------------------------------------------------
  def end_skill_select
    # スキルウィンドウを解放
    @skill_window.dispose
    @skill_window = nil
    # ヘルプウィンドウを隠す
    @help_window.visible = false
    # アクターコマンドウィンドウを有効化
    @actor_command_window.active = true
    @actor_command_window.visible = true
  end
  #--------------------------------------------------------------------------
  # ● アイテム選択開始
  #--------------------------------------------------------------------------
  def start_item_select
    # アイテムウィンドウを作成
    @item_window = Window_Item.new
    # ヘルプウィンドウを関連付け
    @item_window.help_window = @help_window
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
  end
  #--------------------------------------------------------------------------
  # ● アイテム選択終了
  #--------------------------------------------------------------------------
  def end_item_select
    # アイテムウィンドウを解放
    @item_window.dispose
    @item_window = nil
    # ヘルプウィンドウを隠す
    @help_window.visible = false
    # アクターコマンドウィンドウを有効化
    @actor_command_window.active = true
    @actor_command_window.visible = true
  end
end

#==============================================================================
# ■ Scene_Battle (分割定義 4)
#------------------------------------------------------------------------------
# 　バトル画面の処理を行うクラスです。
#==============================================================================

class Scene_Battle
  #--------------------------------------------------------------------------
  # ● メインフェーズ開始
  #--------------------------------------------------------------------------
  def start_phase4
    # フェーズ 4 に移行
    @phase = 4
    # ターン数カウント
    $game_temp.battle_turn += 1
    # バトルイベントの全ページを検索
    for index in 0...$data_troops[@troop_id].pages.size
      # イベントページを取得
      page = $data_troops[@troop_id].pages[index]
      # このページのスパンが [ターン] の場合
      if page.span == 1
        # 実行済みフラグをクリア
        $game_temp.battle_event_flags[index] = false
      end
    end
    # アクターを非選択状態に設定
    @actor_index = -1
    @active_battler = nil
    # パーティコマンドウィンドウを有効化
    @party_command_window.active = false
    @party_command_window.visible = false
    # アクターコマンドウィンドウを無効化
    @actor_command_window.active = false
    @actor_command_window.visible = false
    # メインフェーズフラグをセット
    $game_temp.battle_main_phase = true
    # エネミーアクション作成
    for enemy in $game_troop.enemies
      enemy.make_action
    end
    # 行動順序作成
    make_action_orders
    # ステップ 1 に移行
    @phase4_step = 1
  end
  #--------------------------------------------------------------------------
  # ● 行動順序作成
  #--------------------------------------------------------------------------
  def make_action_orders
    # 配列 @action_battlers を初期化
    @action_battlers = []
    # エネミーを配列 @action_battlers に追加
    for enemy in $game_troop.enemies
      @action_battlers.push(enemy)
    end
    # アクターを配列 @action_battlers に追加
    for actor in $game_party.actors
      @action_battlers.push(actor)
    end
    # 全員のアクションスピードを決定
    for battler in @action_battlers
      battler.make_action_speed
    end
    # アクションスピードの大きい順に並び替え
    @action_battlers.sort! {|a,b|
      b.current_action.speed - a.current_action.speed }
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ)
  #--------------------------------------------------------------------------
  def update_phase4
    case @phase4_step
    when 1
      update_phase4_step1
    when 2
      update_phase4_step2
    when 3
      update_phase4_step3
    when 4
      update_phase4_step4
    when 5
      update_phase4_step5
    when 6
      update_phase4_step6
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 1 : アクション準備)
  #--------------------------------------------------------------------------
  def update_phase4_step1
    # ヘルプウィンドウを隠す
    @help_window.visible = false
    # 勝敗判定
    if judge
      # 勝利または敗北の場合 : メソッド終了
      return
    end
    # アクションを強制されているバトラーが存在しない場合
    if $game_temp.forcing_battler == nil
      # バトルイベントをセットアップ
      setup_battle_event
      # バトルイベント実行中の場合
      if $game_system.battle_interpreter.running?
        return
      end
    end
    # アクションを強制されているバトラーが存在する場合
    if $game_temp.forcing_battler != nil
      # 先頭に追加または移動
      @action_battlers.delete($game_temp.forcing_battler)
      @action_battlers.unshift($game_temp.forcing_battler)
    end
    # 未行動バトラーが存在しない場合 (全員行動した)
    if @action_battlers.size == 0
      # パーティコマンドフェーズ開始
      start_phase2
      return
    end
    # アニメーション ID およびコモンイベント ID を初期化
    @animation1_id = 0
    @animation2_id = 0
    @common_event_id = 0
    # 未行動バトラー配列の先頭からシフト
    @active_battler = @action_battlers.shift
    # すでに戦闘から外されている場合
    if @active_battler.index == nil
      return
    end
    # スリップダメージ
    if @active_battler.hp > 0 and @active_battler.slip_damage?
      @active_battler.slip_damage_effect
      @active_battler.damage_pop = true
    end
    # ステート自然解除
    @active_battler.remove_states_auto
    # ステータスウィンドウをリフレッシュ
    @status_window.refresh
    # ステップ 2 に移行
    @phase4_step = 2
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 2 : アクション開始)
  #--------------------------------------------------------------------------
  def update_phase4_step2
    # 強制アクションでなければ
    unless @active_battler.current_action.forcing
      # 制約が [敵を通常攻撃する] か [味方を通常攻撃する] の場合
      if @active_battler.restriction == 2 or @active_battler.restriction == 3
        # アクションに攻撃を設定
        @active_battler.current_action.kind = 0
        @active_battler.current_action.basic = 0
      end
      # 制約が [行動できない] の場合
      if @active_battler.restriction == 4
        # アクション強制対象のバトラーをクリア
        $game_temp.forcing_battler = nil
        # ステップ 1 に移行
        @phase4_step = 1
        return
      end
    end
    # 対象バトラーをクリア
    @target_battlers = []
    # アクションの種別で分岐
    case @active_battler.current_action.kind
    when 0  # 基本
      make_basic_action_result
    when 1  # スキル
      make_skill_action_result
    when 2  # アイテム
      make_item_action_result
    end
    # ステップ 3 に移行
    if @phase4_step == 2
      @phase4_step = 3
    end
  end
  #--------------------------------------------------------------------------
  # ● 基本アクション 結果作成
  #--------------------------------------------------------------------------
  def make_basic_action_result
    # 攻撃の場合
    if @active_battler.current_action.basic == 0
      # アニメーション ID を設定
      @animation1_id = @active_battler.animation1_id
      @animation2_id = @active_battler.animation2_id
      # 行動側バトラーがエネミーの場合
      if @active_battler.is_a?(Game_Enemy)
        if @active_battler.restriction == 3
          target = $game_troop.random_target_enemy
        elsif @active_battler.restriction == 2
          target = $game_party.random_target_actor
        else
          index = @active_battler.current_action.target_index
          target = $game_party.smooth_target_actor(index)
        end
      end
      # 行動側バトラーがアクターの場合
      if @active_battler.is_a?(Game_Actor)
        if @active_battler.restriction == 3
          target = $game_party.random_target_actor
        elsif @active_battler.restriction == 2
          target = $game_troop.random_target_enemy
        else
          index = @active_battler.current_action.target_index
          target = $game_troop.smooth_target_enemy(index)
        end
      end
      # 対象側バトラーの配列を設定
      @target_battlers = [target]
      # 通常攻撃の効果を適用
      for target in @target_battlers
        target.attack_effect(@active_battler)
      end
      return
    end
    # 防御の場合
    if @active_battler.current_action.basic == 1
      # ヘルプウィンドウに "防御" を表示
      @help_window.set_text($data_system.words.guard, 1)
      return
    end
    # 逃げるの場合
    if @active_battler.is_a?(Game_Enemy) and
       @active_battler.current_action.basic == 2
      # ヘルプウィンドウに "逃げる" を表示
      @help_window.set_text("逃げる", 1)
      # 逃げる
      @active_battler.escape
      return
    end
    # 何もしないの場合
    if @active_battler.current_action.basic == 3
      # アクション強制対象のバトラーをクリア
      $game_temp.forcing_battler = nil
      # ステップ 1 に移行
      @phase4_step = 1
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● スキルまたはアイテムの対象側バトラー設定
  #     scope : スキルまたはアイテムの効果範囲
  #--------------------------------------------------------------------------
  def set_target_battlers(scope)
    # 行動側バトラーがエネミーの場合
    if @active_battler.is_a?(Game_Enemy)
      # 効果範囲で分岐
      case scope
      when 1  # 敵単体
        index = @active_battler.current_action.target_index
        @target_battlers.push($game_party.smooth_target_actor(index))
      when 2  # 敵全体
        for actor in $game_party.actors
          if actor.exist?
            @target_battlers.push(actor)
          end
        end
      when 3  # 味方単体
        index = @active_battler.current_action.target_index
        @target_battlers.push($game_troop.smooth_target_enemy(index))
      when 4  # 味方全体
        for enemy in $game_troop.enemies
          if enemy.exist?
            @target_battlers.push(enemy)
          end
        end
      when 5  # 味方単体 (HP 0) 
        index = @active_battler.current_action.target_index
        enemy = $game_troop.enemies[index]
        if enemy != nil and enemy.hp0?
          @target_battlers.push(enemy)
        end
      when 6  # 味方全体 (HP 0) 
        for enemy in $game_troop.enemies
          if enemy != nil and enemy.hp0?
            @target_battlers.push(enemy)
          end
        end
      when 7  # 使用者
        @target_battlers.push(@active_battler)
      end
    end
    # 行動側バトラーがアクターの場合
    if @active_battler.is_a?(Game_Actor)
      # 効果範囲で分岐
      case scope
      when 1  # 敵単体
        index = @active_battler.current_action.target_index
        @target_battlers.push($game_troop.smooth_target_enemy(index))
      when 2  # 敵全体
        for enemy in $game_troop.enemies
          if enemy.exist?
            @target_battlers.push(enemy)
          end
        end
      when 3  # 味方単体
        index = @active_battler.current_action.target_index
        @target_battlers.push($game_party.smooth_target_actor(index))
      when 4  # 味方全体
        for actor in $game_party.actors
          if actor.exist?
            @target_battlers.push(actor)
          end
        end
      when 5  # 味方単体 (HP 0) 
        index = @active_battler.current_action.target_index
        actor = $game_party.actors[index]
        if actor != nil and actor.hp0?
          @target_battlers.push(actor)
        end
      when 6  # 味方全体 (HP 0) 
        for actor in $game_party.actors
          if actor != nil and actor.hp0?
            @target_battlers.push(actor)
          end
        end
      when 7  # 使用者
        @target_battlers.push(@active_battler)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● スキルアクション 結果作成
  #--------------------------------------------------------------------------
  def make_skill_action_result
    # スキルを取得
    @skill = $data_skills[@active_battler.current_action.skill_id]
    # 強制アクションでなければ
    unless @active_battler.current_action.forcing
      # SP 切れなどで使用できなくなった場合
      unless @active_battler.skill_can_use?(@skill.id)
        # アクション強制対象のバトラーをクリア
        $game_temp.forcing_battler = nil
        # ステップ 1 に移行
        @phase4_step = 1
        return
      end
    end
    # SP 消費
    @active_battler.sp -= @skill.sp_cost
    # ステータスウィンドウをリフレッシュ
    @status_window.refresh
    # ヘルプウィンドウにスキル名を表示
    @help_window.set_text(@skill.name, 1)
    # アニメーション ID を設定
    @animation1_id = @skill.animation1_id
    @animation2_id = @skill.animation2_id
    # コモンイベント ID を設定
    @common_event_id = @skill.common_event_id
    # 対象側バトラーを設定
    set_target_battlers(@skill.scope)
    # スキルの効果を適用
    for target in @target_battlers
      target.skill_effect(@active_battler, @skill)
    end
  end
  #--------------------------------------------------------------------------
  # ● アイテムアクション 結果作成
  #--------------------------------------------------------------------------
  def make_item_action_result
    # アイテムを取得
    @item = $data_items[@active_battler.current_action.item_id]
    # アイテム切れなどで使用できなくなった場合
    unless $game_party.item_can_use?(@item.id)
      # ステップ 1 に移行
      @phase4_step = 1
      return
    end
    # 消耗品の場合
    if @item.consumable
      # 使用したアイテムを 1 減らす
      $game_party.lose_item(@item.id, 1)
    end
    # ヘルプウィンドウにアイテム名を表示
    @help_window.set_text(@item.name, 1)
    # アニメーション ID を設定
    @animation1_id = @item.animation1_id
    @animation2_id = @item.animation2_id
    # コモンイベント ID を設定
    @common_event_id = @item.common_event_id
    # 対象を決定
    index = @active_battler.current_action.target_index
    target = $game_party.smooth_target_actor(index)
    # 対象側バトラーを設定
    set_target_battlers(@item.scope)
    # アイテムの効果を適用
    for target in @target_battlers
      target.item_effect(@item)
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 3 : 行動側アニメーション)
  #--------------------------------------------------------------------------
  def update_phase4_step3
    # 行動側アニメーション (ID が 0 の場合は白フラッシュ)
    if @animation1_id == 0
      @active_battler.white_flash = true
    else
      @active_battler.animation_id = @animation1_id
      @active_battler.animation_hit = true
    end
    # ステップ 4 に移行
    @phase4_step = 4
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 4 : 対象側アニメーション)
  #--------------------------------------------------------------------------
  def update_phase4_step4
    # 対象側アニメーション
    for target in @target_battlers
      target.animation_id = @animation2_id
      target.animation_hit = (target.damage != "Miss")
    end
    # アニメーションの長さにかかわらず、最低 8 フレーム待つ
    @wait_count = 8
    # ステップ 5 に移行
    @phase4_step = 5
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 5 : ダメージ表示)
  #--------------------------------------------------------------------------
  def update_phase4_step5
    # ヘルプウィンドウを隠す
    @help_window.visible = false
    # ステータスウィンドウをリフレッシュ
    @status_window.refresh
    # ダメージ表示
    for target in @target_battlers
      if target.damage != nil
        target.damage_pop = true
      end
    end
    # ステップ 6 に移行
    @phase4_step = 6
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (メインフェーズ ステップ 6 : リフレッシュ)
  #--------------------------------------------------------------------------
  def update_phase4_step6
    # アクション強制対象のバトラーをクリア
    $game_temp.forcing_battler = nil
    # コモンイベント ID が有効の場合
    if @common_event_id > 0
      # イベントをセットアップ
      common_event = $data_common_events[@common_event_id]
      $game_system.battle_interpreter.setup(common_event.list, 0)
    end
    # ステップ 1 に移行
    @phase4_step = 1
  end
end

#==============================================================================
# ■ Scene_Shop
#------------------------------------------------------------------------------
# 　ショップ画面の処理を行うクラスです。
#==============================================================================

class Scene_Shop
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # ヘルプウィンドウを作成
    @help_window = Window_Help.new
    # コマンドウィンドウを作成
    @command_window = Window_ShopCommand.new
    # ゴールドウィンドウを作成
    @gold_window = Window_Gold.new
    @gold_window.x = 480
    @gold_window.y = 64
    # ダミーウィンドウを作成
    @dummy_window = Window_Base.new(0, 128, 640, 352)
    # 購入ウィンドウを作成
    @buy_window = Window_ShopBuy.new($game_temp.shop_goods)
    @buy_window.active = false
    @buy_window.visible = false
    @buy_window.help_window = @help_window
    # 売却ウィンドウを作成
    @sell_window = Window_ShopSell.new
    @sell_window.active = false
    @sell_window.visible = false
    @sell_window.help_window = @help_window
    # 個数入力ウィンドウを作成
    @number_window = Window_ShopNumber.new
    @number_window.active = false
    @number_window.visible = false
    # ステータスウィンドウを作成
    @status_window = Window_ShopStatus.new
    @status_window.visible = false
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @help_window.dispose
    @command_window.dispose
    @gold_window.dispose
    @dummy_window.dispose
    @buy_window.dispose
    @sell_window.dispose
    @number_window.dispose
    @status_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @help_window.update
    @command_window.update
    @gold_window.update
    @dummy_window.update
    @buy_window.update
    @sell_window.update
    @number_window.update
    @status_window.update
    # コマンドウィンドウがアクティブの場合: update_command を呼ぶ
    if @command_window.active
      update_command
      return
    end
    # 購入ウィンドウがアクティブの場合: update_buy を呼ぶ
    if @buy_window.active
      update_buy
      return
    end
    # 売却ウィンドウがアクティブの場合: update_sell を呼ぶ
    if @sell_window.active
      update_sell
      return
    end
    # 個数入力ウィンドウがアクティブの場合: update_number を呼ぶ
    if @number_window.active
      update_number
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (コマンドウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_command
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # マップ画面に切り替え
      $scene = Scene_Map.new
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # 購入する
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ウィンドウの状態を購入モードへ
        @command_window.active = false
        @dummy_window.visible = false
        @buy_window.active = true
        @buy_window.visible = true
        @buy_window.refresh
        @status_window.visible = true
      when 1  # 売却する
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ウィンドウの状態を売却モードへ
        @command_window.active = false
        @dummy_window.visible = false
        @sell_window.active = true
        @sell_window.visible = true
        @sell_window.refresh
      when 2  # やめる
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # マップ画面に切り替え
        $scene = Scene_Map.new
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (購入ウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_buy
    # ステータスウィンドウのアイテムを設定
    @status_window.item = @buy_window.item
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # ウィンドウの状態を初期モードへ
      @command_window.active = true
      @dummy_window.visible = true
      @buy_window.active = false
      @buy_window.visible = false
      @status_window.visible = false
      @status_window.item = nil
      # ヘルプテキストを消去
      @help_window.set_text("")
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アイテムを取得
      @item = @buy_window.item
      # アイテムが無効の場合、または価格が所持金より上の場合
      if @item == nil or @item.price > $game_party.gold
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # アイテムの所持数を取得
      case @item
      when RPG::Item
        number = $game_party.item_number(@item.id)
      when RPG::Weapon
        number = $game_party.weapon_number(@item.id)
      when RPG::Armor
        number = $game_party.armor_number(@item.id)
      end
      # すでに 99 個所持している場合
      if number == 99
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # 最大購入可能個数を計算
      max = @item.price == 0 ? 99 : $game_party.gold / @item.price
      max = [max, 99 - number].min
      # ウィンドウの状態を個数入力モードへ
      @buy_window.active = false
      @buy_window.visible = false
      @number_window.set(@item, max, @item.price)
      @number_window.active = true
      @number_window.visible = true
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (売却ウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_sell
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # ウィンドウの状態を初期モードへ
      @command_window.active = true
      @dummy_window.visible = true
      @sell_window.active = false
      @sell_window.visible = false
      @status_window.item = nil
      # ヘルプテキストを消去
      @help_window.set_text("")
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # アイテムを取得
      @item = @sell_window.item
      # ステータスウィンドウのアイテムを設定
      @status_window.item = @item
      # アイテムが無効の場合、または価格が 0 (売却不可) の場合
      if @item == nil or @item.price == 0
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # アイテムの所持数を取得
      case @item
      when RPG::Item
        number = $game_party.item_number(@item.id)
      when RPG::Weapon
        number = $game_party.weapon_number(@item.id)
      when RPG::Armor
        number = $game_party.armor_number(@item.id)
      end
      # 最大売却個数 = アイテムの所持数
      max = number
      # ウィンドウの状態を個数入力モードへ
      @sell_window.active = false
      @sell_window.visible = false
      @number_window.set(@item, max, @item.price / 2)
      @number_window.active = true
      @number_window.visible = true
      @status_window.visible = true
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (個数入力ウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_number
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # 個数入力ウィンドウを非アクティブ・不可視に設定
      @number_window.active = false
      @number_window.visible = false
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # 購入する
        # ウィンドウの状態を購入モードへ
        @buy_window.active = true
        @buy_window.visible = true
      when 1  # 売却する
        # ウィンドウの状態を売却モードへ
        @sell_window.active = true
        @sell_window.visible = true
        @status_window.visible = false
      end
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # ショップ SE を演奏
      $game_system.se_play($data_system.shop_se)
      # 個数入力ウィンドウを非アクティブ・不可視に設定
      @number_window.active = false
      @number_window.visible = false
      # コマンドウィンドウのカーソル位置で分岐
      case @command_window.index
      when 0  # 購入する
        # 購入処理
        $game_party.lose_gold(@number_window.number * @item.price)
        case @item
        when RPG::Item
          $game_party.gain_item(@item.id, @number_window.number)
        when RPG::Weapon
          $game_party.gain_weapon(@item.id, @number_window.number)
        when RPG::Armor
          $game_party.gain_armor(@item.id, @number_window.number)
        end
        # 各ウィンドウをリフレッシュ
        @gold_window.refresh
        @buy_window.refresh
        @status_window.refresh
        # ウィンドウの状態を購入モードへ
        @buy_window.active = true
        @buy_window.visible = true
      when 1  # 売却する
        # 売却処理
        $game_party.gain_gold(@number_window.number * (@item.price / 2))
        case @item
        when RPG::Item
          $game_party.lose_item(@item.id, @number_window.number)
        when RPG::Weapon
          $game_party.lose_weapon(@item.id, @number_window.number)
        when RPG::Armor
          $game_party.lose_armor(@item.id, @number_window.number)
        end
        # 各ウィンドウをリフレッシュ
        @gold_window.refresh
        @sell_window.refresh
        @status_window.refresh
        # ウィンドウの状態を売却モードへ
        @sell_window.active = true
        @sell_window.visible = true
        @status_window.visible = false
      end
      return
    end
  end
end

#==============================================================================
# ■ Scene_Name
#------------------------------------------------------------------------------
# 　名前入力画面の処理を行うクラスです。
#==============================================================================

class Scene_Name
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # アクターを取得
    @actor = $game_actors[$game_temp.name_actor_id]
    # ウィンドウを作成
    @edit_window = Window_NameEdit.new(@actor, $game_temp.name_max_char)
    @input_window = Window_NameInput.new
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @edit_window.dispose
    @input_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @edit_window.update
    @input_window.update
    # B ボタンが押された場合
    if Input.repeat?(Input::B)
      # カーソル位置が 0 の場合
      if @edit_window.index == 0
        return
      end
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # 文字を削除
      @edit_window.back
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # カーソル位置が [決定] の場合
      if @input_window.character == nil
        # 名前が空の場合
        if @edit_window.name == ""
          # デフォルトの名前に戻す
          @edit_window.restore_default
          # 名前が空の場合
          if @edit_window.name == ""
            # ブザー SE を演奏
            $game_system.se_play($data_system.buzzer_se)
            return
          end
          # 決定 SE を演奏
          $game_system.se_play($data_system.decision_se)
          return
        end
        # アクターの名前を変更
        @actor.name = @edit_window.name
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # マップ画面に切り替え
        $scene = Scene_Map.new
        return
      end
      # カーソル位置が最大の場合
      if @edit_window.index == $game_temp.name_max_char
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 文字が空の場合
      if @input_window.character == ""
        # ブザー SE を演奏
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # 文字を追加
      @edit_window.add(@input_window.character)
      return
    end
  end
end

#==============================================================================
# ■ Scene_Gameover
#------------------------------------------------------------------------------
# 　ゲームオーバー画面の処理を行うクラスです。
#==============================================================================

class Scene_Gameover
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # ゲームオーバーグラフィックを作成
    @sprite = Sprite.new
    @sprite.bitmap = RPG::Cache.gameover($data_system.gameover_name)
    # BGM、BGS を停止
    $game_system.bgm_play(nil)
    $game_system.bgs_play(nil)
    # ゲームオーバー ME を演奏
    $game_system.me_play($data_system.gameover_me)
    # トランジション実行
    Graphics.transition(120)
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # トランジション準備
    Graphics.freeze
    # ゲームオーバーグラフィックを解放
    @sprite.bitmap.dispose
    @sprite.dispose
    # トランジション実行
    Graphics.transition(40)
    # トランジション準備
    Graphics.freeze
    # 戦闘テストの場合
    if $BTEST
      $scene = nil
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # タイトル画面に切り替え
      $scene = Scene_Title.new
    end
  end
end

#==============================================================================
# ■ Scene_Debug
#------------------------------------------------------------------------------
# 　デバッグ画面の処理を行うクラスです。
#==============================================================================

class Scene_Debug
  #--------------------------------------------------------------------------
  # ● メイン処理
  #--------------------------------------------------------------------------
  def main
    # ウィンドウを作成
    @left_window = Window_DebugLeft.new
    @right_window = Window_DebugRight.new
    @help_window = Window_Base.new(192, 352, 448, 128)
    @help_window.contents = Bitmap.new(406, 96)
    # 前回選択されていた項目を復帰
    @left_window.top_row = $game_temp.debug_top_row
    @left_window.index = $game_temp.debug_index
    @right_window.mode = @left_window.mode
    @right_window.top_id = @left_window.top_id
    # トランジション実行
    Graphics.transition
    # メインループ
    loop do
      # ゲーム画面を更新
      Graphics.update
      # 入力情報を更新
      Input.update
      # フレーム更新
      update
      # 画面が切り替わったらループを中断
      if $scene != self
        break
      end
    end
    # マップをリフレッシュ
    $game_map.refresh
    # トランジション準備
    Graphics.freeze
    # ウィンドウを解放
    @left_window.dispose
    @right_window.dispose
    @help_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    # ウィンドウを更新
    @right_window.mode = @left_window.mode
    @right_window.top_id = @left_window.top_id
    @left_window.update
    @right_window.update
    # 選択中の項目を記憶
    $game_temp.debug_top_row = @left_window.top_row
    $game_temp.debug_index = @left_window.index
    # レフトウィンドウがアクティブの場合: update_left を呼ぶ
    if @left_window.active
      update_left
      return
    end
    # ライトウィンドウがアクティブの場合: update_right を呼ぶ
    if @right_window.active
      update_right
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (レフトウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_left
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # マップ画面に切り替え
      $scene = Scene_Map.new
      return
    end
    # C ボタンが押された場合
    if Input.trigger?(Input::C)
      # 決定 SE を演奏
      $game_system.se_play($data_system.decision_se)
      # ヘルプを表示
      if @left_window.mode == 0
        text1 = "C (Enter) : ON / OFF"
        @help_window.contents.draw_text(4, 0, 406, 32, text1)
      else
        text1 = "← : -1   → : +1"
        text2 = "L (Pageup) : -10"
        text3 = "R (Pagedown) : +10"
        @help_window.contents.draw_text(4, 0, 406, 32, text1)
        @help_window.contents.draw_text(4, 32, 406, 32, text2)
        @help_window.contents.draw_text(4, 64, 406, 32, text3)
      end
      # ライトウィンドウをアクティブ化
      @left_window.active = false
      @right_window.active = true
      @right_window.index = 0
      return
    end
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新 (ライトウィンドウがアクティブの場合)
  #--------------------------------------------------------------------------
  def update_right
    # B ボタンが押された場合
    if Input.trigger?(Input::B)
      # キャンセル SE を演奏
      $game_system.se_play($data_system.cancel_se)
      # レフトウィンドウをアクティブ化
      @left_window.active = true
      @right_window.active = false
      @right_window.index = -1
      # ヘルプを消去
      @help_window.contents.clear
      return
    end
    # 選択されているスイッチ / 変数の ID を取得
    current_id = @right_window.top_id + @right_window.index
    # スイッチの場合
    if @right_window.mode == 0
      # C ボタンが押された場合
      if Input.trigger?(Input::C)
        # 決定 SE を演奏
        $game_system.se_play($data_system.decision_se)
        # ON / OFF を反転
        $game_switches[current_id] = (not $game_switches[current_id])
        @right_window.refresh
        return
      end
    end
    # 変数の場合
    if @right_window.mode == 1
      # 右ボタンが押された場合
      if Input.repeat?(Input::RIGHT)
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # 変数を 1 増やす
        $game_variables[current_id] += 1
        # 上限チェック
        if $game_variables[current_id] > 99999999
          $game_variables[current_id] = 99999999
        end
        @right_window.refresh
        return
      end
      # 左ボタンが押された場合
      if Input.repeat?(Input::LEFT)
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # 変数を 1 減らす
        $game_variables[current_id] -= 1
        # 下限チェック
        if $game_variables[current_id] < -99999999
          $game_variables[current_id] = -99999999
        end
        @right_window.refresh
        return
      end
      # R ボタンが押された場合
      if Input.repeat?(Input::R)
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # 変数を 10 増やす
        $game_variables[current_id] += 10
        # 上限チェック
        if $game_variables[current_id] > 99999999
          $game_variables[current_id] = 99999999
        end
        @right_window.refresh
        return
      end
      # L ボタンが押された場合
      if Input.repeat?(Input::L)
        # カーソル SE を演奏
        $game_system.se_play($data_system.cursor_se)
        # 変数を 10 減らす
        $game_variables[current_id] -= 10
        # 下限チェック
        if $game_variables[current_id] < -99999999
          $game_variables[current_id] = -99999999
        end
        @right_window.refresh
        return
      end
    end
  end
end

#==============================================================================
# ■ Main
#------------------------------------------------------------------------------
# 　各クラスの定義が終わった後、ここから実際の処理が始まります。
#==============================================================================

# begin
#   # トランジション準備
#   Graphics.freeze
#   # シーンオブジェクト (タイトル画面) を作成
#   $scene = Scene_Title.new
#   # $scene が有効な限り main メソッドを呼び出す
#   while $scene != nil
#     $scene.main
#   end
#   # フェードアウト
#   Graphics.transition(20)
# rescue Errno::ENOENT
#   # 例外 Errno::ENOENT を補足
#   # ファイルがオープンできなかった場合、メッセージを表示して終了する
#   filename = $!.message.sub("No such file or directory - ", "")
#   print("ファイル #{filename} が見つかりません。")
# end

module Kernel
  if RUBY_ENGINE == "opal"
    def load_data(path)
      file = RGSSEnv.file_read(path)
      obj = JSON.parse(file)
      if obj.is_a?(Array)
        obj3 = obj.map do |val|
          if val
            if val.is_a?(Hash)
              cls = Kernel.const_get(val["class_name"])
              obj2 = cls.allocate
              obj2.rpg_hash_load(val)
              obj2
            else
              val
            end
          else
            nil
          end
        end
      else
        cls = Kernel.const_get(obj["class_name"])
        obj2 = cls.allocate
        obj2.rpg_hash_load(obj)
        obj3 = obj2
      end
      obj3
    end
  elsif RUBY_ENGINE == "mruby"
    def load_data(path)
      if RGSS_ENABLE_MARSHAL
        if RGSS_MODE == :client
          file = RGSSEnv.file_read("rgss/" + path)
        else
          file = File.read(path)
        end
        Marshal.load(file)
      else
        if RGSS_MODE == :client
          file = RGSSEnv.file_read(path)
        else
          file = File.read("../" + path)
        end
        obj = JSON.parse(file)
        if obj.is_a?(Array)
          obj3 = obj.map do |val|
            if val
              if val.is_a?(Hash)
                cls = Kernel.const_get(val["class_name"])
                obj2 = cls.allocate
                obj2.rpg_hash_load(val)
                obj2
              else
                val
              end
            else
              nil
            end
          end
        else
          cls = Kernel.const_get(obj["class_name"])
          obj2 = cls.allocate
          obj2.rpg_hash_load(obj)
          obj3 = obj2
        end
        obj3
      end
    end
  else
    def load_data(path)
      file = File.binread(path)
      Marshal.load(file)
    end
  end
end

# # トランジション準備
# Graphics.freeze
# # シーンオブジェクト (タイトル画面) を作成
# $scene = Scene_Title.new
# # $scene が有効な限り main メソッドを呼び出す
# while $scene != nil
#   $scene.main
# end
# # フェードアウト
# Graphics.transition(20)

# class Cls
#   def initialize(val)
#     @val = val
#   end

#   def val
#     @val
#   end
# end

# obj = Cls.new(100)
# obj = "test"
# bin = Marshal.dump(obj)
# obj2 = Marshal.load(bin)
# p obj2

module RGSSMain
  def self.init_rgss
    $main_fiber = Fiber.new do
      # トランジション準備
      Graphics.freeze
      # シーンオブジェクト (タイトル画面) を作成
      $scene = Scene_Title.new
      # $scene が有効な限り main メソッドを呼び出す
      while $scene != nil
        $scene.main
      end
      # フェードアウト
      Graphics.transition(20)
    end
  end

  def self.update_rgss
    $main_fiber.resume
  end
end

if RGSS_MODE == :server
  RGSSMain.init_rgss
  loop do
    RGSSMain.update_rgss
  end
end

